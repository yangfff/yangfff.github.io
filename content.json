{"meta":{"title":"小萝莉的游乐园","subtitle":null,"description":"一jio一个坑,向着敌人的炮火前进!","author":"yangfff","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-31T06:27:04.534Z","updated":"2019-07-31T06:27:04.534Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-29T16:40:10.568Z","updated":"2019-07-29T16:40:10.568Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-29T16:40:48.442Z","updated":"2019-07-29T16:40:48.442Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-07-31T02:22:19.081Z","updated":"2019-07-31T02:22:19.081Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2019-07-29T16:41:54.693Z","updated":"2019-07-29T16:41:54.693Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-29T16:41:16.020Z","updated":"2019-07-29T16:41:16.020Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML5-Canvas的基本功能","slug":"HTML5-Canvas的基本功能","date":"2019-08-16T05:36:25.000Z","updated":"2019-08-16T09:29:25.029Z","comments":true,"path":"2019/08/16/HTML5-Canvas的基本功能/","link":"","permalink":"http://yoursite.com/2019/08/16/HTML5-Canvas的基本功能/","excerpt":"利用 Canvas 的 API，展示一些基本图形的绘制及操作方法，包括画线、画图、文字操作及图片操作等。（内含代码清单）","text":"利用 Canvas 的 API，展示一些基本图形的绘制及操作方法，包括画线、画图、文字操作及图片操作等。（内含代码清单） 一、绘制基本图形1.1 画线简约版： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 10; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); ctx.moveTo(10,10); ctx.lineTo(150,50); ctx.stroke(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;注释版： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;body&gt; /*在HTML中嵌入Canvas标签，如果浏览器不支持Canvas标签，那么浏览器会自动跳过Canvas标签，运行Canvas内部HTML代码*/ &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*获取HTML中的Canvas标签*/ var c=document.getElementById(&quot;myCanvas&quot;); /*返回一个用来绘制环境类型的环境，目前只支持2d环境*/ var ctx=c.getContext(&quot;2d&quot;); /*线宽*/ ctx.lineWidth = 10; /*笔画颜色，这里颜色值可以是英文字母、RGB值、十六进制颜色*/ ctx.strokeStyle = &quot;red&quot;; /*线帽有三种，分别是butt、round、square butt:默认。向线条的每个末端添加平直的边缘。 round:向线条的每个末端添加圆形线帽。 square:向线条的每个末端添加正方形线帽。*/ ctx.lineCup=&quot;butt&quot;; /*创建一个新路径*/ ctx.beginPath(); /*画笔光标起始位置*/ ctx.moveTo(10,10); /*画笔光标终止位置*/ ctx.lineTo(150,50); /*开始绘制定义好的路径*/ ctx.stroke(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;1.2 画矩形空心矩形： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 10; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ ctx.strokeRect(10,10,70,40); &lt;/script&gt;注：ctx.strokeRect(10,10,70,40);等价于ctx.rect(10,10,70,40);ctx.stroke(); 实心矩形： /*使用fillRect函数*/ &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;red&quot;; ctx.beginPath(); /*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ ctx.fillRect(10,10,70,40); &lt;/script&gt;注：ctx.fillRect(10,10,70,40);等价于ctx.rect(10,10,70,40);ctx.fill(); 1.3 画圆圆其实就是360度的圆弧。在Canvas中，可使用arc函数来画一个圆弧。 空心圆： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 5; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用arc函数绘制圆弧，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ ctx.arc(100,100,70,0,360*Math.PI/180,true); ctx.stroke(); &lt;/script&gt;实心圆： /*使用fill函数*/ &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 5; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用arc函数绘制矩形，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ ctx.arc(100,100,70,0,360*Math.PI/180,true); ctx.fill(); &lt;/script&gt;1.4 圆角矩形Canvas中没有直接画圆角矩形的API，但是我么可以用arcTo函数完成圆角的绘制，然后结合直线绘制，就可以完成圆角矩形的绘制了。 绘制一个圆角： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(70,20); /*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ ctx.arcTo(120,30,120,70,50); ctx.lineTo(120,120); ctx.stroke(); &lt;/script&gt;绘制圆角矩形： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(40,20); ctx.lineTo(100,20); /*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ ctx.arcTo(120,20,120,40,20); ctx.lineTo(120,70); ctx.arcTo(120,90,100,90,20); ctx.lineTo(40,90); ctx.arcTo(20，90，20，70，20); ctx.lineTo(20，40); ctx.arcTo(20，20，40，20，20); ctx.stroke(); &lt;/script&gt;1.5 擦除Canvas画板使用clearRect函数擦除一个矩形区域。他需要4个参数：起点坐标x、坐标y、擦除区域的长和宽。 绘制一个红色实心矩形，再擦除一个50*50的小矩形： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;red&quot;; ctx.beginPath(); ctx.fillRect(10,10,200,100); ctx.clearRect(30,30,50,50); ctx.stroke(); &lt;/script&gt;二、绘制复杂图形2.1 画曲线二次贝塞尔曲线： 二次贝塞尔曲线有一个控制点，再Canvas中用quadraticCurveTo(cpx,cpy,x,y)函数绘制。cpx,cpy表示控制点的坐标，x，y表示终点坐标。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(100,100); ctx.quadraticCurveTo(20,50,200,20); ctx.stroke(); &lt;/script&gt; 三次贝塞尔曲线： 二次、三次贝塞尔曲线的区别在于三次的有两个控制点。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(68，130); var cX1 = 20; var cY1 = 10; var cX2 = 268; var cY2 = 10; var endX = 268; var endY = 170; ctx.bezierCurveTo(cX1,cY1,cX2,cY2,endC,endY); ctx.stroke(); &lt;/script&gt;2.2 利用clip在指定区域绘图clip函数使用当前路径作为绘制操作的剪辑区域。可以理解为窗户，不论绘制了多大的图形，最后看到的图像只能由clip这扇窗来决定。 先画圆，使用clip，再画矩形，最后只能看到圆 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.arc(100,100,40,0,360*Math.PI/180,true); ctx.clip(); ctx.beginPath(); //设定颜色 ctx.fillStyle=&quot;lightblue&quot;; //绘制矩形 ctx.fillRect(0,0,300,150); &lt;/script&gt;2.3 绘制自定义图形结合各种方法，绘制特殊图形，例如： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(100, 150); ctx.bezierCurveTo(50, 100, 100, 0, 150, 50); ctx.bezierCurveTo(200, 0, 250, 100, 200, 150); ctx.bezierCurveTo(250, 200, 200, 300, 150, 250); ctx.bezierCurveTo( 100, 300, 50, 200,100, 150); ctx.closePath(); ctx.moveTo(100, 150); ctx.lineTo(150, 50); ctx.lineTo(200, 150); ctx.lineTo(150, 250); ctx.lineTo(100, 150); ctx.lineWidth = 5; ctx.strokeStyle = &quot;#ff0000&quot;; ctx.stroke(); &lt;/script&gt; 三、绘制文本3.1 绘制文字使用fillText绘制实心文字 fillText(text,x,y,max Width)函数，4各参数分别是：文本字符串、坐标x、坐标y、文本宽度。其中文本宽度可以省略，当其省略时，文本宽度会自动定为整个文本的宽度。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); //设定文字大小和字体 ctx.font=&quot;30px Arial&quot;; //描画文字 ctx.fillText(&quot;Hello World&quot;,100,50); //或添加文本宽度参数： //ctx.fillText(&quot;Hello World&quot;,100,50,50); &lt;/script&gt;使用strokeText绘制空心文字：strokeText与fillText用法相同，只是fillText为实心文字，strokeText为空心文字 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); //设定文字大小和字体 ctx.font=&quot;30px Arial&quot;; //描画文字 ctx.strokeText(&quot;Hello World&quot;,100,50); &lt;/script&gt;3.2 文字设置3.2.1 文字大小使用font参数：例如：ctx.font=”50px Arial”; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定文字大小为30px ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,50); ctx.beginPath(); //设定文字大小为50px ctx.font=&quot;50px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,150); ctx.beginPath(); //设定文字大小为100px ctx.font=&quot;70px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,250); &lt;/script&gt;3.2.2 文字字体&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定文字字体为Arial ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World (Arial)&quot;,50,50); ctx.beginPath(); //设定文字字体为Verdana ctx.font=&quot;30px Verdana&quot;; ctx.fillText(&quot;Hello World (Verdana)&quot;,50,100); ctx.beginPath(); //设定文字字体为Times New Roman ctx.font=&quot;30px Times New Roman&quot;; ctx.fillText(&quot;Hello World (Times New Roman)&quot;,50,150); ctx.beginPath(); //设定文字字体为Courier New ctx.font=&quot;30px Courier New&quot;; ctx.fillText(&quot;Hello World (Courier New)&quot;,50,200); ctx.beginPath(); //设定文字字体为serif ctx.font=&quot;30px serif&quot;; ctx.fillText(&quot;Hello World (serif)&quot;,50,250); ctx.beginPath(); //设定文字字体为sans-serif ctx.font=&quot;30px sans-serif&quot;; ctx.fillText(&quot;Hello World (sans-serif)&quot;,50,300); &lt;/script&gt; 3.2.3 文字粗体效果&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定font-weight为normal ctx.font=&apos;normal 30px Arial&apos;; ctx.fillText(&quot;Hello World (normal)&quot;,50,50); ctx.beginPath(); //设定font-weight为bold ctx.font=&apos;bold 30px Arial&apos;; ctx.fillText(&quot;Hello World (bold)&quot;,50,90); ctx.beginPath(); //设定font-weight为bolder ctx.font=&apos;bolder 30px Arial&apos;; ctx.fillText(&quot;Hello World (bolder)&quot;,50,130); ctx.beginPath(); //设定font-weight为lighter ctx.font=&apos;lighter 30px Arial&apos;; ctx.fillText(&quot;Hello World (lighter)&quot;,50,170); ctx.beginPath(); //设定font-weight为100 ctx.font=&apos;100 30px Arial&apos;; ctx.fillText(&quot;Hello World (100)&quot;,50,210); ctx.beginPath(); //设定font-weight为600 ctx.font=&apos;600 30px Arial&apos;; ctx.fillText(&quot;Hello World (600)&quot;,50,250); ctx.beginPath(); //设定font-weight为900 ctx.font=&apos;900 30px Arial&apos;; ctx.fillText(&quot;Hello World (900)&quot;,50,290); &lt;/script&gt; 3.2.4 文字斜体效果&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定font-weight为normal ctx.font=&apos;normal 30px Arial&apos;; ctx.fillText(&quot;Hello World (normal)&quot;,50,50); ctx.beginPath(); //设定font-style为italic ctx.font=&apos;italic 30px Arial&apos;; ctx.fillText(&quot;Hello World (italic)&quot;,50,90); ctx.beginPath(); //设定font-style为oblique ctx.font=&apos;oblique 30px Arial&apos;; ctx.fillText(&quot;Hello World (oblique)&quot;,50,130); &lt;/script&gt;3.3 文字的对齐效果3.3.1 水平对齐&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(160,0); ctx.lineTo(160,300); ctx.stroke(); ctx.beginPath(); ctx.textAlign=&apos;start&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,50); ctx.beginPath(); ctx.textAlign=&apos;end&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,100); ctx.beginPath(); ctx.textAlign=&apos;left&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,150); ctx.beginPath(); ctx.textAlign=&apos;center&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,200); ctx.beginPath(); ctx.textAlign=&apos;right&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,250); &lt;/script&gt; 3.3.2 竖直对齐&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&apos;myCanvas&apos;); var ctx=c.getContext(&apos;2d&apos;); ctx.textBaseline=&apos;alphabetic&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,50); ctx.moveTo(0,50); ctx.lineTo(250,50); ctx.stroke(); ctx.textBaseline=&apos;bottom&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,100); ctx.moveTo(0,100); ctx.lineTo(250,100); ctx.stroke(); ctx.textBaseline=&apos;hanging&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,150); ctx.moveTo(0,150); ctx.lineTo(250,150); ctx.stroke(); ctx.textBaseline=&apos;ideographic&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,200); ctx.moveTo(0,200); ctx.lineTo(250,200); ctx.stroke(); ctx.textBaseline=&apos;middle&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,250); ctx.moveTo(0,250); ctx.lineTo(250,250); ctx.stroke(); ctx.textBaseline=&apos;top&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,300); ctx.moveTo(0,300); ctx.lineTo(250,300); ctx.stroke(); &lt;/script&gt; 四、图片操作4.1 利用drawImage绘制图片drawImage函数有3种函数原型，语法如下： drawImages（image，dx, dy）;drawImages（image，dx, dy, dw, dh）;drawImages（image，sx, sy, sw, sh, dx, dy, dw, dh）; image是要绘制的对象，可以说HTMLImageRlement、HTML-CanvasElement或者HTMLVideoElement dx、dy是image在Canvas中定位的坐标值 dw、dh表示image在Canvas中即将绘制区域（相对dx、dy坐标的偏移量）的宽度与高度值 sx、sy是image所要绘制的起始位置 sw、sh表示image所要绘制区域（相对sw、sy坐标的偏移量）的宽度与高度值 方式1：在Canvas中通过标签的id取得图片数据 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; img标签&lt;br /&gt; &lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt; canvas画板&lt;br /&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt; 你的浏览器不支持HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var img=document.getElementById(&quot;face&quot;); img.onload = function(){ ctx.drawImage(img,10,10); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;步骤1：在html中加入标签 &lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt; 步骤2：在Canvas中通过标签的id取得图片数据 var img=document.getElementById(&quot;face&quot;); 步骤3：用drawImage函数江图片绘制到画板上 ctx.drawImage(img,10,10); 方式2：在Canvas中通过 JavaScript 的 Image 对象来获取数据（个人推荐这种） &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt; 你的浏览器不支持HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;步骤1：建立image对象 var image = new Image(); 步骤2：通过设置scr属性，载入图片 image.src = &quot;face.jpg&quot;; 步骤3：添加onload事件侦听，当图片载入完成时，将其绘制到画板 image.onload = function(){ ctx.drawImage(image,10,10); }; drawImage函数的3种函数原型的用法与区别： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ /*从坐标（10，10）开始绘制整张图片*/ ctx.drawImage(image,10,10); /*从坐标（260，10）开始绘制整张图片到长100、宽100的矩形区域内*/ ctx.drawImage(image,260,10,100,100); /*截取图片从（50，50）到（100，100）的部分，从坐标（260，130开始绘制，放大长100，宽100的矩形区域内）*/ ctx.drawImage(image,50,50,100,100,260,130,100,100); }; &lt;/script&gt; 4.2 利用getImageData和putImageData绘制图片（不推荐）putImageData（imagedata，dx, dy, sx, sy, sw, sh） imagedata为像素数据 dx、dy是绘制图片的定位坐标值 sx、sy是imagedata所要绘制图片的起始位置 sw、sh表示imagedata所要绘制区域（相对imagedata的sx、sy坐标的偏移量）的宽度与高度值 这里第四个参数及以后的所有参数都可以省略，如果省略则表示绘制整个imagedata。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); var imgData=ctx.getImageData(50,50,200,200); ctx.putImageData(imgData,10,260); ctx.putImageData(imgData,200,260,50,50,100,100); }; &lt;/script&gt;步骤1：图片数据读取完成后，首先江图片数据绘制到Canvas画板上 ctx.drawImage(image,10,10); 步骤2：用getImageData函数从画板上取得像素数据 var imgData=ctx.getImageData(50,50,200,200); 步骤3：将取得的整个像素数据绘制到画板上 ctx.putImageData(imgData,10,260); 或将取得的整个像素数据的一部分绘制到画板上 ctx.putImageData(imgData,200,260,50,50,100,100); 注意：这种方法种使用了getImageData函数获取图片数据，这个函数在Google Chrome等浏览器中会涉及跨域问题，所以无法直接在浏览器种浏览。必须通过服务器来访问。当然，我么可以在本地服务器是浏览。 4.3 利用createImageData新建像素createImageData函数有两种函数原型： 返回指定大小的imageData对象： createImageData（sw, sh）; 返回与指定对象相同大小的imageData对象 createImageData(imageData); 注意：通过createImageData返回的是一个空的imageData对象，必须要针对起像素进行复制才能显示到Canvas 画板上 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); var imgData=ctx.getImageData(50,50,200,200); var imgData01=ctx.createImageData(imgData); for (i=0; i&lt;imgData01.width*imgData01.height*4;i+=4){ imgData01.data[i+0]=255; imgData01.data[i+1]=0; imgData01.data[i+2]=0; imgData01.data[i+3]=255; } ctx.putImageData(imgData01,10,260); var imgData02=ctx.createImageData(100,100); for (i=0; i&lt;imgData02.width*imgData02.height*4;i+=4){ imgData02.data[i+0]=255; imgData02.data[i+1]=0; imgData02.data[i+2]=0; imgData02.data[i+3]=155; } ctx.putImageData(imgData02,220,260); }; &lt;/script&gt;代码解析： 图片数据读取完成后，首先将图片数据绘制到 Canvas 画板上。 ctx.drawImage(image,10,10); 用 getImageData 函数从画板上取得像素数据。 var imgData=ctx.getImageData(50,50,200,200); 使用 createImageData 返回与 imgData 相同大小的 ImageData 对象。 var imgData01=ctx.createImageData(imgData); imgData01 进行赋值。 for (i=0; i&lt;imgData01.widthimgData01.height4;i+=4){ imgData01.data[i+0]=255; imgData01.data[i+1]=0; imgData01.data[i+2]=0; imgData01.data[i+3]=255; } 利用 putImageData 将 imgData01 画到 Canvas 画板上。 ctx.putImageData(imgData01,10,260); 使用 createImageData 返回一个大小为 100×100 的 ImageData 对象。 var imgData02=ctx.createImageData(100,100); 对 imgData02 进行赋值。 for (i=0; i&lt;imgData02.widthimgData02.height4;i+=4){ imgData02.data[i+0]=255; imgData02.data[i+1]=0; imgData02.data[i+2]=0; imgData02.data[i+3]=155; } 利用 putImageData 将 imgData02 画到 Canvas 画板上。 ctx.putImageData(imgData02,220,260); 五、致谢写这篇学习总结的时候是学校开学的前夕，实验室还没有人。早上我给自己泡了一杯茶，累了就去弹两首古琴曲子然后继续回来学。这篇总结写完的时候，太阳的余辉正撒在我的书桌上。我抬头望着窗外的云朵，好像忽然懂了《时光恋旅人》里主角父亲穿越时空一遍遍看书的感受了，哈哈哈，在时空隧道里，想来我一个人也可以相处的很愉快吧。 本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第二章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"JavaScript中的面向对象","slug":"JavaScript中的面向对象","date":"2019-08-16T03:25:03.000Z","updated":"2019-08-16T05:08:22.454Z","comments":true,"path":"2019/08/16/JavaScript中的面向对象/","link":"","permalink":"http://yoursite.com/2019/08/16/JavaScript中的面向对象/","excerpt":"可以说，JavaScript 是一种基于对象的语言，但是，它又不是一种真正的面向对象的编程语言，因为它的语法中不存在 class（类）。 本节将分析和解决如何在 JavaScript 中实现封装和继承等面向对象的问题。","text":"可以说，JavaScript 是一种基于对象的语言，但是，它又不是一种真正的面向对象的编程语言，因为它的语法中不存在 class（类）。 本节将分析和解决如何在 JavaScript 中实现封装和继承等面向对象的问题。 一、类一个没有任何属性和方法的类的定义： function MyClass(){};其实这就是个简单函数的声明，这个函数就是一个类的定义的实现。 使用这个类： var cls1 = new MyClass();这样，利用 new 就可以生成 MyClass的一个实例了。 所以，在JavaScript中，可以说函数就是类，类就是函数。 一个实例的封装包含属性和方法的封装： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); alert(cls1.name + &quot;:&quot; + cls1.age);//[yf:18]在函数内使用 this 就能给函数本身增加属性值。上面的代码中就给 MyClass 函数增加了 name 和 age 两个属性。 利用this给这个类增加一个toString 方法： 方式1： function MyClass(name,age){ this.name = name; this.age = age; this.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString();//[yf:18]方式2（这种方式只是给 cls1 这个实例增加了方法，并未给 MyClass 本身增加方法。）： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; cls1.toString();//[yf:18]比如，使用方式2时下面的代码会出错 ： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; cls1.toString();//[yf:18] var cls2 = new MyClass(&quot;cx&quot;,19); cls2.toString();// 报错使用函数的prototype对象来添加方法： 每一个函数都会包含一个 prototype 属性，这个属性指向了一个 prototype 对象，我们可以指定函数对应的 prototype 对象。如果不指定，则函数的 prototype 属性将指向一个默认的 prototype 对象，并且此默认 prototype 对象的 constructor 属性又会指向该函数。 当用构造函数创建一个新的对象时，新的对象会获取构造函数的 prototype 属性所指向的 prototype 对象的所有属性和方法，这样一来，构造函数对应的 prototype 对象所做的任何操作都会反映到它所生成的对象上，所有的这些对象将共享与构造函数对应的 prototype 对象的属性和方法。 虽然新创建的对象可以使用它的构造函数所指向的 prototype 对象的属性和方法，但不能像构造函数那样直接调用 prototype 对象（对象没有 prototype 属性）。 简而言之，如果我么使用函数的prototype对象来给函数添加方法，那么创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这个函数的所有方法。 具体代码： function MyClass(name,age){ this.name = name; this.age = age; } MyClass.prototype.toString = function(){ alert(this.name + &quot;:&quot; + thus.age); } var cls1 = new MyClass(&quot;yf&quot;,18); clas1.toString();//[yf:18] var cls2 = new MyClass(&quot;cx&quot;,19); clas2.toString();//[cx:19]对于prototype对象来说，由于存在的是指向的关系，所以避免了不必要的浪费。 如果要加入多个方法，可以用下面的方式实现封装： function MyClass(name,age){ this.name = name; this.age = age; } MyClass.prototype = { toString:function(){ alert(this.name + &quot;:&quot; + thus.age); }; sayHello:function(){ alert(this.name + &quot;,你好!&quot;); }; } var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString();//[yf:18] cls1.sayHellow ();//[yf, 你好!]二、静态类其实，下面的函数本身就可以当作静态类来用 ： var StaticClass = function(){}; StaticClass.name = &quot;StaticName&quot;; StaticClass.Sum = function(value1,value2){ return value1 + value2; }; alert(StaticClass.name);//[StaticName] alert(StaticClass.Sum(1,3));//[4]这样，在使用静态类的时候，就无须创建新的实例了，可直接用“类名 + 点 + 属性或方法”的方式。 三、继承上面只讲了类的封装，那么如何实现类的继承呢？如有如下两个构造函数 ： function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ this.name = name; this.sex = sex; };属性的继承：使用 apply 方法将父对象的构造函数绑定在子对象上 function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ PeopleClass.apply(this, arguments); this.name = name; this.sex = sex; }; var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;); alert(stu.type);//[ 人 ]从运行结果来看，StudentClass 继承了 PeopleClass 的属性“人”。 方法的继承：循环使用父对象的 prototype 进行复制 function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ PeopleClass.apply(this, arguments); var prop; for(prop in PeopleClass.prototype){ var proto = this.constructor.prototype; if(!proto[prop]){ proto[prop] = PeopleClass.prototype[prop]; } proto[prop][&quot;super&quot;] = PeopleClass.prototype; } this.name = name; this.sex = sex; }; var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;); alert(stu.type);//[ 人 ] stu.getType();//[ 这是一个人 ]三、致谢本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第一章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5的代码清单","slug":"HTML5的代码清单","date":"2019-08-15T11:02:20.000Z","updated":"2019-08-15T11:28:58.887Z","comments":true,"path":"2019/08/15/HTML5的代码清单/","link":"","permalink":"http://yoursite.com/2019/08/15/HTML5的代码清单/","excerpt":"HTML5 有很多令人心动的特性和新功能，这里罗列了一些HTML5新特性的示例代码。包含使用 video 标签播放动画、使用 audio 标签播放音频、使用 Canvas 标签绘制图形、取得当前的位置、将大量的数据保存在客户端、form 的强化","text":"HTML5 有很多令人心动的特性和新功能，这里罗列了一些HTML5新特性的示例代码。包含使用 video 标签播放动画、使用 audio 标签播放音频、使用 Canvas 标签绘制图形、取得当前的位置、将大量的数据保存在客户端、form 的强化 一、HTML5新特性 强化了Web网页的表现性能，增加了本地数据库等 Web 应用的功能，以及图像操作等。 HTML5 在图像上引入了 Canvas 标签，通过 Canvas，用户可以动态生成各种图形图像、图表以及动画，而不再依赖于 Flash、silverlight 等插件了。 HTML5 在地理位置操作上引入了 Geolocation API，其特点在于 ： 本身不去获取用户的位置，而是通过第三方接口来获取，例如 IP、GPS、WIFI 等方式。 用户可以随时开启和关闭，在被程序调用时也会首先征得用户同意，保证了用户的隐私。 HTML5 还在数据储存上增加了本地数据库，可以使用 WebSQL 来储存数据，并且引入了 web storage API 实现了离线缓存功能，以此替代了 cookies，使得数据保存空间更大、更安全。 二、HTML5新特性代码清单2.1 使用 video 标签播放动画/*这段代码可以实现播放动画功能*/ &lt;video width=&quot;640&quot; height=&quot;360&quot; preload=&quot;auto&quot; poster=&quot;hoge.png&quot; controls autoplay&gt; &lt;!-- 针对播放 webm 格式动画的浏览器 --&gt; &lt;source src=&quot;hoge.webm&quot; type=&apos;video/webm; codecs=&quot;vp8, vorbis&quot;&apos;&gt; &lt;!-- 针对播放 ogv 格式动画的浏览器 -&gt; &lt;source src=&quot;hoge.ogv&quot; type=&apos;video/ogg; codecs=&quot;theora, vorbis&quot;&apos;&gt; &lt;!-- 针对播放 mp4 格式动画的浏览器 --&gt; &lt;source src=&quot;hoge.mp4&quot; type=&apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt; &lt;!-- 当浏览器无法使用 video 标签的时候 --&gt; &lt;p&gt; 无法播放动画。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt; &lt;/video&gt;2.2 使用 audio 标签播放音频/*这段代码可以实现音频播放功能*/ &lt;audio controls loop&gt; &lt;!-- 针对播放 ogg 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.ogg&quot;&gt; &lt;!-- 针对播放 wav 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.wav&quot;&gt; &lt;!-- 针对播放 mp3 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.mp3&quot;&gt; &lt;!-- 当浏览器无法使用 audio 标签的时候 --&gt; &lt;p&gt; 无法播放音频。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt; &lt;/audio&gt;2.3 使用 Canvas 标签绘制图形使用 Canvas 标签，只需要向 HTML5 里添加 Canvas 元素即可，代码如下 ： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;另外，Canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript内部完成。使用案例如下： 案例一： /*这段代码可以绘制一个矩形*/ &lt;canvas id=&quot;canvas&quot; width=&quot;640&quot; height=&quot;360&quot;&gt;&lt;/canvas&gt; &lt;script&gt; // 获取 context 对象 var canvas = document.getElementById(&apos;canvas&apos;); if(canvas.getContext){ var context = canvas.getContext(&apos;2d&apos;); // 设置颜色 context.fillStyle = &apos;rgb(255,0,0)&apos;; // 从坐标 (20,30) 开始，画一个 64×36 大小的矩形 context.fillRect(20,30,64,36); } &lt;/script&gt;案例二: /*这段代码可以须在 JavaScript 内部实现绘制一个矩形*/ onload = function() { draw(); }; function draw() { /* 使用 id 来寻找 Canvas 元素 */ var canvas = document.getElementById(&apos;canvassample&apos;); /* 验证 Canvas 元素是否存在，以及浏览器是否支持 Canvas 元素 */ if ( ! canvas || ! canvas.getContext ) return false; /* 创建 context 对象 */ var ctx = canvas.getContext(&apos;2d&apos;); /* 画一个红色矩形 */ cxt.fillStyle=&quot;#FF0000&quot;; cxt.fillRect(0,0,150,75); }2.4 轻松取得当前的位置/*这段代码可以获取当前位置的纬度和经度*/ &lt;script&gt; window.addEventListener(&apos;load&apos;. function () { // 判断可否使用 geolocation if(navigator.geolocation){ // 定期获取所在地 navigator.geolocation.watchPosition(update); } }, false); // 取得位置并表示 function update(position){ // 纬度 var lat = position.coords.latitude; // 经度 var lng = position.coords.longitude; // 把纬度和经度显示出来 document.write(&apos; 纬度 ：&apos;+lat+&apos;，经度 ：&apos;+lng); } &lt;/script&gt;2.5 将大量的数据保存在客户端/*这段代码中的 JavaScript 使用 LocalStorage 来保存大量的数据*/ &lt;script&gt; // 用 localStorage 来保存数据 localStorage.key = &apos; 想要保存的值 &apos;; // 将 localStorage 中的值取出来 var hoge = localStorage.key; //“想要保存的值”在页面上显示 document.write(hoge); &lt;/script&gt;2.6 form 的强化/*这段代码是form 的几个比较常用的功能*/ &lt;!-- 验证用户输入格式是否正确，只需要改变 type 的类型即可 --&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot;&gt; &lt;!-- 对于必须输入的项目，只需给 input 标签加上 require 属性即可 --&gt; &lt;input name=&quot;text&quot; type=&quot;text&quot; require&gt; &lt;!-- 当失去焦点的时候给出相应的提示，只需给 input 标签加上 placeholder 属性即可 --&gt; &lt;input name=&quot;text&quot; type=&quot;text&quot; placeholder=&quot; 例 ：姓名 &quot;&gt;","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"盒尺寸四大家族之margin与border","slug":"盒尺寸四大家族之margin与border","date":"2019-08-15T04:14:50.000Z","updated":"2019-08-15T11:30:04.083Z","comments":true,"path":"2019/08/15/盒尺寸四大家族之margin与border/","link":"","permalink":"http://yoursite.com/2019/08/15/盒尺寸四大家族之margin与border/","excerpt":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！","text":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！ 一、激进的margin属性 1.1 margin与元素尺寸以及相关布局这里的各类“尺寸”命名和对应的盒子类型全部参考自 jQuery 中与尺寸相关 API 的名称。 元素尺寸：对应 jQuery 中的$().width()和$().height()方法，包括 padding和 border，也就是元素的 border box 的尺寸。在原生的 DOM API 中写作 offsetWidth和 offsetHeight，所以，有时候也成为“元素偏移尺寸”。 元素内部尺寸：对应 jQuery 中的$().innerWidth()和$().innerHeight()方法，表示元素的内部区域尺寸，包括 padding 但不包括 border，也就是元素的 paddingbox 的尺寸。在原生的 DOM API 中写作 clientWidth 和 clientHeight，所以，有时候也称为“元素可视尺寸”。 元素外部尺寸：对应 jQuery 中的$().outerWidth(true)和$().outerHeight(true)方法，表示元素的外部尺寸，不仅包括 padding 和 border，还包括 margin，也就是元素的 margin box 的尺寸。没有相对应的原生的 DOM API。 注意：“外部尺寸”有个很不一样的特性，就是尺寸的大小有可能是负数 1.2 margin的百分比值1.3 正确看待CSS世界里的margin合并1.4 深入理解CSS中的margin：auto1.5 margin无效情形解析二、border属性2.1 为什么border-width不支持百分比值2.2 了解各种border-style类型2.3 border-color和color2.4 border与透明边框技巧2.5 border与图形构建2.6 border等高布局技术","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"盒尺寸四大家族之content与padding","slug":"盒尺寸四大家族","date":"2019-08-13T08:16:12.000Z","updated":"2019-08-14T09:30:30.001Z","comments":true,"path":"2019/08/13/盒尺寸四大家族/","link":"","permalink":"http://yoursite.com/2019/08/13/盒尺寸四大家族/","excerpt":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！","text":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！ 一、深入理解content 1.1 content与替换元素1.1.1 替换元素 替换元素：通过修改某个属性值呈现的内容就可以被替换的元素。 典型例子：&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;、表单元素&lt;textarea&gt;、&lt;input&gt;、 替换元素特点： 内容外观不受页面上的CSS影响 有自己的尺寸 在很多CSS属性上有自己的一套变现规则（例如vertical-align属性） 1.1.2 替换元素的默认dispaly值 用途：显示替换元素时候可以设置style.display=’inline’而无需style.display=’inline-block’。 1.1.3 替换元素的计算尺寸 替换元素的尺寸从内到外：固有尺寸、HTML尺寸、CSS尺寸 固有尺寸：固定大小，例如&lt;input&gt;:，此时的尺寸即为固有尺寸，使用px为单位。 HTML尺寸：只能通过HTML原生属性改变。如&lt;img width=&quot;300&quot; height=&quot;100&quot;&gt;: CSS尺寸：通过CSS设置的width和height或者max-width/min-width和max-height/min-height设置的尺寸对应盒尺寸的content box 应用：Web开发时，为提高加载性能以及节约带宽费用，首屏以下的图片就会通过滚屏加载的形式异步加载，然后，这个即将被异步加载的图片为了布局稳健、体验良好，往往使用一张透明的图片占位。例如 &lt;img scr=&quot;transparent.png&quot;&gt;实际上，这张透明的占位图片也是多余资源，我么直接： &lt;img&gt;然后配合CSS可以实现一样的效果： img { visibility: hidden; display: inline-block; } img[scr] {visibility: vidible; }注意：这里的直接没有scr属性，而是scr=””,scr=””这在很多浏览器下依然会有请求，而且请求的是当前页面数据。当图片的scr属性缺省时，图片不会有任何请求，这是最高效的实现方式。 1.1.4 替换元素与非替换元素观点1：他们之间只隔了一个src属性。应用案例：基于伪元素的图片内容生成技术 观点2：他们之间只隔了一个CSS content属性。应用案例：使用content属性，让普通标签元素变成替换元素；完美的文字换图显示方案 HTML： &lt;img class=&quot;emoji&quot; src=&quot;laugh.png&quot;&gt; CSS： .emoji:hover { content: url(laugh-tear.png); }注意：想要在移动端使用该技术，建议换成SVG矢量图片 1.1.5 content与替换元素关系剖析 在CSS世界，我们把content属性生成的对象称为“匿名替换元素”，content属性生成的内容都是替换元素。 content属性生成的元素和普通元素内容有不同的特性表现： 使用content生成的文本是无法选择复制的 不能左右empty伪类（案例在此） content动态生成值无法获取 其他略 1.2 content内容生成技术实际项目中，content属性大都是用在：：before/：：after这两个伪元素中，所以“content内容生成技术”有时候也称“：：before/：：after伪元素技术” 1.2.1 content辅助元素生成案例content辅助元素与布局 1.2.2 content字符内容生成案例配合@font-face规则实现图标字体效果 案例content换行符与打点loading效果 1.2.3 content图片生成伪元素中的图片更多的是使用background-image模拟，类似： div：before { content：‘’; background： url(1.jpg); }content图片生成并不常用，因为不好控制图片尺寸，所以，只有不需要控制尺寸的图片才有优势。案例content图片生成与新标签页地址标记 1.2.4 content开启闭合图片生成可以针对不同语言指定不同的前后引号。但是这个功能很鸡肋，不如直接使用“”‘’方便。 &lt;p lang=&quot;ch&quot;&gt;&lt;q&gt;中文使用“”&lt;/q&gt;&lt;/p&gt; &lt;p lang=&quot;en&quot;&gt;&lt;q&gt;英文使用&quot;&quot;&lt;/q&gt;&lt;/p&gt; /*为不同的语言指定引号的表现*/ ：lang(ch) &gt; q { quotes: ‘“’ ‘”’；} ：lang(en) &gt; q { quotes: ‘&quot;’ ‘&quot;’；} /*在q标签前后插入引号*/ q:before { content: open-quote;} q:after { content: close-quote;}1.2.5 content atter属性值内容生成这个功能比较实用，案例src缺省时img元素的alt信息展示 1.2.6 深入了解content计数器计数器效果可以说是content部分的重中之重，因为此功能强大、实用、且不具有可替代性，甚至可以实现连JavaScript都实现不好的功能。 CSS计数器就和我们军训报数一样，班级命名、报数规则、开始报数，这三个关键点刚好对应CSS计数器的两个属性和一个方法。 1、属性counter-reset（计数器-重置） 注意：如果不设置，默认起始值为0。 /*确定计数器名称wangxiaoer，起始值2*/ .xxx { counter-reset: wangxiaoer 2;}完整案例： CSS计数器counter-reset值为2 CSS计数器counter-reset两个命名并存 2、属性counter-increment（计数器递增） 注意：如果不设置，默认变化值为1。 /*变化的值为2*/ counter-increament: counter 2 /*变化的值为-1*/ counter-increament: counter -1CSS计数器的技术规则：普照规则 普照规则:普照源（counter-reset）唯一，每普照（counter-increment）一次，普照源增加一次计数值。 案例： CSS计数器counter-reset/counter-increment递增 CSS计数器counter-increment父子连续普照与递增 CSS计数器counter-increment递增机制 3、方法counter（）/counters（） counter（）作用：显示计数、不过方法、用法多个 /*name是counter-reset的名称，style参数选择递增递减方式*/ counter（ name，style）style参数的作用是递增递减英文字母或者罗马文等案例：CSS计数器counter()方法style参数示意 counter支持级联：一个counter属性值可以有多个counter（）方法，案例：CSS计数器多个counter并存 counters（）：嵌套技术的代名词。 /*name是counter-reset的名称，string为字符串*/ counters（ name，string） /*也支持style*/ counters（ name，string, style）string为字符串,表示子序号的连接字符串，如1.1的string就是.,案例：CSS计数器counters的string参数与嵌套 注意：普照源是唯一的。要想实现嵌套，必须让每一个列表容器拥有一个“普照源”，通过子辈对父辈的counter-reset重置、配合counters（）方法才能实现计数嵌套效果。 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的大儿子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的大孙子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的二孙子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的小孙子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的三儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小三&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小四 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小四的大儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;错误示范：CSS计数器counters的错误示范 注意：这种计数效果在模拟书籍的目录效果时十分实用。这里需要强调的是：显示counter计数值的那个DOM元素在文档流中的位置一定要在counter-increment元素的后面，否则是没有技术效果的。 1.2.4 content内容生成的混合特性各种content内容生成语法是可以混合在一起使用的。 二、温和的padding属性padding性格温和，与人相处友好，在使用padding属性进行页面开发过程中，很少会出现意想不到的情况。 padding指的是盒子的内补间 2.1 padding与元素的尺寸因为CSS中默认的box-sizing是content-box,所以使用padding会增加元素的尺寸。 误区：内联元素的padding只会影响水平方向，不会影响垂直方向。这是错误的！ 正解：内联元素padding对视觉层和布局层具有双重影响。案例：内联元素垂直padding也有作用 应用： 利用padding的常规应用：在不影响当前布局的情况下，优雅的增加链接或按钮的点击区域大小。如 `article a { padding: .25em 0; }` 利用内联元素padding特性的应用：内联元素padding与高度可控的分隔线 标题下方留出一定位置： 源代码： &lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt; h3{ line-height: 30px; font-size: 14px; }现在： &lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt; h3{ line-height: 30px; font-size: 14px; h3 &gt; span { padding-top: 58px; }2.2 padding的百分比值 与margin属性不同，padding不支持负值 padding支持百分比值，且padding百分比值无论是水平方向还是竖直方向均是相对于宽度计算的。 /一个正方形/ div { padding: 50%; } /一个宽高比2：1的矩形/ div { padding: 25% 50%; } 应用案例：百分比padding值与等比例头图效果 2.3 标签元素内置的padding ol/ul列表内置padding-left，但是单位是px不是em。根据张鑫旭老师的经验，font-size是12-14px时，22px是一个比较好的padding-left设定值，所有浏览器都能正常显示，且非常贴近边缘。 ol,ul { padding-left:22px; } 很多表单都内置padding 案例：button 与 label 配合使用，使得即语义良好行为保留又UI效果好。 &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;label for=&quot;but&quot;&gt;按钮&lt;/label&gt; button{ position: absolute; clip: rect(0 0 0 0); } label{ display: inline-block; line-height: 20px; padding: 10px; }2.4 padding与图形绘制padding属性与background-clip属性配合，可以在有限的标签下实现一些CSS图形绘制效果。 案例：三道杠和双层圆点图形生成 三、致谢本文内容我对张鑫旭老师《CSS世界》第四章1、2小节的的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Vis-Class1_可视化释义","slug":"Vis-Class—-one","date":"2019-08-07T09:42:59.000Z","updated":"2019-08-16T10:15:32.470Z","comments":true,"path":"2019/08/07/Vis-Class—-one/","link":"","permalink":"http://yoursite.com/2019/08/07/Vis-Class—-one/","excerpt":"浙江大学2019年可视化与可视分析暑期学校第一课：陈为老师《可视化释义》笔记。","text":"浙江大学2019年可视化与可视分析暑期学校第一课：陈为老师《可视化释义》笔记。 SummerCourse2019ZJU Class 1 Introduction release Wei Chen chenwei@cad.zju.edu.cn OUTLINE 1.1 What is data visualization 1.2 Visualization is hot &amp; cool &amp; young 1.3 How to create visualization? 1、What is data visualization --- 1.1 “Data visualization is the creation and study of the visual representation of data” - wiki Input: data Output: visual form Goal: insight vi·su·al·i·za·tion: Formation of mental visual images The act or process of interpreting in visual terms or of putting into visible form eg:Aaron Koblin, TED 2006 1.2 Why is a Diagram (Sometimes)Worth 10,000 Words Larkin and Simon, Cognitive Science, 1987 图表表达与句型表达具有信息和计算上的等价性 [Simon 1978] 图表具有拓扑和几何的关联，将信息基于位置进行索引，所见处即所得 句型表达具有时间或逻辑方面的序列，显式地表达了单个元素。 句型表达假设每句话是串行阵列；而图表表达有一个简洁的语义网络，认知时只需要在不同的节点间定位。 在求解问题时，图表表达可以提供搜索与认知的便利；句型表达在搜索时需要记住更多的信息。eg:Visu Algo通过动画可视化数据结构和算法 1.3 How to do Helps us think Uses perception to offload cognition Serves as an external aid to augment working memory Boosts our cognitive abilities 2、Visualization is hot & cool & young --- **2.1 Top VIS Conferences** VAST (Visual Analytics Science and Technology) InfoVis (Information Visualization) SciVis (Scientific Visualization) 2.2 What is VIS Research? Visualization Pipeline Technique Papers Application/Design Study Papers System Papers Evaluation Papers Theory/Model papers 2.3 Some of Web Milestones Project 时间线 蚂蚁金服DT时代新布局：可视化神器G2 Baidu EChart 3、How to create visualization? --- 3.1 Act I: Foundations Design Principles Process &amp; Data Tasks &amp; Interaction Perception Visual Encodings Color 3.2 Act II:Methods SingleViews MultipleViews Filtering &amp;Aggregation Dimensionality Reduction Evaluation 3.3 Act III:Techniques Statistical Graphs Trees &amp; Networks Maps Text &amp; Images 3.4How to create a visualization yourself 数据清洗工具OpenRefine（以前称为Google Refine）; 中文教程 数据可视化工具Tableau; 中文教程 统计计算和统计制图的优秀工具:R 在视觉艺术环境中编码的语言:Processing 最流行的可视化库之一:D3 (JS);中文教程 配色方案:ColorBrewer","categories":[],"tags":[{"name":"Vis","slug":"Vis","permalink":"http://yoursite.com/tags/Vis/"}]},{"title":"Git常用操作总结","slug":"Git常用操作总结","date":"2019-08-05T10:07:56.000Z","updated":"2019-08-16T10:15:34.031Z","comments":true,"path":"2019/08/05/Git常用操作总结/","link":"","permalink":"http://yoursite.com/2019/08/05/Git常用操作总结/","excerpt":"Git常用操作总结 - 参考自廖雪峰老师的git教程","text":"Git常用操作总结 - 参考自廖雪峰老师的git教程 一.创建版本库 $ mkdir learngit// 创建文件夹learngit $ cd learngit $ pwd//显示当前路径 ①初始化一个Git仓库： git init//将当前目录变成一个Git可以管理的仓库②添加文件到Git仓库： 1.git add&lt;file&gt; ; 2.git commit $ git add readme.txt // 将文件添加到Git仓库（把文件修改添加到暂存区） $ git add file1.txt // 添加file1.txt文件 $ git add file2.txt file3.txt // 同时添加file2.txt和file3.txt两个文件 $ git commit -m “wrote a readme.txt.” // 将文件提交到仓库（把暂存区的所有内容提交到当前分支） 二.时光机穿梭①查看工作区状态，文件是否被修改过： git status②查看修改的内容： git diff eg:$ git diff readme.txt // 查看工作区的readme.txt与缓存区的readme.txt的区别 1.版本回退①HEAD:当前版本 ②HEAD^:上个版本 ③定位版本：git reset --hard commit_id ④git log：穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本 ⑤git reflog：要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 $ git log // 查看最近到最远的提交记录（详情: commit id + Author + Date + comment） $ git log –pretty=oneline // 查看最近到最远的提交记录（简写：commit id + comment） $ git reset –hard HEAD^ // 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本） $ git reset –hard 1234567 // 回到指定版本号commit id（此处：commit id 假设为1234567**，Git会根据commit id的前几位自动寻找对应的版本） $ cat readme.txt // 查看readme.txt的内容 $ git reflog // 查看每一次命令记录历史，确保能回到任意版本 2.工作区和暂存区①工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 ②版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 ③暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区。 $ git diff readme.txt // 比较工作区（working directory）和暂存区（stage/index）的区别 $ git diff --cached // 比较暂存区（stage/index）和分支（master）的区别第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 3.管理修改①每次修改，如果不add到暂存区，就不会加入到commit中 4.撤销修改①git checkout -- file：丢弃工作区的修改 ②git reset HEAD file：把暂存区的修改撤销掉，重新放回工作区5.删除文件①git rm：从版本库中删除文件 $ rm test.txt // 删除工作区文件（类似于手动删除） $ git status // 查看当前工作区与缓存区状态 $ git rm test.txt // 情况1：确认删除 $ git commit -m “remove test.txt” // 情况1：确认删除后，提交到版本库 $ git checkout – readme.txt // 情况2：误删，需要回退（即：用版本库里的版本替换工作区的版本） 三.远程仓库1.添加远程库①关联一个远程库： git remote add origin git@server-name:path/repo-name.git// 关联一个远程仓库 eg:git remote add origin git@github.com:yangfff/learngit.git ②关联后第一次推送master分支的所有内容： git push -u origin master③此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 git push -u origin master // 第一次推送master分支的所有内容ps:由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 注：在GitHub上创建新仓库时，如果勾选了README.md选项时，可能会出现下面错误，提示：远程仓库有readme.txt,而本地仓库没有README.txt,此时应该先进行合并文件，再进行推送。 git pull --rebase origin master // 推送之前，进行合并合并文件之后，发现本地仓库中多了README.md文件，此时再进行推送修改到远程仓库就可以了。 再次执行：git push -u origin master, 即可推送本地仓库到远程仓库了查看GitHub上的文件，已经更新！ 2.从远程库克隆①要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆 ②Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 $ git clone git@github.com:yangfff/learngit.git // 以SSH方式克隆 $ git clone https://github.com/yangfff/learngit.git // 以Https协议方式克隆四.分支管理1.创建与合并分支查看分支： git branch 创建分支： git branch&lt;name&gt; 切换分支： git cheakout&lt;name&gt; 创建+切换分支： git cheakout -b &lt;name&gt; 合并某分支到当前分支：git merge&lt;name&gt; 删除分支：git branch - d &lt;name&gt;2.解决冲突①查看分支合并图： git log --graph // 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit // 查看分支合并缩略图3.分支管理策略①合并分支时加–no-ff参数：普通模式合并，合并后的历史有分支，禁用fast forward eg:git log –no-ff-m”merge with no–ff”dev 4.Bug分支git stash // 隐藏分支工作现场，为修复bug准备 git stash list // 查看有哪些分支隐藏的工作现场，为恢复工作现场做准备 git stash apply // 恢复工作现场，但不删除存储的stash内容，结合git stash drop进行删除 git stash drop // 删除存储的stash内容，恢复到隐藏前的工作现场 git stash pop // 恢复到隐藏前的工作现场，相当于git stash apply和git stash drop git stash apply stash@{0} // 可以多次stash，通过git stash list查看所有的stash，然后可以恢复到指定的隐藏的工作现场5.Feature分支①开发一个新feature，最好新建一个分支； ②如果要丢弃一个没有被合并过的分支，可以通过 git branch -D &lt;name&gt;//强行删除6.多人协作①git remote -v：查看远程库信息 ②git push origin branch-name：从本地推送分支 ③git pull：推送失败时，抓取远程的新提交 ④git checkout -b branch-name origin/branch-name：在本地创建和远程分支对应的分支（本地和远程分支的名称最好一致） ⑤git branch –set-upstream branch-name origin/branch-name：建立本地分支和远程分支的关联 五.标签管理1.创建标签①git tag ：新建一个标签（默认为HEAD，也可以指定commit id） ②git tag -a -m “blablabla…”：可以指定标签信息 ③git tag -s -m “blablabla…”：可以用PGP签名信息 ④git tag：查看所有标签 2.操作标签①git push origin ：推送一个本地标签 ②git push origin –tags：推送全部未推送过的本地标签 ③git tag -d ：删除一个本地标签 ④git push origin :refs/tags/：删除一个远程标签 六.使用GitHub①在GitHub上，可以任意Fork开源仓库； ②自己拥有Fork后的仓库的读写权限； ③可以推送pull request给官方仓库来贡献代码。 七.自定义Git1.忽略特殊文件①忽略某些文件时，需要编写.gitignore； 2.配置别名①我们只需要敲一行命令，告诉Git，以后st就表示status： git config --global alias.st status eg: $ git config –global alias.co checkout $ git config –global alias.ci commit $ git config –global alias.br branch $ git config –global alias.unstage ‘reset HEAD’ $ git config –global alias.last ‘log -1’ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 3.搭建Git服务器GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 例如大众点评code.dianpingoa.com","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"流、元素与基本尺寸","slug":"流、元素与基本尺寸","date":"2019-08-01T04:15:46.000Z","updated":"2019-08-13T08:13:34.424Z","comments":true,"path":"2019/08/01/流、元素与基本尺寸/","link":"","permalink":"http://yoursite.com/2019/08/01/流、元素与基本尺寸/","excerpt":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。","text":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。 “流”之所以影响了整个CSS世界，就是因为影响了CSS世界的基石HTML。HTNML标签通常分为两类：块级元素和内联元素。 注意： 按照W3C的CSS规范，这里应该是“块级元素”和“内联级元素”。但是在W3C的HTML规范里，已经明确把HTML元素分为了“块级元素”和“内联元素”。我们这里采用现实中常用的HTML的内联元素这一说法。 一、块级元素（block-level element）1.1 基本特性： 基本特性：换行特性（一个水平流上只能单独显示一个元素，多个块级元素则换行显示。） 注意：块级元素的流体特性主要表现在水平方向上。 1.2 块级元素和“display 为block 的元素”不是一个概念display:list-item、display:table均块级元素，因为他们符合块级元素的基本特征，即换行特征。 1.3 用display值为block和list-item来配合clear属性来清除浮动带来的影响不使用list-item的原因：字母比较多、会出现项目符号、ie浏览器不支持伪元素的display值为listitem。 如案例： .clear: after { content: &apos;&apos;; display: table; // 也可以是block，或者是list-item clear: both; }二、list-item 元素会出现项目符号的原因2.1 标记盒子：注意:标记盒子可以理解为主块级之外的附加盒子。 list-item 元素会出现项目符号是因为生成了一个附加的盒子，学名“标记盒子”（marker box），专门用来放圆点、数字这些项目号。 IE浏览器下伪元素不支持list-item 或许就是无法创建这个“标记盒子”导致的。 2.2 外在盒子和容器盒子注意:容器盒子可以理解为内在盒子。 内在盒子：负责元素是一行显示还是只能换行显示。 容器盒子：负责宽高、内容呈现等。 [按照display的属性值我们可以知道： display值为block的元素由外在的“块级盒子”和内在的“块级容器盒子”组成。 display值为inline-block的元素由外在的“内联盒子”和内在的“块级容器盒子”组成。 display值为inline的元素内外均是“内联盒子”。 display值为inline-table的元素外面是“内联盒子”，里面是“table 盒子”。 2.3 width/height 作用在“容器盒子”点此查看案例演示：和文字平起平坐的表格 案例结果：该元素和文字一行显示，且表现如同真正的表格元素（子元素宽度等分） 三、width/height作用的细节3.1 width默认值auto的4种表现：1、充分利用可用空间，宽度默认100%于父级容器的。 比如：&lt;div&gt;、&lt;p&gt;这些元素的宽度默认是100%于父级容器的。 这种充分利用可用空间的行为还有个专有名字，叫作fill-available。 2、自适应大小，具有包裹性。 典型代表：浮动、绝对定位、inline-block 元素或table 元素。 3、收缩到最小 这个最容易出现在table-l表格ayout 为auto 的中： 当一列空间都不够时，文字能断就断，但中文随便断的，英文单词不能断。 4、超出容器限制除非明确width的相关设置，否则上面3种都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如：内容很长的连续的英文和数字，或者内联元素被设置了white-space：nowrap,则表现为如下： 像这一种子元素既保持了inline-block元素的收缩性，又同时让内容宽度最大，直接无视父级容器的宽度限制，后来在CSS3中有了专门的属性值描述，教室max-cintent. 上面的几个只有第一个是“外部尺寸”，其余全部是“内部尺寸”。而这唯一的“外部尺寸”，是“流”的精髓所在。 四、外部尺寸与流体特性元素尺寸由外部的容器决定 正常流宽度是一种margin/border/padding和content 内容区域自动分配水平空间的机制，尽量用无宽带的流来布局。 格式化宽度：在position属性值为absolute 或fixed 的元素中。在默认情况下，宽度由内部尺寸决定。当left/top 或top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position 属性值不是static）的祖先元素计算。margin、border、padding 和content 内容区域同样会自动分配水平（和垂直）空间 五、内部尺寸与流体特性元素尺寸由内部元素决定，“内部尺寸”有下面3 种表现形式： 包裹性:元素尺寸由内部元素决定，但永远小于“包含块”容器的尺寸（除非容器尺寸小于元素的“首选最小宽度”）按钮: 按钮就是inline-block 元素。 按钮文字越多宽度越宽（内部尺寸特性），但如果文字足够多，则会在容器的宽度处自动换行（自适应特性）。 标签按钮才会自动换行，标签按钮，默white-space:pre，是不会换行的，需要将pre 值重置为默认的normal。 按钮最大宽度就是容器的240 像素 首选最小宽度:元素最适合的最小宽度.外部容器的宽度是240 像素，假设宽度是0，里面的inline-block 元素的宽度是首选最小宽度。具体表现规则： 东亚文字（如中文）最小宽度为每个汉字的宽度。 西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。 如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS 中的word-break:break-all。 类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度。 最大宽度:是元素可以有的最大宽度。“最大宽度”实际等同于“包裹性”元素设置white-space:nowrap 声明后的宽度。如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度。 六、width 值作用的细节width 是作用在“内在盒子”上的，“内在盒子”又被分成了4 个盒子，分别是content box、padding box、border box和margin box。 content box ： content-box，padding box ：padding-box，border box ：border-box。margin box没有名字。 margin 的背景永远是透明的。 在CSS2.1 的规范中，有一段非常露骨的描述：content box 环绕着width 和height 给定的矩形。这种宽度设定和表现并不合理： 流动性丢失：对于块状元素，如果width:auto，则元素会如水流般充满整个容器，而一旦设定了width具体数值，则元素的流动性就会被阻断。 与现实世界表现不一致的困扰。 七、CSS 流体布局下的宽度分离原则所谓“宽度分离原则”，就是CSS 中的width 属性不与影响宽度的padding/border（有时候包括margin）属性共存。写法： .father { width: 180px; } .son { margin: 0 20px; padding: 20px; border: 1px solid; }为何要宽度分离:当一件事情的发展可以被多个因素所左右的时候，这个事情最终的结果就会变数很大而不可预期。宽度在这里也是类似，由于盒尺寸中的4 个盒子都能影响宽度，自然页面元素的最终宽度就很容易发生变化而导致意想不到的布局发生。使用“宽度分离”后，咱们不需要烧脑子去计算了，而且页面结构反而更稳固。 八、改变width/height 作用细节的box-sizingbox-sizing 的作用：改变了width 作用的盒子。box-sizing:border-box 就是让100 像素的宽度直接作用在border box上，从默认的content box 变成border box。此时，content box 从宽度值中释放，形成了局部的流动性，和padding 一起自动分配width 值。 box-sizing 并不支持margin-box。 如何评价*{box-sizing:border-box}。从纯个人角度讲，不喜欢这种做法的。 这种做法易产生没必要的消耗，通配符*应该是一个慎用的选择器，因为它会选择所有的标签元素。 这种做法并不能解决所有问题。box-sizing 不支持margin-box，只有当元素没有水平margin 时候，box-sizing 才能真正无计算，而“宽度分离”等策略则可以彻底解决所有的宽度计算的问题。 替换元素css重置更合适： input, textarea, img, video, object { box-sizing: border-box; } 九、关于height对于width 属性，就算父元素width 为auto，其百分比值也是支持的。 对于height 属性，如果父元素height 为auto，只要子元素在文档流中，其百分比值完全就被忽略了。百分比高度值要想起作用，其父级必须有一个可以生效的高度值。 如何让元素支持height:100%效果： 设定显式的高度值。 使用绝对定位。绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于padding box 的，也就是说会把padding 大小值计算在内，但是，非绝对定位元素则是相对于content box 计算的。 十、min-width/max-width和min-height/max-heightmax-width 和max-height 的初始值是none,min-width/min-height 的初始值都是auto。 超越!important 指的是max-width 会覆盖width，而且这种覆盖不是普通的覆盖，是超级覆盖。 &lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important;&quot;&gt; img { max-width: 256px; }答案是256px。 min-width覆盖max-width，此规则发生在min-width和max-width冲突的时候。 任意高度元素的展开收起动画技术：.element { height: 0; overflow: hidden; transition: height .25s;}.element.active { height: auto; /* 没有transition 效果，只是生硬地展开 */}可以试试下面方法 .element { max - height: 0; overflow: hidden; transition: max - height .25s;}.element.active { max - height: 666px; /* 一个足够大的最大高度值 */}注意：即虽然说从适用范围讲，max- height 值越大使用场景越多，但是，如果max-height 值太大，在收起的时候可能会有“效果延迟”的问题。因此，我个人建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也会因为时间很短，很难被用户察觉，并不会影响体验。 十一、内联元素块级负责结构，内联负责内容。 “内联元素”的“内联”特指“外在盒子”，和“display 为inline的元素”不是一个概念。 “内联元素”的典型特征就是可以和文字在一行显示。 内容区域（content area）：域指一种围绕文字看不见的盒子可以理解为把文本选中的背景色区域作为内容区域。 注意：在IE 和Firefox 浏览器下，文字的选中背景总能准确反映内容区域范围，但是Chrome 浏览器下，::selection 范围并不总是准确的，例如，和图片混排或者有垂直padding 的时候，范围会明显过大，这一点需要注意。 内联盒子（inline box）：“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类： 内联盒子:外部含内联标签&lt;span&gt;、&lt;a&gt;和&lt;em&gt;等。匿名内联盒子:光秃秃的文字。 行框盒子（line box）:每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。 包含盒子（containing box）:标签就是一个“包含盒子”（实线框标注），此盒子由一行一行的“行框盒子”组成。 十二、幽灵空白节点在HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 注意:这里有一个前提，文档声明必须是HTML5 文档声明，如果还是很多年前的老声明，则不存在“幽灵空白节点”。 十三、致谢本文内容是我对张鑫旭老师《CSS世界》一书第三章的学习笔记，由衷的钦佩张鑫旭老师，向张鑫旭老师学习！也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS世界的专业术语","slug":"CSS世界的专业术语","date":"2019-07-31T08:21:13.000Z","updated":"2019-08-02T04:12:48.604Z","comments":true,"path":"2019/07/31/CSS世界的专业术语/","link":"","permalink":"http://yoursite.com/2019/07/31/CSS世界的专业术语/","excerpt":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。","text":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。 一、CSS世界的专业术语案例： .vacabulary{ height: 99px; color: transparent; }1. 属性例如上面案例中的高度和颜色就是CSS世界的属性，CSS属性就是魔法师。 2. 值CSS的各种属性值就是魔法师的魔法技能。在CSS世界中，值得分类十分广泛，比较常用的有： 整数值，如z-index:1中，1属于,同时也属于 数值，如line-height：1.5中的1.5 百分比值，如padding：50%中的50% 长度值，如99px 颜色值，如#999 此外，还有字符串值、位置值等类型。在CSS3新世界中，还有角度值、频率值、时间值等类型。 3. 关键词 关键字：CSS中很关键的英文单词。例如上面案例中的transparent（全透明黑色）就是典型的关键词，还有常见的solid（实线的）、inherit(继承)。 泛关键字：所有CSS属性都可以使用的关键字，例如initial（默认）、inherit（继承）和unset（不设置） 4. 变量CSS中目前可以称为变量的比较有效，CSS3中的currentColor就是变量，非常有用：currentColor-CSS3超高校级好用CSS变量; 以及阮一峰老师的自定义CSS变量教程：CSS 变量教程 5. 长度单位CSS中的单位有时间单位（如s、ms）,还有角度单位（如deg、rad等），但最常见的还是长度单位。长度单位分为： 绝对长度单位：彼此固定，不会因为其他元素的尺寸变化而变化。主要有px、cm、mm、Q、in、pc、pt(eg:除px外，其他基本不用) 相对长度单位：指定相对于另一长度的长度。主要有em、ex、ch、rem、%和可视区百分比长度单位 vm、vh、vmin、vmax 注意： 2%属于数值，这里的%不是长度单位 “值”里面的&lt;length和长度单位的关系：&lt;numberre&gt;+长度单位=&lt;length&gt;; 6. 功能符值以函数的形式指定（就是被括号括起来的那种），主要用来表示颜色（rgba和hsla）、背景图片地址（url)、元素属性值、计算（calc）和过渡效果等，如rgba (0,0,0,0)、url(“css-world.png”)、attr(“herf”)、scale(-1) 7. 属性值属性冒号后面的内容统一称为属性值 8. 声明属性名+属性值 9. 声明块声明块就是花括号{}包裹的一系列声明 10. 规则或规则集出现了选择器，而且后面跟着声明块，如本文最上面的案例。 11. 选择器用来瞄准目标元素的东西。 类选择器：如.umbrella ID选择器：如#id 属性 选择器：如[attribute] [target] 选择带有 target 属性所有元素 伪类选择器：一般前面有一个： 伪元素选择器：有两个冒号的原则，::selection ::selection 选择被用户选取的元素部分。 这里放上更详细的介绍：CSS 选择器参考手册 12. 关系选择器根据与其他元素的关系选择元素的选择器，常见的有： 后代选择器 空格连接 相邻后代选择器 &gt;连接 兄弟选择器 ~连接 （注意：是当前元素后面所有的的合规则的那个同父的兄弟元素） 相邻兄弟选择器： +连接 （注意：仅仅选择当前元素相邻的那一个同父元素的合规则的兄弟元素。且适用于IE7以上版本） 13. @规则指的是以@字符开头的一些规则，例如@media、@font-face、@page或@support 二、CSS世界中的“未定义行为”现实世界中，法律约束我们的行为，如果越界，就叫违法；在CSS世界中，有Web标准约束元素的行为，如果越界就称为bug。不过不可能面面俱到，法律会有法律空白，在CSS世界也会有”未定义行为”。例如以下这个案例：FireFox mousedown干掉:active实例页面 HTML： 正常情况： &lt;a href=&quot;javascript:&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt; 包含JS： &lt;a href=&quot;javascript:&quot; id=&quot;button&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt;CSS： .active-btn { display: inline-block; background-color: #cd0000; } .active-btn:active { background-color: #ae0000; }JavaScript： var button = document.getElementById(&quot;button&quot;); if (button.addEventListener) { button.addEventListener(&quot;mousedown&quot;, function(event) { // 此处省略N行 event.preventDefault(); }); }现象描述：在FireFox浏览器中，点击“正常情况按钮”会出现按钮点击样式，但点击“包含js的按钮”，则不会有按钮点击样式 原因分析：因为规范上并没有对这种场景的具体描述，所以FireFox认为：active发生在mousedown事件之后。（IE/Chrome反之认为） 像这种规范估计不到的细枝末节的实现，就称之“未定义行为” 三、致谢本文内容我对张鑫旭老师《CSS世界》一书第二章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS世界概述","slug":"CSS世界概述","date":"2019-07-31T02:28:28.000Z","updated":"2019-08-01T02:48:18.136Z","comments":true,"path":"2019/07/31/CSS世界概述/","link":"","permalink":"http://yoursite.com/2019/07/31/CSS世界概述/","excerpt":"欢迎来到CSS世界，这里有几个比较大的平行世界，不同世界有浏览器王国的命运也不一样，这里还有许多厉害的魔法师哦！","text":"欢迎来到CSS世界，这里有几个比较大的平行世界，不同世界有浏览器王国的命运也不一样，这里还有许多厉害的魔法师哦！ 一、CSS世界的世界观在CSS世界中： 世界：操作系统不同的操作系统代表了不同的评选世界，CSS世界有几个比较大的平行世界，即： Window世界 OS X世界 移动端iOS世界 Android世界 王国：浏览器不同世界的浏览器王国的命运不一样，例如： 在OS X世界中，IE王国是不存在的，而Safari王国异常强大 而在Window世界中，Safari王国异常落寞 魔法师：CSS属性CSS的各种属性值就是魔法师的魔法技能 魔法石：HTML选择法器：选择器例如，使用.umbrella法器，即可对所有class=”umbrella”的元素进行改变 二、CSS世界为什么被创造出来2.1 CSS的诞生在最开始的时候，互联网领域的信息就是图片和文字，网站的功能就是信息展示。那时候的网站前端技术关心的是图片和文字的呈现，而 CSS世界的诞生就是为图文信息展示服务 2.2 CSS完胜SVG的武器——流在很长一段时间里，网站的主要功能都是图片和文字信息的展示，而SVG的强项是图片，但是文字内容的呈现不敢恭维，所以SVG被打入冷宫，CSS一如既往被重用。 CSS为什么有强大的图文显示能力？ 流！ 2.3 什么是流？流，即是“文档流”的简称，“流”实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的“水流”。 “流”就是CSS世界中引导元素排列和定位的一条看不见的“水流” CSS世界构建的基石是HTML,而HTML最具代表的两个基石正好是CSS世界中的块级元素和内联元素的代表，对应着盛水容器的水和木头 现实中的水流：水流自动铺满容器，放入木头，水位升高，木头依次排序。CSS世界中的流：div自动铺满容器，图片文字依次排列，不足则换行。 流是如何影响整个CSS世界的 通过控制HTML默认的表现符合流，来使流”统治CSS世界 通过破坏“流”来实现特殊布局 通过改变流的流向来改变表现形式 流体布局利用元素“流”的特性实现的各类布局效果。例如“div+CSS布局” 注意：“自适应布局”是凡具有自适应特性的一类布局的统称，“流体布局要小寨的多。例如表格布局是自适应布局，但不是流体布局” 2.4 CSS的世界的一些备注 对CSS2.1的全面支持是从微软公司的IE8开始的。 比CSS还要老,他有自己的世界。“流”的特性对并不适用，一些CSS属性的表现，如单元格的vertical-align，也和普通元素不一样。 CSS新世界——CSS3:布局更为丰富，视觉表现长足进步。 三、致谢本文内容我对张鑫旭老师《CSS世界》一书第一章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程","slug":"建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程","date":"2019-07-29T13:21:14.000Z","updated":"2019-07-31T05:43:00.098Z","comments":true,"path":"2019/07/29/建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程/","link":"","permalink":"http://yoursite.com/2019/07/29/建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程/","excerpt":"感谢TRHX的建站博客,真的非常详细，给予我莫大的帮助！另外在建站过程中，发现了一个需要注意的问题。","text":"感谢TRHX的建站博客,真的非常详细，给予我莫大的帮助！另外在建站过程中，发现了一个需要注意的问题。 致谢感谢TRHX的“使用Github Pages和Hexo搭建自己的独立博客【超级详细的小白教程】”,真的非常详细，给予我的网站莫大的帮助！感谢作者！ 建站过程中需要注意的问题1、无法用“https:/yangfff.github.io”打开网页的问题以及解决问题描述：无法用“https:/yangfff.github.io”打开网页 原因分析：没有配置号 Git 个人信息 直接原因：在“ _config.yml 文件”中repository是SSH格式的，但是却没有将Github项目的 Clone or download 按钮，选择为 Use SSH _config.yml 文件： deploy: type: git repository: git@github.com:yangfff/yangfff.github.io.git branch: master解决方法：将Github项目的 Clone or download 按钮，选择为 Use SSH","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-29T12:04:03.048Z","updated":"2019-07-31T05:34:39.127Z","comments":true,"path":"2019/07/29/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/29/hello-world/","excerpt":"Welcom!Let’s Go! Create a new post1$ hexo new \"My New Post\" Run server1$ hexo s Deploy to remote sites1$ hexo d -g","text":"Welcom!Let’s Go! Create a new post1$ hexo new \"My New Post\" Run server1$ hexo s Deploy to remote sites1$ hexo d -g Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}