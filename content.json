{"meta":{"title":"小萝莉的游乐园","subtitle":null,"description":"一jio一个坑,向着敌人的炮火前进!","author":"yangfff","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-31T06:27:04.534Z","updated":"2019-07-31T06:27:04.534Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-07-29T16:40:10.568Z","updated":"2019-07-29T16:40:10.568Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-29T16:40:48.442Z","updated":"2019-07-29T16:40:48.442Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-07-31T02:22:19.081Z","updated":"2019-07-31T02:22:19.081Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2019-07-29T16:41:54.693Z","updated":"2019-07-29T16:41:54.693Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-29T16:41:16.020Z","updated":"2019-07-29T16:41:16.020Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用lufylegend库件进行HTML5猜拳游戏猜拳游戏开发","slug":"使用lufylegend库件进行HTML5猜拳游戏猜拳游戏开发","date":"2019-08-17T13:07:06.000Z","updated":"2019-08-18T06:44:14.984Z","comments":true,"path":"2019/08/17/使用lufylegend库件进行HTML5猜拳游戏猜拳游戏开发/","link":"","permalink":"http://yoursite.com/2019/08/17/使用lufylegend库件进行HTML5猜拳游戏猜拳游戏开发/","excerpt":"猜拳游戏——石头剪刀布。里面使用了LBitmapData、LBitmap、LSprite、LTextField等几个类和lufylegend库件里的鼠标事件。","text":"猜拳游戏——石头剪刀布。里面使用了LBitmapData、LBitmap、LSprite、LTextField等几个类和lufylegend库件里的鼠标事件。 一、游戏分析游戏需要的要素： 图片描画：将石头剪刀布三张图片会知道画面上 图形绘制：背景、边框 文字绘制：统计次数的文字 鼠标点击：通过点击三个不同按钮选择出拳 电脑AI:电脑随机出拳 条件分支与判断：胜负判定结果 二、必要的Javascript知识2.1 随机数Math.random()函数，可以随机生成0到1之间的一个小数。如果需要随机生成5-10之间的整数，则用： Math.floor(5 + 5*Math.random()); 2.2 条件分支if..else if..else: if(条件1){ 条件1成立执行代码； }else if(条件2){ 条件2成立执行代码； }else{ 条件1、2都不成立时执行代码； }switch: switch(变量){ case 值1： 执行代码块1 break; case 值2： 执行代码块2 break; default; 当变量既不是值1也不是值2时执行的代码块 }三、分层实现层次划分： 整个游戏界面一层 选择出拳部分一层 结果显示部分一层 3层分别显示到画面上： init(50,&quot;mylegend&quot;,800,400,main); /*新建3个变量层，分别代表3个显示层*/ var backLayer, resultLayer, clickLayer; function main(){ gameInit(); } function gameInit(){ /*初始化层backLayer，将其作为背景层显示出来*/ backLayer = new LSprite(); addChild(backLayer); //添加游戏界面背景 backLayer.graphics.drawRect(10,&apos;#008800&apos;,[0,0,LGlobal.width,LGlobal.height],true,&apos;#000000&apos;); //结果显示层初始化 initResultLayer(); //操作层初始化 initClickLayer(); } /*初始化resultLayer层，将其作为结果表示层，并在层上绘制一个白色矩形，当作结果表示层的背景色*/ function initResultLayer(){ resultLayer = new LSprite(); resultLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,150,110],true,&apos;#ffffff&apos;); resultLayer.x = 10; resultLayer.y = 100; backLayer.addChild(resultLayer); } /*初始化clickLayer层，并将其作为控制点击层，同时再层上绘制一个白色矩形，当作控制点击层的背景色*/ function initClickLayer(){ clickLayer = new LSprite(); clickLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,300,110],true,&apos;#ffffff&apos;); clickLayer.x = 250; clickLayer.y = 275; backLayer.addChild(clickLayer); }四、各个层的基本功能4.1 基本画面显示将图片读取到电脑，然后按照需求显示到画面。 图片的读取，再这篇博客已经介绍过，我们这次使用lufylegend库件中另一种比较方便的图片读取方式，即静态类LLoadManage中的load函数来一次性读取多张图片： LLoadManage.load ($list,$onupdata,$oncomplete); $list:尧都区的图片数组$onupdata：没读取数组中一张图片后调用的函数，可以为空$oncomplet：读取玩数组中所有图片后调用的函数 init(50,&quot;mylegend&quot;,800,400,main); var loadingLayer, backLayer, resultLayer, clickLayer, /*变量imglist用来保存读取后的图片数据的数组，保存方式以key=&gt;value的形式，key就是imgData对于的name值*/ var imglist = {}; var imgData = new Array( {name:&quot;title&quot;,path:&quot;../images/title.png&quot;}, {name:&quot;shitou&quot;,path:&quot;../images/shitou.png&quot;}, {name:&quot;jiandao&quot;,path:&quot;../images/jiandao.png&quot;}, {name:&quot;bu&quot;,path:&quot;../images/bu.png&quot;} ); function main(){ backLayer = new LSprite(); addChild(backLayer); /*加载进度条，有三种样式，这里使用样式3*/ loadingLayer = new LoadingSample3(); backLayer.addChild(loadingLayer); /*利用静态类LLoadManage的load函数来读取数组中的图片*/ LLoadManage.load( imgData, function(progress){ loadingLayer.setProgress(progress); }, function(result){ imglist = result; backLayer.removeChild(loadingLayer); loadingLayer = null; gameInit(); } ); }LLoadManage的load函数： 第一个参数imgData：要读取的图片数组 第二个参数function：function类型，每读取一张图片后调用的函数，其中progress指的是读完的图片数占总图片数的比例，将这个比例值通过setProgress传给LoadingSample3对象，就实现了同台的进度条 第三个参数：function类型，是将读取完图片后的结果赋值给变量imglist，然后移除画面上的进度条对象，最后调用gameInit,进行游戏下一步的操作。 修改gameInit函数，添加相应变量： init(50,&quot;mylegend&quot;,800,400,main); /*添加selfBitmap、enemyBitmap变量，用于显示己方的电脑的出拳结果*/ var loadingLayer, backLayer, resultLayer, clickLayer, selfBitmap, enemyBitmap; var imglist = {}; var imgData = new Array( {name:&quot;title&quot;,path:&quot;../images/title.png&quot;}, {name:&quot;shitou&quot;,path:&quot;../images/shitou.png&quot;}, {name:&quot;jiandao&quot;,path:&quot;../images/jiandao.png&quot;}, {name:&quot;bu&quot;,path:&quot;../images/bu.png&quot;} ); var showList = new Array(); function main(){ backLayer = new LSprite(); addChild(backLayer); loadingLayer = new LoadingSample3(); backLayer.addChild(loadingLayer); LLoadManage.load( imgData, function(progress){ loadingLayer.setProgress(progress); }, function(result){ imglist = result; backLayer.removeChild(loadingLayer); loadingLayer = null; gameInit(); } ); } function gameInit(){ /*为了避免反复新建LBitmapData对象，所以将新建的LBitmapData对象添加到数组showList中。imglist是利用LLoadManage读取图片后返回的结果集。*/ showList.push(new LBitmapData(imglist[&quot;shitou&quot;])); showList.push(new LBitmapData(imglist[&quot;jiandao&quot;])); showList.push(new LBitmapData(imglist[&quot;bu&quot;])); //添加游戏界面背景 backLayer.graphics.drawRect(10,&apos;#008800&apos;,[0,0,LGlobal.width,LGlobal.height],true,&apos;#000000&apos;); //显示游戏标题 var titleBitmap = new LBitmap(new LBitmapData(imglist[&quot;title&quot;])); titleBitmap.x = (LGlobal.width - titleBitmap.width)/2; titleBitmap.y = 10; backLayer.addChild(titleBitmap); //玩家方出拳图片 selfBitmap = new LBitmap(showList[0]); selfBitmap.x = 400 - selfBitmap.width - 50; selfBitmap.y = 130; backLayer.addChild(selfBitmap); //电脑方出拳图片 enemyBitmap = new LBitmap(showList[0]); enemyBitmap.x = 400 + 50; enemyBitmap.y = 130; backLayer.addChild(enemyBitmap); //玩家电脑名称设定 var nameText; nameText = new LTextField(); nameText.text = &quot;玩家&quot;; nameText.weight = &quot;bolder&quot;; nameText.color = &quot;#ffffff&quot;; nameText.size = 24; nameText.x = selfBitmap.x + (selfBitmap.width - nameText.getWidth())/2; nameText.y = 95; backLayer.addChild(nameText); nameText = new LTextField(); nameText.text = &quot;电脑&quot;; nameText.weight = &quot;bolder&quot;; nameText.color = &quot;#ffffff&quot;; nameText.size = 24; nameText.x = enemyBitmap.x + (enemyBitmap.width - nameText.getWidth())/2; nameText.y = 95; backLayer.addChild(nameText); //结果显示层初始化 initResultLayer(); //操作层初始化 initClickLayer(); } function initResultLayer(){ resultLayer = new LSprite(); resultLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,150,110],true,&apos;#ffffff&apos;); resultLayer.x = 10; resultLayer.y = 100; backLayer.addChild(resultLayer); } function initClickLayer(){ clickLayer = new LSprite(); clickLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,300,110],true,&apos;#ffffff&apos;); clickLayer.x = 250; clickLayer.y = 275; backLayer.addChild(clickLayer); }4.2 结果层的显示在结果层中记录审理、失败和平局等各种结果的次数 定义相应变量： var loadingLayer, backLayer, resultLayer, clickLayer, selfBitmap, enemyBitmap, /*LTextField对象，用于显示各种结果值*/ selfTextAll, selfTextWin, selfTextLoss, selfTextDraw, /*次数*/ win = 0, loss = 0, draw = 0;初始化几个对象，并显示到结果层： function initResultLayer(){ resultLayer = new LSprite(); resultLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,150,110],true,&apos;#ffffff&apos;); resultLayer.x = 10; resultLayer.y = 100; backLayer.addChild(resultLayer); selfTextAll = new LTextField(); selfTextAll.text = &quot;猜拳次数 ： 0&quot;; selfTextAll.weight = &quot;bolder&quot;; selfTextAll.x = 10; selfTextAll.y = 20; resultLayer.addChild(selfTextAll); selfTextWin = new LTextField(); selfTextWin.text = &quot;胜利次数 ： 0&quot;; selfTextWin.weight = &quot;bolder&quot;; selfTextWin.x = 10; selfTextWin.y = 40; resultLayer.addChild(selfTextWin); selfTextLoss = new LTextField(); selfTextLoss.text = &quot;失败次数 ： 0&quot;; selfTextLoss.weight = &quot;bolder&quot;; selfTextLoss.x = 10; selfTextLoss.y = 60; resultLayer.addChild(selfTextLoss); selfTextDraw = new LTextField(); selfTextDraw.text = &quot;平局次数 ： 0&quot;; selfTextDraw.weight = &quot;bolder&quot;; selfTextDraw.x = 10; selfTextDraw.y = 80; resultLayer.addChild(selfTextDraw); }4.3 控制层的显示添加石头、剪刀、布三个按钮： function initClickLayer(){ clickLayer = new LSprite(); clickLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,300,110],true,&apos;#ffffff&apos;); var msgText = new LTextField(); msgText.text = &quot;请出拳：&quot;; msgText.weight = &quot;bolder&quot;; msgText.x = 10; msgText.y = 10; /*调用getButton函数，通过传入相应参数来建立按钮*/ clickLayer.addChild(msgText); var btnShitou = getButton(&quot;shitou&quot;); btnShitou.x = 30; btnShitou.y = 35; clickLayer.addChild(btnShitou); var btnJiandao = getButton(&quot;jiandao&quot;); btnJiandao.x = 115; btnJiandao.y = 35; clickLayer.addChild(btnJiandao); var btnBu = getButton(&quot;bu&quot;); btnBu.x = 200; btnBu.y = 35; clickLayer.addChild(btnBu); clickLayer.x = 250; clickLayer.y = 275; backLayer.addChild(clickLayer); }五、出拳给按钮添加鼠标点击事件： function initClickLayer(){ clickLayer = new LSprite(); clickLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,300,110],true,&apos;#ffffff&apos;); var msgText = new LTextField(); msgText.text = &quot;请出拳：&quot;; msgText.weight = &quot;bolder&quot;; msgText.x = 10; msgText.y = 10; clickLayer.addChild(msgText); /*建立3个按钮之后，分别给按钮加上MOUSE_UP事件，当鼠标单击按钮并弹起时候，调用onclick函数*/ var btnShitou = getButton(&quot;shitou&quot;); btnShitou.x = 30; btnShitou.y = 35; clickLayer.addChild(btnShitou); btnShitou.addEventListener(LMouseEvent.MOUSE_UP,onclick); var btnJiandao = getButton(&quot;jiandao&quot;); btnJiandao.x = 115; btnJiandao.y = 35; clickLayer.addChild(btnJiandao); btnJiandao.addEventListener(LMouseEvent.MOUSE_UP,onclick); var btnBu = getButton(&quot;bu&quot;); btnBu.x = 200; btnBu.y = 35; clickLayer.addChild(btnBu); btnBu.addEventListener(LMouseEvent.MOUSE_UP,onclick); clickLayer.x = 250; clickLayer.y = 275; backLayer.addChild(clickLayer); } function onclick(event,display){ var selfValue,enemyValue; if(display.name == &quot;shitou&quot;){ selfValue = 0; }else if(display.name == &quot;jiandao&quot;){ selfValue = 1; }else if(display.name == &quot;bu&quot;){ selfValue = 2; } enemyValue = Math.floor(Math.random()*3); selfBitmap.bitmapData = showList[selfValue]; enemyBitmap.bitmapData = showList[enemyValue]; }六、结果判定为方便判断结果，我们准备一个结果判定数组： function onclick(event,display){ var selfValue,enemyValue; if(display.name == &quot;shitou&quot;){ selfValue = 0; }else if(display.name == &quot;jiandao&quot;){ selfValue = 1; }else if(display.name == &quot;bu&quot;){ selfValue = 2; } enemyValue = Math.floor(Math.random()*3); selfBitmap.bitmapData = showList[selfValue]; enemyBitmap.bitmapData = showList[enemyValue]; var result = checkList[selfValue][enemyValue]; if(result == -1){ loss += 1; }else if(result == 1){ win += 1; }else{ draw += 1; } selfTextWin.text = &quot;胜利次数 ： &quot; + win; selfTextLoss.text = &quot;失败次数 ： &quot; + loss; selfTextDraw.text = &quot;平局次数 ： &quot; + draw; selfTextAll.text = &quot;猜拳次数 ： &quot; + (win + loss + draw); }运行效果： 七、完整代码init(50,&quot;mylegend&quot;,800,400,main); var loadingLayer, backLayer, resultLayer, clickLayer, selfBitmap, enemyBitmap, selfTextAll, selfTextWin, selfTextLoss, selfTextDraw, win = 0, loss = 0, draw = 0; var imglist = {}; var imgData = new Array( {name:&quot;title&quot;,path:&quot;../images/title.png&quot;}, {name:&quot;shitou&quot;,path:&quot;../images/shitou.png&quot;}, {name:&quot;jiandao&quot;,path:&quot;../images/jiandao.png&quot;}, {name:&quot;bu&quot;,path:&quot;../images/bu.png&quot;} ); var checkList = [ [0,1,-1], [-1,0,1], [1,-1,0] ]; var showList = new Array(); function main(){ LGlobal.setDebug(true); backLayer = new LSprite(); addChild(backLayer); loadingLayer = new LoadingSample3(); backLayer.addChild(loadingLayer); LLoadManage.load( imgData, function(progress){ loadingLayer.setProgress(progress); }, function(result){ imglist = result; backLayer.removeChild(loadingLayer); loadingLayer = null; gameInit(); } ); } function gameInit(){ showList.push(new LBitmapData(imglist[&quot;shitou&quot;])); showList.push(new LBitmapData(imglist[&quot;jiandao&quot;])); showList.push(new LBitmapData(imglist[&quot;bu&quot;])); //添加游戏界面背景 backLayer.graphics.drawRect(10,&apos;#008800&apos;,[0,0,LGlobal.width,LGlobal.height],true,&apos;#000000&apos;); //显示游戏标题 var titleBitmap = new LBitmap(new LBitmapData(imglist[&quot;title&quot;])); titleBitmap.x = (LGlobal.width - titleBitmap.width)/2; titleBitmap.y = 10; backLayer.addChild(titleBitmap); //玩家方出拳图片 selfBitmap = new LBitmap(showList[0]); selfBitmap.x = 400 - selfBitmap.width - 50; selfBitmap.y = 130; backLayer.addChild(selfBitmap); //电脑方出拳图片 enemyBitmap = new LBitmap(showList[0]); enemyBitmap.x = 400 + 50; enemyBitmap.y = 130; backLayer.addChild(enemyBitmap); //玩家电脑名称设定 var nameText; nameText = new LTextField(); nameText.text = &quot;玩家&quot;; nameText.weight = &quot;bolder&quot;; nameText.color = &quot;#ffffff&quot;; nameText.size = 24; nameText.x = selfBitmap.x + (selfBitmap.width - nameText.getWidth())/2; nameText.y = 95; backLayer.addChild(nameText); nameText = new LTextField(); nameText.text = &quot;电脑&quot;; nameText.weight = &quot;bolder&quot;; nameText.color = &quot;#ffffff&quot;; nameText.size = 24; nameText.x = enemyBitmap.x + (enemyBitmap.width - nameText.getWidth())/2; nameText.y = 95; backLayer.addChild(nameText); //结果显示层初始化 initResultLayer(); //操作层初始化 initClickLayer(); } function initResultLayer(){ resultLayer = new LSprite(); resultLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,150,110],true,&apos;#ffffff&apos;); resultLayer.x = 10; resultLayer.y = 100; backLayer.addChild(resultLayer); selfTextAll = new LTextField(); selfTextAll.text = &quot;猜拳次数 ： 0&quot;; selfTextAll.weight = &quot;bolder&quot;; selfTextAll.x = 10; selfTextAll.y = 20; resultLayer.addChild(selfTextAll); selfTextWin = new LTextField(); selfTextWin.text = &quot;胜利次数 ： 0&quot;; selfTextWin.weight = &quot;bolder&quot;; selfTextWin.x = 10; selfTextWin.y = 40; resultLayer.addChild(selfTextWin); selfTextLoss = new LTextField(); selfTextLoss.text = &quot;失败次数 ： 0&quot;; selfTextLoss.weight = &quot;bolder&quot;; selfTextLoss.x = 10; selfTextLoss.y = 60; resultLayer.addChild(selfTextLoss); selfTextDraw = new LTextField(); selfTextDraw.text = &quot;平局次数 ： 0&quot;; selfTextDraw.weight = &quot;bolder&quot;; selfTextDraw.x = 10; selfTextDraw.y = 80; resultLayer.addChild(selfTextDraw); } function initClickLayer(){ clickLayer = new LSprite(); clickLayer.graphics.drawRect(4,&apos;#ff8800&apos;,[0,0,300,110],true,&apos;#ffffff&apos;); var msgText = new LTextField(); msgText.text = &quot;请出拳：&quot;; msgText.weight = &quot;bolder&quot;; msgText.x = 10; msgText.y = 10; clickLayer.addChild(msgText); var btnShitou = getButton(&quot;shitou&quot;); btnShitou.x = 30; btnShitou.y = 35; clickLayer.addChild(btnShitou); btnShitou.addEventListener(LMouseEvent.MOUSE_UP,onclick); var btnJiandao = getButton(&quot;jiandao&quot;); btnJiandao.x = 115; btnJiandao.y = 35; clickLayer.addChild(btnJiandao); btnJiandao.addEventListener(LMouseEvent.MOUSE_UP,onclick); var btnBu = getButton(&quot;bu&quot;); btnBu.x = 200; btnBu.y = 35; clickLayer.addChild(btnBu); btnBu.addEventListener(LMouseEvent.MOUSE_UP,onclick); clickLayer.x = 250; clickLayer.y = 275; backLayer.addChild(clickLayer); } function onclick(event,display){ var selfValue,enemyValue; if(display.name == &quot;shitou&quot;){ selfValue = 0; }else if(display.name == &quot;jiandao&quot;){ selfValue = 1; }else if(display.name == &quot;bu&quot;){ selfValue = 2; } enemyValue = Math.floor(Math.random()*3); selfBitmap.bitmapData = showList[selfValue]; enemyBitmap.bitmapData = showList[enemyValue]; var result = checkList[selfValue][enemyValue]; if(result == -1){ loss += 1; }else if(result == 1){ win += 1; }else{ draw += 1; } selfTextWin.text = &quot;胜利次数 ： &quot; + win; selfTextLoss.text = &quot;失败次数 ： &quot; + loss; selfTextDraw.text = &quot;平局次数 ： &quot; + draw; selfTextAll.text = &quot;猜拳次数 ： &quot; + (win + loss + draw); } function getButton(value){ var btnUp = new LBitmap(new LBitmapData(imglist[value])); btnUp.scaleX = 0.5; btnUp.scaleY = 0.5; var btnOver = new LBitmap(new LBitmapData(imglist[value])); btnOver.scaleX = 0.5; btnOver.scaleY = 0.5; btnOver.x = 2; btnOver.y = 2; var btn = new LButton(btnUp,btnOver); btn.name = value; return btn; }","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"lufylegend开源库件","slug":"lufylegend开源库件","date":"2019-08-17T02:11:16.000Z","updated":"2019-08-17T08:55:09.001Z","comments":true,"path":"2019/08/17/lufylegend开源库件/","link":"","permalink":"http://yoursite.com/2019/08/17/lufylegend开源库件/","excerpt":"本文将详细介绍如何利用HTML5的开源框架lufylegend来进行游戏的开发。","text":"本文将详细介绍如何利用HTML5的开源框架lufylegend来进行游戏的开发。 一、lufylegend库件简介 一个HTML5开源框架 利用JavaScript和ActionScript相似性，用仿ActionScript3.0的语法对HTML5 Canvas的API进行了封装 支持多种常用环境，手机浏览器与PC浏览器自动切换事件 1.1 工作原理lufylegend库件封装了Canvas绘图的所有API，它利用JavaScript的setInterval函数，对Canvas画板进行周期性重绘。每次重绘时，首先要使用clearRect对Canvas画板进行清空整个画板，再调用需要重绘的各个API函数，这样可以达到重新绘制所有图形的目的。 lufylegend库件初始化时，会根据浏览器来判断需要加载的是mouse事件还是touch事件。再利用lufylegend库件加载点击事件的时候，只是将被加载的事件加入了框架预先准备的数组中，当点击事件发生的时候才会调用这个数组里的事件。 1.2 库件使用流程 从http://lufylegend.com/lufylegend下载库件最新版。 压缩包内包含lufylegend-x.x.x.js和lufylegend-x.x.x.min.js两个完整版本，还有lufylegend-x.x.x.simple.js和lufylegend-x.x.x.simple.min.js两个缩减版本，***.min是去除了回车和空格的压缩版本。 simple缩减版本与完整版本的区别在于，将LBox2d，LQuadTree，LTransitionManager，LoadingSample1，LoadingSample2，LoadingSample3，LoadingSample4，LoadingSample5等几个类与引擎的常用部分分离，缩减了引擎的体积。如果用到了被分离的部分的功能的话，可以进行手动加载。 在html中将库件引入。 调用LInit函数，初始化库件。 示例代码： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../lufylegend-1.7.6.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mylegend&quot;&gt;loading...&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ alert(&quot;lufylegend start&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;二、图片的加载与显示步骤： 使用Lloader类加载图片数据 将读取完的图片数据保存到LbitmapData中 利用Lbitmap将图片显示到画板上 2.1 图片显示举例&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../lufylegend-1.7.6.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mylegend&quot;&gt;loading...&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ /*给Image添加一个onload事件*/ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ /*图片读取完调用loadBitmapdata函数，新建一个LBitmapData对象。此时的loader.content就是一个Image*/ /*LbitmapData是lufylend库件的一个类，用来保存和读取Image对象，如果要将图片显示到Canvas画板上，则需要用到Lbitmap*/ var bitmapdata = new LBitmapData(loader.content); /*LBitmap的功能是将Image对象显示到Canvas画板上*/ var bitmap = new LBitmap(bitmapdata); addChild(bitmap); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;给Image添加一个onload事件的代码： loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(“face.jpg”,”bitmapData”); 等价于: var image = new Image(); image.onload = function(){ };上面的代码可以看出图片显示主要用到LBitmapData和LBitmap两个对象。 2.2 LBitmapData对象 LBitmapData（image,x,y,width,height） 参数针对可视范围，若后面四个参数缺省，则显示整张图片 &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content,50,50,150,150); var bitmap = new LBitmap(bitmapdata); addChild(bitmap); } &lt;/script&gt;2.3 LBitmap对象功能： 将图片显示到Canvas画板上 控制图片的各种属性，坐标（x,y）、透明度（rotate）、旋转(rotate)、缩放(scaleX、scaleY)等 /设置图片旋转与透明度/ var loader; init(50,\"mylegend\",500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(\"face.jpg\",\"bitmapData\"); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var bitmap = new LBitmap(bitmapdata); //图片坐标 bitmap.x = 50; bitmap.y = 50; //图片旋转60度 bitmap.rotate = 60; //图片透明度设置为0.4 bitmap.alpha = 0.4; addChild(bitmap); } 三、层的概念如果把不同的图形放到不同层，我么就能觉得这些图像在游戏画面里出现的顺序。 lufylegend.js库件为Canvas实现了层的概念，就是LSprite对象。 创建LSprite对象，并把layer层添加到画板： var layer = new LSprite(); addChild(layer);把layer层添加到画板，然后将bitmap添加到layer层： var layer = new LSprite(); addChild(layer); layer.addChild(bitmap);LSprite对象也和LBitmap对象一样，有坐标（x,y）、透明度（rotate）、旋转(rotate)、缩放(scaleX、scaleY)等属性，不过它控制的是整个层的属性。 /*使用LSprite对象的旋转属性*/ &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var bitmap = new LBitmap(bitmapdata); //加入层LSprite var layer = new LSprite(); addChild(layer); layer.addChild(bitmap); layer.x = 50; layer.y = 50; layer.rotate = 60; } &lt;/script&gt;四、使用LGraphics对象绘图LGraphics是lufylegend库件中的一个绘图类，它内置了一些函数以简化绘图。 可以单独属于，也可以与LSprite对象配合使用。 4.1 绘制矩形使用LGraphics对象中的drawRect函数绘制矩形： drawRect （thickness,lineColor,pointArray,isfill,color） &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var graphics = new LGraphics(); addChild(graphics); graphics.drawRect(1,&apos;#000000&apos;,[50,50,100,100]); graphics.drawRect(1,&apos;#000000&apos;,[170,50,100,100],true,&apos;#cccccc&apos;); } &lt;/script&gt;4.2 绘制圆 drawArc (thickeness,lineColor,pointArray,isfull,color) pointArray:圆形参数数组[坐标x,坐标y,半径，起始角度，结束角度，顺时针或逆时针] &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ /*建立一个绘图对象，并将其加载到Cavans画板上*/ var graphics = new LGraphics(); addChild(graphics); /*画一个空心圆*/ graphics.drawArc(1,&apos;#000000&apos;,[60,60,50,0,360*Math.PI/180]); /*画一个实心圆*/ graphics.drawArc(1,&apos;#000000&apos;,[180,60,50,0,360*Math.PI/180],true,&apos;#cccccc&apos;); } &lt;/script&gt;4.3 绘制任意多边形 drawVertices (thickness,lineColor,vertices,isfill,color) vertices:顶点数组[[顶点1],[顶点2],[顶点3]…] &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var graphics = new LGraphics(); addChild(graphics); /*画一个空心六边形*/ graphics.drawVertices(1,&apos;#000000&apos;,[[50,20],[80,20],[100,50],[80,80],[50,80],[30,50]]); /*画一个填充六边形*/ graphics.drawVertices(1,&apos;#000000&apos;,[[150,20],[180,20],[200,50],[180,80],[150,80],[130,50]],true,&apos;#cccccc&apos;); } &lt;/script&gt;4.4 使用Canvas原始绘图函数进行绘图LGraphics对象可以使用Canvas的原始绘图函数进行绘图。 script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ /*建立一个绘图对象，并将其加载到Canvas画板上*/ var graphics = new LGraphics(); addChild(graphics); /*调用LGraphics对象中的add函数，传入绘图函数*/ graphics.add(function(coodx,coody){ LGlobal.canvas.strokeStyle = &quot;#000000&quot;; LGlobal.canvas.moveTo(20,20); LGlobal.canvas.lineTo(200,200); LGlobal.canvas.stroke(); }); } &lt;/script&gt;因为写在fun内部的JavaScript代码都会被运行，所以绘制图形的代码可以写在他的里面。 这里用到的LGlobal.canvas其实就是getContext(“2d”)所返回的对象。 add函数原型：add(fun) 4.5 使用LSprite对象进行绘图由于每个LSprite对象都包含一个LGraphics对象，所以上面的绘图都可以使用LSprite对象中的graphics来实现，比如4.1中画一个矩形的代码也可以这样写： &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var layer = new LSprite(); addChild(layer); layer.graphics.drawRect(1,&apos;#000000&apos;,[50,50,100,100]); layer.graphics.drawRect(1,&apos;#000000&apos;,[170,50,100,100],true,&apos;#cccccc&apos;); } &lt;/script&gt;4.6 使用LGraphics对象绘制图片使用LGraphics对象绘制图片，主要是结合LGraphics对象的beginBitmapfull函数来实现的。 4.6.1 绘制一个圆形区域的图片LGraphics对象的beginBitmapfull函数和drawArc函数结合起来使用 &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var backLayer = new LSprite(); addChild(backLayer); backLayer.graphics.beginBitmapFill(bitmapdata); backLayer.graphics.drawArc(1,&quot;#000&quot;,[110,80,50,0,Math.PI*2]); } &lt;/script&gt;解析： 利用beginBitmapfull函数将LBitmapData对象存储到LGraphics对象中： backLayer.graphics.beginBitmapFill(bitmapdata);利用drawArc函数绘制一个圆形区域。LBitmapData对象会直接将存储在自己内部的BitmapData对象通过这个圆形区域显示出来： backLayer.graphics.drawArc(1,&quot;#000&quot;,[110,80,50,0,Math.PI*2]);4.6.2 绘制一个矩形区域的图片&lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var backLayer = new LSprite(); addChild(backLayer); backLayer.graphics.beginBitmapFill(bitmapdata); backLayer.graphics.drawRect(1,&quot;#000&quot;,[80,50,70,100]); } &lt;/script&gt;4.6.3 绘制一个多边形区域的图片LGraphics对象的beginBitmapfull函数和drawVertices函数结合起来使用 &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var backLayer = new LSprite(); addChild(backLayer); backLayer.graphics.beginBitmapFill(bitmapdata); backLayer.graphics.drawVertices(1,&quot;#000&quot;,[[120,50],[100,200],[200,150]]); } &lt;/script&gt;4.6.4 绘制一个扭曲的图片LGraphics对象的beginBitmapfull函数和drawTriangles函数结合起来使用 drawTriangles函数:drawTriangles(vertices,indices,uvtData,thickness,color) vertices：由数字构成的矢量，其中每一对数字将被视为一个坐标位置（x,y），该参数是必须要有的 indices：由整数或索引构成的矢量，其中每3个索引定义一个三角形，如果indeces参数为null，则每三个顶点定义一个三角形。（三角形定点顺序：左上-右上-左下或右上-左下-右下） uvtData：用于应用纹理映射的标准坐标构成的矢量。表示定义上面的每个顶点相对于整张图片的比例 thickness：分割玩的三角形边框线宽 color：分割玩的三角形边框颜色 &lt;script type=&quot;text/javascript&quot;&gt; var loader; init(50,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;face.jpg&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content); var backLayer = new LSprite(); backLayer.x=100; addChild(backLayer); vertices = new Array(); vertices.push(0, 0); vertices.push(0-50, 120);//这里将原坐标的x坐标左移50 vertices.push(0, 240); vertices.push(120, 0); vertices.push(120, 120); vertices.push(120, 240); vertices.push(240, 0); vertices.push(240+50, 120);//这里将原坐标的x坐标右移50 vertices.push(240, 240); indices = new Array(); indices.push(0, 3, 1); indices.push(3, 1, 4); indices.push(1, 4, 2); indices.push(4, 2, 5); indices.push(3, 6, 4); indices.push(6, 4, 7); indices.push(4, 7, 5); indices.push(7, 5, 8); uvtData = new Array(); uvtData.push(0, 0); uvtData.push(0, 0.5); uvtData.push(0, 1); uvtData.push(0.5, 0); uvtData.push(0.5, 0.5); uvtData.push(0.5, 1); uvtData.push(1, 0); uvtData.push(1, 0.5); uvtData.push(1, 1); backLayer.graphics.beginBitmapFill(bitmapdata); backLayer.graphics.drawTriangles(vertices, indices, uvtData); } &lt;/script&gt;4.6.5 实现3d效果使用drawTriangles函数，示例代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;3D&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../lufylegend-1.7.6.min.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; LSystem.screen(0.5); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;legend&quot;&gt; &lt;/div&gt; &lt;script&gt; init(50, &quot;legend&quot;, 600, 500, main); var leftspeed = 0; var leftindex = 1; var upspeed = 10; var upindex = 1; var vertices; var indices; var uvtData; var backLayer; var bitmapData, earthBitmapData; var rows = 24, cols = 24; var mi = 0; var imgData = [{ name: &quot;earth&quot;, path: &quot;earth.jpg&quot; }]; var imglist; function main(){ LLoadManage.load(imgData, null, gameInit); } function gameInit(result){ imglist = result; earthBitmapData = new LBitmapData(imglist[&quot;earth&quot;]); //earthBitmapData = new LBitmapData(&quot;#ffffff&quot;, 0, 0, 500, 300); var i, j; var r = 100; vertices = new Array(); for (i = 0; i &lt;= cols; i++) { for (j = 0; j &lt;= rows; j++) { var angle = (90 - 180 * j / rows) * Math.PI / 180; var a = Math.sin(angle); if ((90 - 180 * j / rows) % 90 == 0 &amp;&amp; (90 - 180 * j / rows) % 180 != 0) a = (90 - 180 * j / rows) &gt; 0 ? 1 : -1; if ((90 - 180 * j / rows) % 180 == 0) a = 0; var sy = -r * a; var sa = Math.cos(angle); if ((90 - 180 * j / rows) % 180 == 0) sa = 1; var sr = Math.abs(r * sa); var angle2 = 360 * (i + 1) / cols; var b = Math.cos(angle2 * Math.PI / 180); if (angle2 % 360 == 0) b = 1; else if (angle2 % 180 == 0) b = -1; var sx = sr * b; vertices.push(sx, sy); } } indices = new Array(); for (i = 0; i &lt; cols; i++) { for (j = 0; j &lt; rows; j++) { indices.push(i * (rows + 1) + j, (i + 1) * (rows + 1) + j, i * (rows + 1) + j + 1); indices.push((i + 1) * (rows + 1) + j, i * (rows + 1) + j + 1, (i + 1) * (rows + 1) + j + 1); } } uvtData = new Array(); for (i = 0; i &lt;= cols; i++) { for (j = 0; j &lt;= rows; j++) { uvtData.push(i / cols, j / rows); } } backLayer = new LSprite(); backLayer.x = 110; backLayer.y = 110; addChild(backLayer); backLayer.graphics.clear(); backLayer.graphics.beginBitmapFill(earthBitmapData); backLayer.graphics.drawTriangles(vertices, indices, uvtData); backLayer.addEventListener(LEvent.ENTER_FRAME, onframe); } function onframe(){ if (leftspeed &lt; 10 &amp;&amp; leftindex++ &gt; leftspeed) { leftindex = 0; for (i = 0; i &lt;= rows; i++) { uvtData.push(uvtData.shift()); uvtData.push(uvtData.shift()); } } if (upspeed &lt; 10 &amp;&amp; upindex++ &gt; upspeed) { upindex = 0; for (var i = 1; i &lt; uvtData.length; i += 2) { uvtData[i] += 1 / rows; if (uvtData[i] &gt; 1) uvtData[i] -= 1; } } } function runspeed(value){ leftspeed = 10 - value; } function runmax(value){ backLayer.scaleX = value / 50; backLayer.scaleY = backLayer.scaleX; } &lt;/script&gt; &lt;div id=&quot;mylegend1&quot; style=&quot;position:absolute;top:400px;width:400px;z-index:1;color: #ffffff;background-color:#000000;&quot;&gt; 旋转速度:&lt;input type=&quot;number&quot; max=&quot;10&quot; min=&quot;0&quot; value=&quot;10&quot; onchange=&quot;runspeed(this.value);&quot;/&gt; &lt;br/&gt; 伸缩:&lt;input type=&quot;number&quot; max=&quot;100&quot; min=&quot;0&quot; value=&quot;50&quot; onchange=&quot;runmax(this.value);&quot;/&gt;% &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;五、文本5.1 文本属性创建的文本框对象不会自动加入可视化对象列表中，只有手动调用addChild（）方法添加它才能显示。 &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var layer = new LSprite(); addChild(layer); var field = new LTextField(); field.text = &quot;Hello World!&quot;; layer.addChild(field); } &lt;/script&gt;加一些改进： &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var layer = new LSprite(); addChild(layer); var field = new LTextField(); field.x = 50; field.y = 50; field.text = &quot;Hello World!&quot;; field.size = 25; field.color = &quot;#333333&quot;; field.weight = &quot;bolder&quot;; layer.addChild(field); } &lt;/script&gt;5.2 输入框LTextField只要将文本的texttype属性设置为LTextFieldType.INPUT，就可以将文本变成输入框 &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,500,350,main); function main(){ var layer = new LSprite(); addChild(layer); var field = new LTextField(); field.x = 50; field.y = 50; field.setType(LTextFieldType.INPUT); layer.addChild(field); } &lt;/script&gt;六、事件6.1 鼠标事件鼠标事件分为鼠标按下、鼠标弹起和鼠标移动事件 &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,300,300,main); var field; function main(){ var layer = new LSprite(); layer.graphics.drawRect(1,&apos;#cccccc&apos;,[0,0,300,300],true,&apos;#cccccc&apos;); addChild(layer); /*建立一个文本*/ field = new LTextField(); field.text = &quot;Wait Click!&quot;; layer.addChild(field); /*给layer对象加载鼠标按下和鼠标弹起事件侦听*/ layer.addEventListener(LMouseEvent.MOUSE_DOWN,downshow); layer.addEventListener(LMouseEvent.MOUSE_UP,upshow); } /*侦听鼠标按下和弹起事件，当鼠标按下时...*/ function downshow(event){ field.text = &quot;Mouse Down!&quot;; } function upshow(event){ field.text = &quot;Mouse Up!&quot;; } &lt;/script&gt;注意：手机上用TOUCh_START等代替，但是这个库件会根据运行环境自动转换，所以不用自行切换。 6.2 循环事件使用LRvent.ENTER_FRAMR来添加侦听循环事件 /*现象：屏幕上文本从开始不断自增*/ &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,300,300,main); var field; function main(){ var layer = new LSprite(); layer.graphics.drawRect(1,&apos;#cccccc&apos;,[0,0,300,300],true,&apos;#cccccc&apos;); addChild(layer); field = new LTextField(); field.text = &quot;0&quot;; layer.addChild(field); /*给layer对象加载循环时间侦听*/ layer.addEventListener(LEvent.ENTER_FRAME,onframe); } /*回调函数*/ function onframe(){ field.text = parseInt(field.text) + 1; } &lt;/script&gt;6.3 键盘事件使用LKeyboardEvent.KEY_DOWN、LKeyboardEvent.KEY_up、LKeyboardEvent.KEY_PRESS来侦听键盘事件 由于键盘事件需要加载到window上，所以加载的时候与前面讲述的方法会稍微有些变化。 &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,300,300,main); var field; function main(){ var layer = new LSprite(); layer.graphics.drawRect(1,&apos;#cccccc&apos;,[0,0,300,300],true,&apos;#cccccc&apos;); addChild(layer); field = new LTextField(); field.text = &quot;Wait Click!&quot;; layer.addChild(field); LEvent.addEventListener(LGlobal.window,LKeyboardEvent.KEY_DOWN,downshow); LEvent.addEventListener(LGlobal.window,LKeyboardEvent.KEY_UP,upshow); } function downshow(event){ field.text = event.keyCode + &quot; Down!&quot;; } /*键盘按键的值*/ function upshow(event){ field.text = event.keyCode + &quot; Up!&quot;; } &lt;/script&gt;这里使用LEvent.addEventListener来加载键盘事件，其中LGlobal.window就是window对象，所以键盘事件就是加载到window对象上的，这样能侦听到整个浏览器窗口。 LEvent.addEventListener(LGlobal.window,LKeyboardEvent.KEY_DOWN,downshow); LEvent.addEventListener(LGlobal.window,LKeyboardEvent.KEY_UP,upshow);6.7 按钮内置LButton类来添加按钮 LButton(DisplayObject_up,DisplayObject_over) DisplayObject_up:按钮默认up状态，当鼠标不在按钮上，按钮就处于这个状态 DisplayObject_up：鼠标在按钮时的状态 传入按钮的这两个状态对象，可以是LSprite对象，也可以是LBitmap对象 &lt;script type=&quot;text/javascript&quot;&gt; init(50,&quot;mylegend&quot;,300,300,main); var loader,bitmapup,bitmapover,field; /*读取两种图片，准备接下来当作按钮的两个状态*/ function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadUp); loader.load(&quot;up.png&quot;,&quot;bitmapData&quot;); } function loadUp(event){ bitmapup = new LBitmap(new LBitmapData(loader.content)); loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadOver); loader.load(&quot;over.png&quot;,&quot;bitmapData&quot;); } function loadOver(){ bitmapover = new LBitmap(new LBitmapData(loader.content)); var layer = new LSprite(); addChild(layer); field = new LTextField(); field.text = &quot;Wait Click!&quot;; layer.addChild(field); /*新建LButton按钮对象，并将bitmapup、bitmapover做为参数传给这个按钮*/ var testButton = new LButton(bitmapup,bitmapover); testButton.y = 50; layer.addChild(testButton); /*LButton继承自类LSprite，所以由LSprite类的所有属性和方法，这样就可以给按钮添加鼠标点击事件了*/ testButton.addEventListener(LMouseEvent.MOUSE_DOWN,downshow); } function downshow(event){ field.text = &quot;testButton Click!&quot;; } &lt;/script&gt;八、动画 LAnimation(layer,data,list) layer:LSprite对象data:LBitmapData对象list:一个存储坐标的二维数组 动画需要一个坐标的二维数组，也就是小图片的坐标，这里用LGlobal.dividiCooedinate函数来实现： LGlobal.dividiCooedinate(width,height,row,col) row：行数col:列数 &lt;script type=&quot;text/javascript&quot;&gt; var loader,anime,layer; init(200,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;chara.png&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ /*将读取完的Image保持到LBitmapData,显示范围为（0，0，64，64）*/ var bitmapdata = new LBitmapData(loader.content,0,0,64,64); /*建一个保存有坐标位置的二维数组*/ var list = LGlobal.divideCoordinate(256,256,4,4); //加入层LSprite layer = new LSprite(); addChild(layer); /*建一个LAnimation类，并将上面准备好的layer、bitmapdata、list作为参数传入LAnimation对象中*/ anime = new LAnimation(layer,bitmapdata,list); /*给layer层添加循环事件侦听*/ layer.addEventListener(LEvent.ENTER_FRAME,onframe); } /*循环事件的回调函数调用LAnimation类的onframe函数，来实现动画的顺序循环播放*/ function onframe(){ anime.onframe(); } &lt;/script&gt;LAnimation类的onframe函数的功能是将所播放图片的列号加1，如果循环onframe函数，就变成动画了。但是目前只是实现了第一行图片的循环播放，如果实现所有图片的循环播放，则需要用LAnimation类的setAction函数。 setAction(rowIndex,colIndex) rowIndex:数组行号colIndex：数组列号 如果只需要改变播放的行号，那么第二个参数可省。 &lt;script type=&quot;text/javascript&quot;&gt; var loader,anime,layer; init(200,&quot;mylegend&quot;,500,350,main); function main(){ loader = new LLoader(); loader.addEventListener(LEvent.COMPLETE,loadBitmapdata); loader.load(&quot;chara.png&quot;,&quot;bitmapData&quot;); } function loadBitmapdata(event){ var bitmapdata = new LBitmapData(loader.content,0,0,64,64); var list = LGlobal.divideCoordinate(256,256,4,4); //加入层LSprite layer = new LSprite(); addChild(layer); anime = new LAnimation(layer,bitmapdata,list); layer.addEventListener(LEvent.ENTER_FRAME,onframe); } function onframe(){ /*使用LAnimation类的getAction函数取得anime对象当前所播放动画的行号列好，其返回值为数组类型[行号，列号]*/ var action = anime.getAction(); /*利用switch对当前所播放动画的行号进行了区别处理，[0,1,2,3]这4个行号分别代表下、左、右、上4个方向，然后再4个方向上改变坐标值进行相应的移动，并且根据所移动到达的位置来该百年移动的方向*/ switch(action[0]){ case 0: layer.y += 5; if(layer.y &gt;= 200){ anime.setAction(2); } break; case 1: layer.x -= 5; if(layer.x &lt;= 0){ anime.setAction(0); } break; case 2: layer.x += 5; if(layer.x &gt;= 200){ anime.setAction(3); } break; case 3: layer.y -= 5; if(layer.y &lt;= 0){ anime.setAction(1); } break; } /*循环事件的回调函数调用LAnimation类的onframe函数，来实现动画的肾虚循环播放*/ anime.onframe(); } &lt;/script&gt;九、致谢本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第四章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"使用Canvas制作一个自定义画板","slug":"使用Canvas制作一个自定义画板","date":"2019-08-16T12:48:21.000Z","updated":"2019-08-17T01:21:05.840Z","comments":true,"path":"2019/08/16/使用Canvas制作一个自定义画板/","link":"","permalink":"http://yoursite.com/2019/08/16/使用Canvas制作一个自定义画板/","excerpt":"制作一个自定义画板，进一步熟悉一下Canvas的API 用法。","text":"制作一个自定义画板，进一步熟悉一下Canvas的API 用法。 一、画板的建立需求分析： （1）当鼠标按下的时候，开始描画，此处需要加入鼠标按下事件。（2）当鼠标弹起的时候，结束描画，此处需要加入鼠标弹起事件。（3）在鼠标按下并且移动的时候，在鼠标经过的路径上画线，此处需要加入鼠标移动事件。 代码实现： 下列代码画了一个黑色矩形区域，作为画板。 // 画一个黑色矩形 ctx.fillStyle=&quot;black&quot;; ctx.fillRect(0,0,600,300);下面建立了 3 个变量，变量 onoff 用来控制鼠标是否按下，只有当鼠标按下的时候才会 开始绘图。变量 oldx、oldy 表示鼠标发生移动前的坐标。 // 按下标记 var onoff = false; var oldx = -10; var oldy = -10;下面设置画笔的颜色为白色，线宽为 4。 // 设置颜色 var linecolor = &quot;white&quot;; // 设置线宽 var linw = 4;下面给 Canvas 添加了鼠标按下侦听事件，当鼠标按下的时候，会调用 down 函数。 // 添加鼠标按下事件 canvas.addEventListener(&quot;mousedown&quot;,down,false);下面给 Canvas 添加了鼠标弹起侦听事件，当鼠标弹起的时候，会调用 up 函数。 // 添加鼠标弹起事件 canvas.addEventListener(&quot;mouseup&quot;,up,false);下面给 Canvas 添加了鼠标移动侦听事件，当鼠标在 Canvas 上移动的时候，会持续调用draw 函数。 // 添加鼠标移动事件 canvas.addEventListener(&quot;mousemove&quot;,draw,true);三个函数： down 函数是在鼠标按下的时候调用的。当调用 down 函数的时候，会将 onoff 变量设置为 true，表示开始绘图，并给 oldx、oldy 赋予鼠标当前位置的坐标值。 function down(event){ onoff = true; oldx = event.pageX-10; oldy = event.pageY-10; }up 函数是在鼠标弹起的时候调用的。当调用 up 函数的时候，将 onoff 变量设置为 false，表示结束绘图。 function up(){ onoff = false; }draw 函数是在鼠标发生移动的时候不断持续调用的。当调用 draw 函数的时候，首先判断 onoff 变量的值，即判断鼠标是否处于按下状态，如果鼠标处于按下状态，则开始画线。 function draw(event){ if(onoff == true){ var newx = event.pageX-10; var newy = event.pageY-10; ctx.beginPath(); ctx.moveTo(oldx,oldy); ctx.lineTo(newx,newy); ctx.strokeStyle=linecolor; ctx.lineWidth=linw; ctx.lineCap=&quot;round&quot;; ctx.stroke(); oldx = newx; oldy = newy; }每次画线时，需要确定线条的起始位置和结束位置，线条的起始位置就是坐标(oldx,oldy)，然后把当前鼠标位置作为线条的结束位置，代码如下所示 ： var newx = event.pageX-10; var newy = event.pageY-10; 接着，利用 moveTo 和 lineTo 画线，代码如下所示 ： ctx.beginPath(); ctx.moveTo(oldx,oldy); ctx.lineTo(newx,newy); ctx.strokeStyle=linecolor; ctx.lineWidth=linw; ctx.lineCap=&quot;round&quot;; ctx.stroke();上面的代码是画一条从坐标 (oldx,oldy) 到坐标 (newx,newy) 的线段，并设置了线条的颜色、宽度和线帽的类型。 在此次绘制结束后，新的鼠标位置将作为下一次画线的起始位置，代码如下所示 ： oldx = newx; oldy = newy;实现效果： 二、加入按钮操作改变画笔颜色和线条宽度的功能下面的代码加入了 6 个按钮，并加入了单击事件，当单击不同按钮的时候，就会相应地改变画笔的颜色。 &lt;button style=&quot;width:80px;background-color:yellow;&quot; onclick=&apos;linecolor = &quot;yellow&quot;;&apos;&gt;YELLOW&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:red;&quot; onclick=&apos;linecolor = &quot;red&quot;;&apos;&gt;RED&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:blue;&quot; onclick=&apos;linecolor = &quot;blue&quot;;&apos;&gt;BLUE&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:green;&quot; onclick=&apos;linecolor = &quot;green&quot;;&apos;&gt;GREEN&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&apos;linecolor = &quot;white&quot;;&apos;&gt;WHITE&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:black;color:white;&quot; onclick=&apos;linecolor = &quot;black&quot;;&apos;&gt;BLACK&lt;/button&gt;下面的代码加入了 3 个按钮，并加入了单击事件，当单击不同按钮的时候，就会相应地改变线条的宽度。 &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 4;&quot;&gt;4px&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 8;&quot;&gt;8px&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 16;&quot;&gt;16px&lt;/button&gt;实现效果： 三、画布的导出功能画板的图片导出功能，即复制Canvas 画板上的图像，使其保存为图片格式。 要将 Canvas 画板保存为图片格式，只需要使用下面的方法即可： canvas.toDataURL(&quot;image/png&quot;);现在可在页面上新建一个 标签，然后将复制的 Canvas 内容用 表示出来。 代码如下： /**添加一个导出按钮/ &lt;button id=&quot;but10&quot; style=&quot;width:80px;background-color:pink;&quot; onclick=&quot;copyimage();&quot;&gt;EXPORT&lt;/button&gt; /*新建一个 &lt;img &gt; 标签*/ &lt;img src=&quot;&quot; id=&quot;image_png&quot; width=&quot;600&quot; height=&quot;300&quot;&gt; /*将复制的 Canvas 内容用 &lt;img&gt; 表示出来*/ function copyimage(event){ var img_png_src = canvas.toDataURL(&quot;image/png&quot;); document.getElementById(&quot;image_png&quot;).src = img_png_src; }实现效果： 四、完整代码&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;300&quot;&quot;&gt;&lt;/canvas&gt;&lt;br&gt; &lt;button style=&quot;width:80px;background-color:yellow;&quot; onclick=&apos;linecolor = &quot;yellow&quot;;&apos;&gt;YELLOW&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:red;&quot; onclick=&apos;linecolor = &quot;red&quot;;&apos;&gt;RED&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:blue;&quot; onclick=&apos;linecolor = &quot;blue&quot;;&apos;&gt;BLUE&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:green;&quot; onclick=&apos;linecolor = &quot;green&quot;;&apos;&gt;GREEN&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&apos;linecolor = &quot;white&quot;;&apos;&gt;WHITE&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:black;color:white;&quot; onclick=&apos;linecolor = &quot;black&quot;;&apos;&gt;BLACK&lt;/button&gt; &lt;br&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 4;&quot;&gt;4px&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 8;&quot;&gt;8px&lt;/button&gt; &lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 16;&quot;&gt;16px&lt;/button&gt; &lt;br&gt; &lt;button id=&quot;but10&quot; style=&quot;width:80px;background-color:pink;&quot; onclick=&quot;copyimage();&quot;&gt;EXPORT&lt;/button&gt; &lt;br&gt; &lt;img src=&quot;&quot; id=&quot;image_png&quot; width=&quot;600&quot; height=&quot;300&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;canvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); //画一个黑色矩形 ctx.fillStyle=&quot;black&quot;; ctx.fillRect(0,0,600,300); //按下标记 var onoff = false; var oldx = -10; var oldy = -10; //设置颜色 var linecolor = &quot;white&quot;; //设置线宽 var linw = 4; //添加鼠标移动事件 canvas.addEventListener(&quot;mousemove&quot;,draw,true); //添加鼠标按下事件 canvas.addEventListener(&quot;mousedown&quot;,down,false); //添加鼠标弹起事件 canvas.addEventListener(&quot;mouseup&quot;,up,false); function down(event){ onoff = true; oldx = event.pageX-10; oldy = event.pageY-10; } function up(){ onoff = false; } function draw(event){ if(onoff == true){ var newx = event.pageX-10; var newy = event.pageY-10; ctx.beginPath(); ctx.moveTo(oldx,oldy); ctx.lineTo(newx,newy); ctx.strokeStyle=linecolor; ctx.lineWidth=linw; ctx.lineCap=&quot;round&quot;; ctx.stroke(); oldx = newx; oldy = newy; }; }; function copyimage(event){ var img_png_src = canvas.toDataURL(&quot;image/png&quot;); document.getElementById(&quot;image_png&quot;).src = img_png_src; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"Canvas高级功能","slug":"Canvas高级功能","date":"2019-08-16T10:16:53.000Z","updated":"2019-08-16T12:44:46.270Z","comments":true,"path":"2019/08/16/Canvas高级功能/","link":"","permalink":"http://yoursite.com/2019/08/16/Canvas高级功能/","excerpt":"本文将介绍Canvas 中的缩放、平移、旋转和倾斜等基本变形功能的实现，并且利用这些基本变形的组合操作实现了图片的扭曲以及介绍一下色彩的渲染","text":"本文将介绍Canvas 中的缩放、平移、旋转和倾斜等基本变形功能的实现，并且利用这些基本变形的组合操作实现了图片的扭曲以及介绍一下色彩的渲染 一、变形默认情况下，一个画布的坐标空间会使用画布的左上角 (0,0) 作为原点，x 值向右增加，y 值向下增加。这个坐标空间中的单位通常会被转换为像素，然后，可通过转换坐标空间在绘图过程中实现移动、缩放或旋转等操作。这些操作是通过 translate()、scale() 和 rotate() 等方法来实现的，它们会对画布的变换矩阵产生影响。 1.1 放大与缩小用scale函数来实现图形的放大和缩小： scale(x, y); 第一个参数 x 表示在 x 轴进行缩放，即水平缩放 第二个参数 y 表示在 y 轴上进行缩放，即在竖直方向上进行缩放 var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); /*画一个宽150，高100的黑色矩形*/ ctx.beginPath(); ctx.strokeStyle = \"#000000\"; ctx.strokeRect(10,10,150,100); /*将原先的矩形沿x、y方向放大3倍，并重画一个灰色矩形*/ ctx.scale(3,3); ctx.beginPath(); ctx.strokeStyle = \"#cccccc\"; ctx.strokeRect(10,10,150,100); /*将黑色矩形缩小到0.5倍*/ ctx.scale(0.5,0.5); ctx.beginPath(); ctx.strokeStyle = \"#cccccc\"; ctx.strokeRect(50,50,150,100); 用scale函数参数为负来实现图形的翻转： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot; style=&quot;background-color: #cccccc;&quot;&gt; 你的浏览器不支持HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); ctx.scale(1,-1); ctx.drawImage(image,250,-250); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;1.2 平移使用 translate 函数可以实现对图形进行平移的功能。 translate (x, y); 第一个参数 x 表示在 x 轴进行平移，即在水平方向上平移 第二个参数 y 表示在 y 轴上进行缩放，即在竖直方向上平移。 var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); ctx.beginPath(); ctx.strokeStyle = \"#000000\"; ctx.strokeRect(10,10,150,100); ctx.translate(50,100); ctx.beginPath(); ctx.strokeStyle = \"#cccccc\"; ctx.strokeRect(10,10,150,100); 1.3 旋转使用rotate函数可以实现图形的旋转功能。 rotate (angle);注意：传入rotate的参数angle是弧度不是角度。如果角度是angle，那么换算成弧度就是angle*Math.PI/180。 以Canvas的起始坐标（0，0）为中心进行旋转： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(200,50,100,50); ctx.rotate(45*Math.PI/180); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(200,50,100,50); &lt;/script&gt;使用1.2中的translate函数，让图形以自己为中心旋转： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(200,50,100,50); /*先将Canvas的起始坐标移动到所画矩形的中心处，然后旋转，再将Canvas起始坐标返回*/ ctx.translate(250,75); ctx.rotate(45*Math.PI/180); ctx.translate(-250, -75); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(200,50,100,50); &lt;/script&gt;1.4 利用 transform 矩阵实现多样化的变形上面分别讲了缩放、平移以及旋转的实现方法。其实所有这些变形都是可以通过变形矩阵 transform 来实现的。 transform (a,b,c,d,e,f); 该函数的各个变量对应以下变换矩阵中相应位置的参数： 1.4.1 缩放设原始坐标为（x,y）,缩放后坐标为（x1,y1）缩放倍数分别为a,d,那么： x1 = a*x x2 = d*y 得到矩阵公式： 这样就可以用transform(a,0,0,d,0,0)来代替scale（a,d）了。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(10,10,150,100); /*将原先的矩形沿x、y方向放大3倍，并重画一个灰色矩形*/ ctx.transform(3,0,0,3,0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(10,10,150,100); &lt;/script&gt;1.4.2 平移设原始坐标为（x,y）,缩放后坐标为（x1,y1）x,y平移量分别为e,f,那么： x1 = x+e x2 = y+f 得到矩阵公式： 这样就可以用transform(1,0,0,1,e,f)来代替translate（e,f）了。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(10,10,150,100); ctx.transform (1,0,0,1,50,100); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(10,10,150,100); &lt;/script&gt;1.4.3 旋转 现在可以用 transform (cos θ, sin θ, –sin θ, cos θ,0,0) 来替换 rotate (θ) 了 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(200,50,100,50); ctx.transform (Math.cos(45*Math.PI/180),Math.sin(45*Math.PI/180),-Math.sin(45*Math.PI/180), Math.cos(45*Math.PI/180),0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(200,50,100,50); &lt;/script&gt;变换矩阵也可以通过 setTransform 函数来实现，setTransform 的参数与 transform 一样，不同的是，setTransform 函数是先消去之前的 transform 变换，然后重新进行变换的 transform:第二次在第一次的基础上再旋转10度，相当于旋转了15度 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(200,50,100,50); /*首先旋转5度*/ ctx.transform (Math.cos(5*Math.PI/180),Math.sin(5*Math.PI/180),-Math.sin(5*Math.PI/180), Math.cos(5*Math.PI/180),0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(200,50,100,50); /*第二次在第一次的基础上再旋转10度，相当于旋转了15度*/ ctx.transform (Math.cos(10*Math.PI/180),Math.sin(10*Math.PI/180),-Math.sin(10*Math.PI/180), Math.cos(10*Math.PI/180),0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#999999&quot;; ctx.strokeRect(200,50,100,50);setTransform:清楚transform历史，重新旋转 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.strokeStyle = &quot;#000000&quot;; ctx.strokeRect(200,50,100,50); /*首先旋转5度*/ ctx.transform (Math.cos(5*Math.PI/180),Math.sin(5*Math.PI/180),-Math.sin(5*Math.PI/180), Math.cos(5*Math.PI/180),0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#cccccc&quot;; ctx.strokeRect(200,50,100,50); /*清除第一次旋转5度的历史，重新对原来的图形旋转10度*/ ctx.setTransform (Math.cos(10*Math.PI/180),Math.sin(10*Math.PI/180),-Math.sin(10*Math.PI/180), Math.cos(10*Math.PI/180),0,0); ctx.beginPath(); ctx.strokeStyle = &quot;#999999&quot;; ctx.strokeRect(200,50,100,50); &lt;/script&gt;1.4.4 倾斜倾斜1: 图中3点p0、p2、p3遵循公式：将上面的矩形公式代入steTransform函数中 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&apos;myCanvas&apos;); var ctx=c.getContext(&apos;2d&apos;); ctx.setTransform(1,10/150,-40/100,1,40,10); ctx.rect(50,50,150,100); ctx.stroke(); &lt;/script&gt;结果： 倾斜2:图中3点p1、p2、p3遵循公式：将上面的矩形公式代入steTransform函数中 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&apos;myCanvas&apos;); var ctx=c.getContext(&apos;2d&apos;); ctx.setTransform(130/150,-20/150,-20/100,80/100,0,0); ctx.rect(50,50,150,100); ctx.stroke(); &lt;/script&gt;结果： 1.4.5 图片扭曲效果图中的扭曲变形效果需要通过多种变形组合来实现： 先实现两个倾斜的变形，然后利用clip函数江图片的一部分绘制出来： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&apos;myCanvas&apos;); var ctx=c.getContext(&apos;2d&apos;); var img = new Image(); img.src=&quot;face.jpg&quot;; img.onload = function(){ ctx.save(); /*左半边图的绘制：以三个点为顶点绘制一个三角形，然后利用clip函数将这个三角形作为绘图的可视区域*/ /*以三个点为顶点绘制一个三角形*/ ctx.beginPath(); ctx.moveTo(80,0); ctx.lineTo(320,40); ctx.lineTo(0,200); ctx.closePath(); ctx.clip(); /*以刚才三角形的三个顶点来进行倾斜变形*/ ctx.setTransform((320-80)/240,40/240,-80/240,200/240,80,0); /*绘制图片：因为绘图的区域是一个三角形，所以绘制完的图片只有一部分*/ ctx.drawImage(img,0,0); ctx.restore(); ctx.save(); /*右半边图的绘制，方法一样*/ ctx.beginPath(); ctx.moveTo(320,40); ctx.lineTo(0,200); ctx.lineTo(200,150); ctx.closePath(); ctx.clip(); ctx.setTransform(200/240,(150-200)/240,(200-320)/240,(150-40)/240,0,200); ctx.drawImage(img,0,0-240); ctx.restore(); }; &lt;/script&gt;二、图形的渲染2.1 绘制颜色渐变效果的图形颜色的渐变分为线性渐变和径向渐变 2.1.1 线性渐变使用 createLinearGradient 函数和 addColorStop 函数可以实现线性渐变功能： createLinearGradient(x1,y1,x2,y2) 其中的 4 个参数分别是渐变的出发点坐标 (x1，y1) 与终点坐标 (x2，y2)。 addColorStop (position,color)其中，position 参数必须是一个 0.0 到 1.0 之间的数值，表示渐变中颜色地点的相对地位；color 参数表示渐变的颜色。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var grd=ctx.createLinearGradient(0,0,200,0); grd.addColorStop(0.2,&quot;#00ff00&quot;); grd.addColorStop(0.8,&quot;#ff0000&quot;); ctx.fillStyle=grd; ctx.fillRect(0,0,200,100); &lt;/script&gt; 2.1.1 径向渐变使用 createRadialGradient 函数和 addColorStop 函数可以实现径向渐变功能。 createRadialGradient (x0,y0,r0,x1,y1,r1) 其中，参数 x0、y0 为开始圆的圆心坐标，r0 为开始圆的直径 ；x1、y1 为结束圆的圆心坐标，r1 为结束圆的直径。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var grd=ctx.createRadialGradient(100,100,10,100,100,50); grd.addColorStop(0,&quot;#00ff00&quot;); grd.addColorStop(1,&quot;#ff0000&quot;); ctx.fillStyle=grd; ctx.fillRect(0,0,200,200); &lt;/script&gt; 2.2 颜色合成globalCompositeOperation 属性说明了绘制到画布上的颜色是如何与画布上已有的颜色组合起来的。 使用代码： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle=&quot;#00ff00&quot;; ctx.fillRect(10,10,50,50); ctx.globalCompositeOperation=&quot;source-over&quot;; ctx.beginPath(); ctx.fillStyle=&quot;#ff0000&quot;; ctx.arc(50,50,30,0,2*Math.PI); ctx.fill(); &lt;/script&gt;下面列出了其中可能要设置的值以及它们的含义。 注： source 一词指的是将要绘制到画布上的颜色 destination 指的是画布上已经存在的颜色 默认值是source-over copy ：只绘制新图形，删除其他所有内容。 darker ：在图形重叠的地方，其颜色由两个颜色值相减后决定。 destination-atop ：画布上已有的内容只会在它和新图形重叠的地方保留。新图形绘制于内容之后。 destination-in ：在新图形及画布上已有图形重叠的地方，画布上已有内容都保留。所 有其他内容均为透明的。 destination-out ：在画布上已有内容和新图形不重叠的地方，已有内容保留。所有其他 内容均为透明的。 destination-over ：新图形绘制于画布上已有内容的后面。 lighter ：在图形重叠的地方，其颜色由两种颜色值的加值来决定。 source-atop ：只有在新图形和画布上已有内容重叠的地方才绘制新图形。 source-in ：在新图形以及画布上已有内容重叠的地方才绘制新图形。所有其他内容均为透明的。 ource-out ：只有在和画布上已有图形不重叠的地方才绘制新图形。 source-over ：新图形绘制于画布上已有图形的顶部。这是默认的设置。 xor ：在重叠和正常绘制的其他地方，图形都成为透明的。 2.3 颜色反转所谓颜色反转，就是对图形的每个像素进行颜色取反 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,0,0); var imgdata = ctx.getImageData(0,0,250,250); var pixels = imgdata.data; // 遍历每个像素并对 RGB 值进行取反 for (var i=0, n=pixels.length; i&lt;n; i+= 4){ pixels[i] = 255-pixels[i]; pixels[i+1] = 255-pixels[i+1]; pixels[i+2] = 255-pixels[i+2]; } // 在指定位置进行像素重绘 ctx.putImageData(imgdata, 250, 0); }; &lt;/script&gt; 2.4 灰度控制&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,0,0); var imgdata = ctx.getImageData(0,0,250,250); var pixels = imgdata.data; // 遍历每个像素并对 RGB 值进行取反 for (var i=0, n=pixels.length; i&lt;n; i+= 4){ var grayscale = pixels[i]*.3+pixels[i+1]*.59+pixels[i+2]*.11; pixels[i ] = grayscale; // red pixels[i+1] = grayscale; // green pixels[i+2] = grayscale; // blue } // 在指定位置进行像素重绘 ctx.putImageData(imgdata, 250, 0); }; &lt;/script&gt; 2.5 阴影效果Canvas API 中包含了自动为你所绘制的任何图形添加下拉阴影的属性。 阴影的颜色可用shadowColor 属性来指定，并且可以通过 shadowOffsetX 和 hadowOffsetY 属性来改变。 另外，应用到阴影边缘的羽化量也可以使用 shadowBlur 属性来设置。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); /*设定阴影颜色为红色*/ ctx.shadowColor=&quot;#ff0000&quot;; /*设定羽化程度为10*/ ctx.shadowBlur=10; /*指定阴影的水平偏移量和垂直偏移量*/ ctx.shadowOffsetX=20; ctx.shadowOffsetY=30; var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,0,0); }; &lt;/script&gt;三、致谢本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第三章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 本章内容将会在下一篇进行一个实战，制作一个简单的自定义画板。 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"HTML5-Canvas的基本功能","slug":"HTML5-Canvas的基本功能","date":"2019-08-16T05:36:25.000Z","updated":"2019-08-16T09:29:25.029Z","comments":true,"path":"2019/08/16/HTML5-Canvas的基本功能/","link":"","permalink":"http://yoursite.com/2019/08/16/HTML5-Canvas的基本功能/","excerpt":"利用 Canvas 的 API，展示一些基本图形的绘制及操作方法，包括画线、画图、文字操作及图片操作等。（内含代码清单）","text":"利用 Canvas 的 API，展示一些基本图形的绘制及操作方法，包括画线、画图、文字操作及图片操作等。（内含代码清单） 一、绘制基本图形1.1 画线简约版： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 10; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); ctx.moveTo(10,10); ctx.lineTo(150,50); ctx.stroke(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;注释版： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;body&gt; /*在HTML中嵌入Canvas标签，如果浏览器不支持Canvas标签，那么浏览器会自动跳过Canvas标签，运行Canvas内部HTML代码*/ &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*获取HTML中的Canvas标签*/ var c=document.getElementById(&quot;myCanvas&quot;); /*返回一个用来绘制环境类型的环境，目前只支持2d环境*/ var ctx=c.getContext(&quot;2d&quot;); /*线宽*/ ctx.lineWidth = 10; /*笔画颜色，这里颜色值可以是英文字母、RGB值、十六进制颜色*/ ctx.strokeStyle = &quot;red&quot;; /*线帽有三种，分别是butt、round、square butt:默认。向线条的每个末端添加平直的边缘。 round:向线条的每个末端添加圆形线帽。 square:向线条的每个末端添加正方形线帽。*/ ctx.lineCup=&quot;butt&quot;; /*创建一个新路径*/ ctx.beginPath(); /*画笔光标起始位置*/ ctx.moveTo(10,10); /*画笔光标终止位置*/ ctx.lineTo(150,50); /*开始绘制定义好的路径*/ ctx.stroke(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;1.2 画矩形空心矩形： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 10; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ ctx.strokeRect(10,10,70,40); &lt;/script&gt;注：ctx.strokeRect(10,10,70,40);等价于ctx.rect(10,10,70,40);ctx.stroke(); 实心矩形： /*使用fillRect函数*/ &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;red&quot;; ctx.beginPath(); /*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ ctx.fillRect(10,10,70,40); &lt;/script&gt;注：ctx.fillRect(10,10,70,40);等价于ctx.rect(10,10,70,40);ctx.fill(); 1.3 画圆圆其实就是360度的圆弧。在Canvas中，可使用arc函数来画一个圆弧。 空心圆： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 5; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用arc函数绘制圆弧，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ ctx.arc(100,100,70,0,360*Math.PI/180,true); ctx.stroke(); &lt;/script&gt;实心圆： /*使用fill函数*/ &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.lineWidth = 5; ctx.strokeStyle = &quot;red&quot;; ctx.beginPath(); /*用arc函数绘制矩形，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ ctx.arc(100,100,70,0,360*Math.PI/180,true); ctx.fill(); &lt;/script&gt;1.4 圆角矩形Canvas中没有直接画圆角矩形的API，但是我么可以用arcTo函数完成圆角的绘制，然后结合直线绘制，就可以完成圆角矩形的绘制了。 绘制一个圆角： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(70,20); /*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ ctx.arcTo(120,30,120,70,50); ctx.lineTo(120,120); ctx.stroke(); &lt;/script&gt;绘制圆角矩形： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(40,20); ctx.lineTo(100,20); /*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ ctx.arcTo(120,20,120,40,20); ctx.lineTo(120,70); ctx.arcTo(120,90,100,90,20); ctx.lineTo(40,90); ctx.arcTo(20，90，20，70，20); ctx.lineTo(20，40); ctx.arcTo(20，20，40，20，20); ctx.stroke(); &lt;/script&gt;1.5 擦除Canvas画板使用clearRect函数擦除一个矩形区域。他需要4个参数：起点坐标x、坐标y、擦除区域的长和宽。 绘制一个红色实心矩形，再擦除一个50*50的小矩形： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt; 你的浏览器不支持 HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;red&quot;; ctx.beginPath(); ctx.fillRect(10,10,200,100); ctx.clearRect(30,30,50,50); ctx.stroke(); &lt;/script&gt;二、绘制复杂图形2.1 画曲线二次贝塞尔曲线： 二次贝塞尔曲线有一个控制点，再Canvas中用quadraticCurveTo(cpx,cpy,x,y)函数绘制。cpx,cpy表示控制点的坐标，x，y表示终点坐标。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(100,100); ctx.quadraticCurveTo(20,50,200,20); ctx.stroke(); &lt;/script&gt; 三次贝塞尔曲线： 二次、三次贝塞尔曲线的区别在于三次的有两个控制点。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(68，130); var cX1 = 20; var cY1 = 10; var cX2 = 268; var cY2 = 10; var endX = 268; var endY = 170; ctx.bezierCurveTo(cX1,cY1,cX2,cY2,endC,endY); ctx.stroke(); &lt;/script&gt;2.2 利用clip在指定区域绘图clip函数使用当前路径作为绘制操作的剪辑区域。可以理解为窗户，不论绘制了多大的图形，最后看到的图像只能由clip这扇窗来决定。 先画圆，使用clip，再画矩形，最后只能看到圆 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.arc(100,100,40,0,360*Math.PI/180,true); ctx.clip(); ctx.beginPath(); //设定颜色 ctx.fillStyle=&quot;lightblue&quot;; //绘制矩形 ctx.fillRect(0,0,300,150); &lt;/script&gt;2.3 绘制自定义图形结合各种方法，绘制特殊图形，例如： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(100, 150); ctx.bezierCurveTo(50, 100, 100, 0, 150, 50); ctx.bezierCurveTo(200, 0, 250, 100, 200, 150); ctx.bezierCurveTo(250, 200, 200, 300, 150, 250); ctx.bezierCurveTo( 100, 300, 50, 200,100, 150); ctx.closePath(); ctx.moveTo(100, 150); ctx.lineTo(150, 50); ctx.lineTo(200, 150); ctx.lineTo(150, 250); ctx.lineTo(100, 150); ctx.lineWidth = 5; ctx.strokeStyle = &quot;#ff0000&quot;; ctx.stroke(); &lt;/script&gt; 三、绘制文本3.1 绘制文字使用fillText绘制实心文字 fillText(text,x,y,max Width)函数，4各参数分别是：文本字符串、坐标x、坐标y、文本宽度。其中文本宽度可以省略，当其省略时，文本宽度会自动定为整个文本的宽度。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); //设定文字大小和字体 ctx.font=&quot;30px Arial&quot;; //描画文字 ctx.fillText(&quot;Hello World&quot;,100,50); //或添加文本宽度参数： //ctx.fillText(&quot;Hello World&quot;,100,50,50); &lt;/script&gt;使用strokeText绘制空心文字：strokeText与fillText用法相同，只是fillText为实心文字，strokeText为空心文字 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); //设定文字大小和字体 ctx.font=&quot;30px Arial&quot;; //描画文字 ctx.strokeText(&quot;Hello World&quot;,100,50); &lt;/script&gt;3.2 文字设置3.2.1 文字大小使用font参数：例如：ctx.font=”50px Arial”; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定文字大小为30px ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,50); ctx.beginPath(); //设定文字大小为50px ctx.font=&quot;50px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,150); ctx.beginPath(); //设定文字大小为100px ctx.font=&quot;70px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,100,250); &lt;/script&gt;3.2.2 文字字体&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定文字字体为Arial ctx.font=&quot;30px Arial&quot;; ctx.fillText(&quot;Hello World (Arial)&quot;,50,50); ctx.beginPath(); //设定文字字体为Verdana ctx.font=&quot;30px Verdana&quot;; ctx.fillText(&quot;Hello World (Verdana)&quot;,50,100); ctx.beginPath(); //设定文字字体为Times New Roman ctx.font=&quot;30px Times New Roman&quot;; ctx.fillText(&quot;Hello World (Times New Roman)&quot;,50,150); ctx.beginPath(); //设定文字字体为Courier New ctx.font=&quot;30px Courier New&quot;; ctx.fillText(&quot;Hello World (Courier New)&quot;,50,200); ctx.beginPath(); //设定文字字体为serif ctx.font=&quot;30px serif&quot;; ctx.fillText(&quot;Hello World (serif)&quot;,50,250); ctx.beginPath(); //设定文字字体为sans-serif ctx.font=&quot;30px sans-serif&quot;; ctx.fillText(&quot;Hello World (sans-serif)&quot;,50,300); &lt;/script&gt; 3.2.3 文字粗体效果&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定font-weight为normal ctx.font=&apos;normal 30px Arial&apos;; ctx.fillText(&quot;Hello World (normal)&quot;,50,50); ctx.beginPath(); //设定font-weight为bold ctx.font=&apos;bold 30px Arial&apos;; ctx.fillText(&quot;Hello World (bold)&quot;,50,90); ctx.beginPath(); //设定font-weight为bolder ctx.font=&apos;bolder 30px Arial&apos;; ctx.fillText(&quot;Hello World (bolder)&quot;,50,130); ctx.beginPath(); //设定font-weight为lighter ctx.font=&apos;lighter 30px Arial&apos;; ctx.fillText(&quot;Hello World (lighter)&quot;,50,170); ctx.beginPath(); //设定font-weight为100 ctx.font=&apos;100 30px Arial&apos;; ctx.fillText(&quot;Hello World (100)&quot;,50,210); ctx.beginPath(); //设定font-weight为600 ctx.font=&apos;600 30px Arial&apos;; ctx.fillText(&quot;Hello World (600)&quot;,50,250); ctx.beginPath(); //设定font-weight为900 ctx.font=&apos;900 30px Arial&apos;; ctx.fillText(&quot;Hello World (900)&quot;,50,290); &lt;/script&gt; 3.2.4 文字斜体效果&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.beginPath(); //设定font-weight为normal ctx.font=&apos;normal 30px Arial&apos;; ctx.fillText(&quot;Hello World (normal)&quot;,50,50); ctx.beginPath(); //设定font-style为italic ctx.font=&apos;italic 30px Arial&apos;; ctx.fillText(&quot;Hello World (italic)&quot;,50,90); ctx.beginPath(); //设定font-style为oblique ctx.font=&apos;oblique 30px Arial&apos;; ctx.fillText(&quot;Hello World (oblique)&quot;,50,130); &lt;/script&gt;3.3 文字的对齐效果3.3.1 水平对齐&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(160,0); ctx.lineTo(160,300); ctx.stroke(); ctx.beginPath(); ctx.textAlign=&apos;start&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,50); ctx.beginPath(); ctx.textAlign=&apos;end&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,100); ctx.beginPath(); ctx.textAlign=&apos;left&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,150); ctx.beginPath(); ctx.textAlign=&apos;center&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,200); ctx.beginPath(); ctx.textAlign=&apos;right&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&quot;Hello World&quot;,160,250); &lt;/script&gt; 3.3.2 竖直对齐&lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&apos;myCanvas&apos;); var ctx=c.getContext(&apos;2d&apos;); ctx.textBaseline=&apos;alphabetic&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,50); ctx.moveTo(0,50); ctx.lineTo(250,50); ctx.stroke(); ctx.textBaseline=&apos;bottom&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,100); ctx.moveTo(0,100); ctx.lineTo(250,100); ctx.stroke(); ctx.textBaseline=&apos;hanging&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,150); ctx.moveTo(0,150); ctx.lineTo(250,150); ctx.stroke(); ctx.textBaseline=&apos;ideographic&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,200); ctx.moveTo(0,200); ctx.lineTo(250,200); ctx.stroke(); ctx.textBaseline=&apos;middle&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,250); ctx.moveTo(0,250); ctx.lineTo(250,250); ctx.stroke(); ctx.textBaseline=&apos;top&apos;; ctx.font=&apos;30px Arial&apos;; ctx.fillText(&apos;Hello World&apos;,50,300); ctx.moveTo(0,300); ctx.lineTo(250,300); ctx.stroke(); &lt;/script&gt; 四、图片操作4.1 利用drawImage绘制图片drawImage函数有3种函数原型，语法如下： drawImages（image，dx, dy）;drawImages（image，dx, dy, dw, dh）;drawImages（image，sx, sy, sw, sh, dx, dy, dw, dh）; image是要绘制的对象，可以说HTMLImageRlement、HTML-CanvasElement或者HTMLVideoElement dx、dy是image在Canvas中定位的坐标值 dw、dh表示image在Canvas中即将绘制区域（相对dx、dy坐标的偏移量）的宽度与高度值 sx、sy是image所要绘制的起始位置 sw、sh表示image所要绘制区域（相对sw、sy坐标的偏移量）的宽度与高度值 方式1：在Canvas中通过标签的id取得图片数据 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; img标签&lt;br /&gt; &lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt; canvas画板&lt;br /&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt; 你的浏览器不支持HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var img=document.getElementById(&quot;face&quot;); img.onload = function(){ ctx.drawImage(img,10,10); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;步骤1：在html中加入标签 &lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt; 步骤2：在Canvas中通过标签的id取得图片数据 var img=document.getElementById(&quot;face&quot;); 步骤3：用drawImage函数江图片绘制到画板上 ctx.drawImage(img,10,10); 方式2：在Canvas中通过 JavaScript 的 Image 对象来获取数据（个人推荐这种） &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt; 你的浏览器不支持HTML5 &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;步骤1：建立image对象 var image = new Image(); 步骤2：通过设置scr属性，载入图片 image.src = &quot;face.jpg&quot;; 步骤3：添加onload事件侦听，当图片载入完成时，将其绘制到画板 image.onload = function(){ ctx.drawImage(image,10,10); }; drawImage函数的3种函数原型的用法与区别： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ /*从坐标（10，10）开始绘制整张图片*/ ctx.drawImage(image,10,10); /*从坐标（260，10）开始绘制整张图片到长100、宽100的矩形区域内*/ ctx.drawImage(image,260,10,100,100); /*截取图片从（50，50）到（100，100）的部分，从坐标（260，130开始绘制，放大长100，宽100的矩形区域内）*/ ctx.drawImage(image,50,50,100,100,260,130,100,100); }; &lt;/script&gt; 4.2 利用getImageData和putImageData绘制图片（不推荐）putImageData（imagedata，dx, dy, sx, sy, sw, sh） imagedata为像素数据 dx、dy是绘制图片的定位坐标值 sx、sy是imagedata所要绘制图片的起始位置 sw、sh表示imagedata所要绘制区域（相对imagedata的sx、sy坐标的偏移量）的宽度与高度值 这里第四个参数及以后的所有参数都可以省略，如果省略则表示绘制整个imagedata。 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); var imgData=ctx.getImageData(50,50,200,200); ctx.putImageData(imgData,10,260); ctx.putImageData(imgData,200,260,50,50,100,100); }; &lt;/script&gt;步骤1：图片数据读取完成后，首先江图片数据绘制到Canvas画板上 ctx.drawImage(image,10,10); 步骤2：用getImageData函数从画板上取得像素数据 var imgData=ctx.getImageData(50,50,200,200); 步骤3：将取得的整个像素数据绘制到画板上 ctx.putImageData(imgData,10,260); 或将取得的整个像素数据的一部分绘制到画板上 ctx.putImageData(imgData,200,260,50,50,100,100); 注意：这种方法种使用了getImageData函数获取图片数据，这个函数在Google Chrome等浏览器中会涉及跨域问题，所以无法直接在浏览器种浏览。必须通过服务器来访问。当然，我么可以在本地服务器是浏览。 4.3 利用createImageData新建像素createImageData函数有两种函数原型： 返回指定大小的imageData对象： createImageData（sw, sh）; 返回与指定对象相同大小的imageData对象 createImageData(imageData); 注意：通过createImageData返回的是一个空的imageData对象，必须要针对起像素进行复制才能显示到Canvas 画板上 &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;face.jpg&quot;; image.onload = function(){ ctx.drawImage(image,10,10); var imgData=ctx.getImageData(50,50,200,200); var imgData01=ctx.createImageData(imgData); for (i=0; i&lt;imgData01.width*imgData01.height*4;i+=4){ imgData01.data[i+0]=255; imgData01.data[i+1]=0; imgData01.data[i+2]=0; imgData01.data[i+3]=255; } ctx.putImageData(imgData01,10,260); var imgData02=ctx.createImageData(100,100); for (i=0; i&lt;imgData02.width*imgData02.height*4;i+=4){ imgData02.data[i+0]=255; imgData02.data[i+1]=0; imgData02.data[i+2]=0; imgData02.data[i+3]=155; } ctx.putImageData(imgData02,220,260); }; &lt;/script&gt;代码解析： 图片数据读取完成后，首先将图片数据绘制到 Canvas 画板上。 ctx.drawImage(image,10,10); 用 getImageData 函数从画板上取得像素数据。 var imgData=ctx.getImageData(50,50,200,200); 使用 createImageData 返回与 imgData 相同大小的 ImageData 对象。 var imgData01=ctx.createImageData(imgData); imgData01 进行赋值。 for (i=0; i&lt;imgData01.widthimgData01.height4;i+=4){ imgData01.data[i+0]=255; imgData01.data[i+1]=0; imgData01.data[i+2]=0; imgData01.data[i+3]=255; } 利用 putImageData 将 imgData01 画到 Canvas 画板上。 ctx.putImageData(imgData01,10,260); 使用 createImageData 返回一个大小为 100×100 的 ImageData 对象。 var imgData02=ctx.createImageData(100,100); 对 imgData02 进行赋值。 for (i=0; i&lt;imgData02.widthimgData02.height4;i+=4){ imgData02.data[i+0]=255; imgData02.data[i+1]=0; imgData02.data[i+2]=0; imgData02.data[i+3]=155; } 利用 putImageData 将 imgData02 画到 Canvas 画板上。 ctx.putImageData(imgData02,220,260); 五、致谢写这篇学习总结的时候是学校开学的前夕，实验室还没有人。早上我给自己泡了一杯茶，累了就去弹两首古琴曲子然后继续回来学。这篇总结写完的时候，太阳的余辉正撒在我的书桌上。我抬头望着窗外的云朵，好像忽然懂了《时光恋旅人》里主角父亲穿越时空一遍遍看书的感受了，哈哈哈，在时空隧道里，想来我一个人也可以相处的很愉快吧。 本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第二章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"HTML5-Canvas","slug":"HTML5-Canvas","permalink":"http://yoursite.com/tags/HTML5-Canvas/"}]},{"title":"JavaScript中的面向对象","slug":"JavaScript中的面向对象","date":"2019-08-16T03:25:03.000Z","updated":"2019-08-16T05:08:22.454Z","comments":true,"path":"2019/08/16/JavaScript中的面向对象/","link":"","permalink":"http://yoursite.com/2019/08/16/JavaScript中的面向对象/","excerpt":"可以说，JavaScript 是一种基于对象的语言，但是，它又不是一种真正的面向对象的编程语言，因为它的语法中不存在 class（类）。 本节将分析和解决如何在 JavaScript 中实现封装和继承等面向对象的问题。","text":"可以说，JavaScript 是一种基于对象的语言，但是，它又不是一种真正的面向对象的编程语言，因为它的语法中不存在 class（类）。 本节将分析和解决如何在 JavaScript 中实现封装和继承等面向对象的问题。 一、类一个没有任何属性和方法的类的定义： function MyClass(){};其实这就是个简单函数的声明，这个函数就是一个类的定义的实现。 使用这个类： var cls1 = new MyClass();这样，利用 new 就可以生成 MyClass的一个实例了。 所以，在JavaScript中，可以说函数就是类，类就是函数。 一个实例的封装包含属性和方法的封装： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); alert(cls1.name + &quot;:&quot; + cls1.age);//[yf:18]在函数内使用 this 就能给函数本身增加属性值。上面的代码中就给 MyClass 函数增加了 name 和 age 两个属性。 利用this给这个类增加一个toString 方法： 方式1： function MyClass(name,age){ this.name = name; this.age = age; this.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString();//[yf:18]方式2（这种方式只是给 cls1 这个实例增加了方法，并未给 MyClass 本身增加方法。）： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; cls1.toString();//[yf:18]比如，使用方式2时下面的代码会出错 ： function MyClass(name,age){ this.name = name; this.age = age; }; var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString() = function(){ alert(this.name + &quot;:&quot; + this.age); }; cls1.toString();//[yf:18] var cls2 = new MyClass(&quot;cx&quot;,19); cls2.toString();// 报错使用函数的prototype对象来添加方法： 每一个函数都会包含一个 prototype 属性，这个属性指向了一个 prototype 对象，我们可以指定函数对应的 prototype 对象。如果不指定，则函数的 prototype 属性将指向一个默认的 prototype 对象，并且此默认 prototype 对象的 constructor 属性又会指向该函数。 当用构造函数创建一个新的对象时，新的对象会获取构造函数的 prototype 属性所指向的 prototype 对象的所有属性和方法，这样一来，构造函数对应的 prototype 对象所做的任何操作都会反映到它所生成的对象上，所有的这些对象将共享与构造函数对应的 prototype 对象的属性和方法。 虽然新创建的对象可以使用它的构造函数所指向的 prototype 对象的属性和方法，但不能像构造函数那样直接调用 prototype 对象（对象没有 prototype 属性）。 简而言之，如果我么使用函数的prototype对象来给函数添加方法，那么创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这个函数的所有方法。 具体代码： function MyClass(name,age){ this.name = name; this.age = age; } MyClass.prototype.toString = function(){ alert(this.name + &quot;:&quot; + thus.age); } var cls1 = new MyClass(&quot;yf&quot;,18); clas1.toString();//[yf:18] var cls2 = new MyClass(&quot;cx&quot;,19); clas2.toString();//[cx:19]对于prototype对象来说，由于存在的是指向的关系，所以避免了不必要的浪费。 如果要加入多个方法，可以用下面的方式实现封装： function MyClass(name,age){ this.name = name; this.age = age; } MyClass.prototype = { toString:function(){ alert(this.name + &quot;:&quot; + thus.age); }; sayHello:function(){ alert(this.name + &quot;,你好!&quot;); }; } var cls1 = new MyClass(&quot;yf&quot;,18); cls1.toString();//[yf:18] cls1.sayHellow ();//[yf, 你好!]二、静态类其实，下面的函数本身就可以当作静态类来用 ： var StaticClass = function(){}; StaticClass.name = &quot;StaticName&quot;; StaticClass.Sum = function(value1,value2){ return value1 + value2; }; alert(StaticClass.name);//[StaticName] alert(StaticClass.Sum(1,3));//[4]这样，在使用静态类的时候，就无须创建新的实例了，可直接用“类名 + 点 + 属性或方法”的方式。 三、继承上面只讲了类的封装，那么如何实现类的继承呢？如有如下两个构造函数 ： function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ this.name = name; this.sex = sex; };属性的继承：使用 apply 方法将父对象的构造函数绑定在子对象上 function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ PeopleClass.apply(this, arguments); this.name = name; this.sex = sex; }; var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;); alert(stu.type);//[ 人 ]从运行结果来看，StudentClass 继承了 PeopleClass 的属性“人”。 方法的继承：循环使用父对象的 prototype 进行复制 function PeopleClass(){ this.type = &quot; 人 &quot;; }; PeopleClass.prototype = { getType:function(){ alert(&quot; 这是一个人 &quot;); } }; function StudentClass(name,sex){ PeopleClass.apply(this, arguments); var prop; for(prop in PeopleClass.prototype){ var proto = this.constructor.prototype; if(!proto[prop]){ proto[prop] = PeopleClass.prototype[prop]; } proto[prop][&quot;super&quot;] = PeopleClass.prototype; } this.name = name; this.sex = sex; }; var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;); alert(stu.type);//[ 人 ] stu.getType();//[ 这是一个人 ]三、致谢本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第一章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5的代码清单","slug":"HTML5的代码清单","date":"2019-08-15T11:02:20.000Z","updated":"2019-08-15T11:28:58.887Z","comments":true,"path":"2019/08/15/HTML5的代码清单/","link":"","permalink":"http://yoursite.com/2019/08/15/HTML5的代码清单/","excerpt":"HTML5 有很多令人心动的特性和新功能，这里罗列了一些HTML5新特性的示例代码。包含使用 video 标签播放动画、使用 audio 标签播放音频、使用 Canvas 标签绘制图形、取得当前的位置、将大量的数据保存在客户端、form 的强化","text":"HTML5 有很多令人心动的特性和新功能，这里罗列了一些HTML5新特性的示例代码。包含使用 video 标签播放动画、使用 audio 标签播放音频、使用 Canvas 标签绘制图形、取得当前的位置、将大量的数据保存在客户端、form 的强化 一、HTML5新特性 强化了Web网页的表现性能，增加了本地数据库等 Web 应用的功能，以及图像操作等。 HTML5 在图像上引入了 Canvas 标签，通过 Canvas，用户可以动态生成各种图形图像、图表以及动画，而不再依赖于 Flash、silverlight 等插件了。 HTML5 在地理位置操作上引入了 Geolocation API，其特点在于 ： 本身不去获取用户的位置，而是通过第三方接口来获取，例如 IP、GPS、WIFI 等方式。 用户可以随时开启和关闭，在被程序调用时也会首先征得用户同意，保证了用户的隐私。 HTML5 还在数据储存上增加了本地数据库，可以使用 WebSQL 来储存数据，并且引入了 web storage API 实现了离线缓存功能，以此替代了 cookies，使得数据保存空间更大、更安全。 二、HTML5新特性代码清单2.1 使用 video 标签播放动画/*这段代码可以实现播放动画功能*/ &lt;video width=&quot;640&quot; height=&quot;360&quot; preload=&quot;auto&quot; poster=&quot;hoge.png&quot; controls autoplay&gt; &lt;!-- 针对播放 webm 格式动画的浏览器 --&gt; &lt;source src=&quot;hoge.webm&quot; type=&apos;video/webm; codecs=&quot;vp8, vorbis&quot;&apos;&gt; &lt;!-- 针对播放 ogv 格式动画的浏览器 -&gt; &lt;source src=&quot;hoge.ogv&quot; type=&apos;video/ogg; codecs=&quot;theora, vorbis&quot;&apos;&gt; &lt;!-- 针对播放 mp4 格式动画的浏览器 --&gt; &lt;source src=&quot;hoge.mp4&quot; type=&apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt; &lt;!-- 当浏览器无法使用 video 标签的时候 --&gt; &lt;p&gt; 无法播放动画。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt; &lt;/video&gt;2.2 使用 audio 标签播放音频/*这段代码可以实现音频播放功能*/ &lt;audio controls loop&gt; &lt;!-- 针对播放 ogg 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.ogg&quot;&gt; &lt;!-- 针对播放 wav 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.wav&quot;&gt; &lt;!-- 针对播放 mp3 格式音频的浏览器 --&gt; &lt;source src=&quot;hoge.mp3&quot;&gt; &lt;!-- 当浏览器无法使用 audio 标签的时候 --&gt; &lt;p&gt; 无法播放音频。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt; &lt;/audio&gt;2.3 使用 Canvas 标签绘制图形使用 Canvas 标签，只需要向 HTML5 里添加 Canvas 元素即可，代码如下 ： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;另外，Canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript内部完成。使用案例如下： 案例一： /*这段代码可以绘制一个矩形*/ &lt;canvas id=&quot;canvas&quot; width=&quot;640&quot; height=&quot;360&quot;&gt;&lt;/canvas&gt; &lt;script&gt; // 获取 context 对象 var canvas = document.getElementById(&apos;canvas&apos;); if(canvas.getContext){ var context = canvas.getContext(&apos;2d&apos;); // 设置颜色 context.fillStyle = &apos;rgb(255,0,0)&apos;; // 从坐标 (20,30) 开始，画一个 64×36 大小的矩形 context.fillRect(20,30,64,36); } &lt;/script&gt;案例二: /*这段代码可以须在 JavaScript 内部实现绘制一个矩形*/ onload = function() { draw(); }; function draw() { /* 使用 id 来寻找 Canvas 元素 */ var canvas = document.getElementById(&apos;canvassample&apos;); /* 验证 Canvas 元素是否存在，以及浏览器是否支持 Canvas 元素 */ if ( ! canvas || ! canvas.getContext ) return false; /* 创建 context 对象 */ var ctx = canvas.getContext(&apos;2d&apos;); /* 画一个红色矩形 */ cxt.fillStyle=&quot;#FF0000&quot;; cxt.fillRect(0,0,150,75); }2.4 轻松取得当前的位置/*这段代码可以获取当前位置的纬度和经度*/ &lt;script&gt; window.addEventListener(&apos;load&apos;. function () { // 判断可否使用 geolocation if(navigator.geolocation){ // 定期获取所在地 navigator.geolocation.watchPosition(update); } }, false); // 取得位置并表示 function update(position){ // 纬度 var lat = position.coords.latitude; // 经度 var lng = position.coords.longitude; // 把纬度和经度显示出来 document.write(&apos; 纬度 ：&apos;+lat+&apos;，经度 ：&apos;+lng); } &lt;/script&gt;2.5 将大量的数据保存在客户端/*这段代码中的 JavaScript 使用 LocalStorage 来保存大量的数据*/ &lt;script&gt; // 用 localStorage 来保存数据 localStorage.key = &apos; 想要保存的值 &apos;; // 将 localStorage 中的值取出来 var hoge = localStorage.key; //“想要保存的值”在页面上显示 document.write(hoge); &lt;/script&gt;2.6 form 的强化/*这段代码是form 的几个比较常用的功能*/ &lt;!-- 验证用户输入格式是否正确，只需要改变 type 的类型即可 --&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot;&gt; &lt;!-- 对于必须输入的项目，只需给 input 标签加上 require 属性即可 --&gt; &lt;input name=&quot;text&quot; type=&quot;text&quot; require&gt; &lt;!-- 当失去焦点的时候给出相应的提示，只需给 input 标签加上 placeholder 属性即可 --&gt; &lt;input name=&quot;text&quot; type=&quot;text&quot; placeholder=&quot; 例 ：姓名 &quot;&gt;","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"盒尺寸四大家族之margin与border","slug":"盒尺寸四大家族之margin与border","date":"2019-08-15T04:14:50.000Z","updated":"2019-08-15T11:30:04.083Z","comments":true,"path":"2019/08/15/盒尺寸四大家族之margin与border/","link":"","permalink":"http://yoursite.com/2019/08/15/盒尺寸四大家族之margin与border/","excerpt":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！","text":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！ 一、激进的margin属性 1.1 margin与元素尺寸以及相关布局这里的各类“尺寸”命名和对应的盒子类型全部参考自 jQuery 中与尺寸相关 API 的名称。 元素尺寸：对应 jQuery 中的$().width()和$().height()方法，包括 padding和 border，也就是元素的 border box 的尺寸。在原生的 DOM API 中写作 offsetWidth和 offsetHeight，所以，有时候也成为“元素偏移尺寸”。 元素内部尺寸：对应 jQuery 中的$().innerWidth()和$().innerHeight()方法，表示元素的内部区域尺寸，包括 padding 但不包括 border，也就是元素的 paddingbox 的尺寸。在原生的 DOM API 中写作 clientWidth 和 clientHeight，所以，有时候也称为“元素可视尺寸”。 元素外部尺寸：对应 jQuery 中的$().outerWidth(true)和$().outerHeight(true)方法，表示元素的外部尺寸，不仅包括 padding 和 border，还包括 margin，也就是元素的 margin box 的尺寸。没有相对应的原生的 DOM API。 注意：“外部尺寸”有个很不一样的特性，就是尺寸的大小有可能是负数 1.2 margin的百分比值1.3 正确看待CSS世界里的margin合并1.4 深入理解CSS中的margin：auto1.5 margin无效情形解析二、border属性2.1 为什么border-width不支持百分比值2.2 了解各种border-style类型2.3 border-color和color2.4 border与透明边框技巧2.5 border与图形构建2.6 border等高布局技术","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"盒尺寸四大家族之content与padding","slug":"盒尺寸四大家族","date":"2019-08-13T08:16:12.000Z","updated":"2019-08-14T09:30:30.001Z","comments":true,"path":"2019/08/13/盒尺寸四大家族/","link":"","permalink":"http://yoursite.com/2019/08/13/盒尺寸四大家族/","excerpt":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！","text":"盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！ 一、深入理解content 1.1 content与替换元素1.1.1 替换元素 替换元素：通过修改某个属性值呈现的内容就可以被替换的元素。 典型例子：&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;、表单元素&lt;textarea&gt;、&lt;input&gt;、 替换元素特点： 内容外观不受页面上的CSS影响 有自己的尺寸 在很多CSS属性上有自己的一套变现规则（例如vertical-align属性） 1.1.2 替换元素的默认dispaly值 用途：显示替换元素时候可以设置style.display=’inline’而无需style.display=’inline-block’。 1.1.3 替换元素的计算尺寸 替换元素的尺寸从内到外：固有尺寸、HTML尺寸、CSS尺寸 固有尺寸：固定大小，例如&lt;input&gt;:，此时的尺寸即为固有尺寸，使用px为单位。 HTML尺寸：只能通过HTML原生属性改变。如&lt;img width=&quot;300&quot; height=&quot;100&quot;&gt;: CSS尺寸：通过CSS设置的width和height或者max-width/min-width和max-height/min-height设置的尺寸对应盒尺寸的content box 应用：Web开发时，为提高加载性能以及节约带宽费用，首屏以下的图片就会通过滚屏加载的形式异步加载，然后，这个即将被异步加载的图片为了布局稳健、体验良好，往往使用一张透明的图片占位。例如 &lt;img scr=&quot;transparent.png&quot;&gt;实际上，这张透明的占位图片也是多余资源，我么直接： &lt;img&gt;然后配合CSS可以实现一样的效果： img { visibility: hidden; display: inline-block; } img[scr] {visibility: vidible; }注意：这里的直接没有scr属性，而是scr=””,scr=””这在很多浏览器下依然会有请求，而且请求的是当前页面数据。当图片的scr属性缺省时，图片不会有任何请求，这是最高效的实现方式。 1.1.4 替换元素与非替换元素观点1：他们之间只隔了一个src属性。应用案例：基于伪元素的图片内容生成技术 观点2：他们之间只隔了一个CSS content属性。应用案例：使用content属性，让普通标签元素变成替换元素；完美的文字换图显示方案 HTML： &lt;img class=&quot;emoji&quot; src=&quot;laugh.png&quot;&gt; CSS： .emoji:hover { content: url(laugh-tear.png); }注意：想要在移动端使用该技术，建议换成SVG矢量图片 1.1.5 content与替换元素关系剖析 在CSS世界，我们把content属性生成的对象称为“匿名替换元素”，content属性生成的内容都是替换元素。 content属性生成的元素和普通元素内容有不同的特性表现： 使用content生成的文本是无法选择复制的 不能左右empty伪类（案例在此） content动态生成值无法获取 其他略 1.2 content内容生成技术实际项目中，content属性大都是用在：：before/：：after这两个伪元素中，所以“content内容生成技术”有时候也称“：：before/：：after伪元素技术” 1.2.1 content辅助元素生成案例content辅助元素与布局 1.2.2 content字符内容生成案例配合@font-face规则实现图标字体效果 案例content换行符与打点loading效果 1.2.3 content图片生成伪元素中的图片更多的是使用background-image模拟，类似： div：before { content：‘’; background： url(1.jpg); }content图片生成并不常用，因为不好控制图片尺寸，所以，只有不需要控制尺寸的图片才有优势。案例content图片生成与新标签页地址标记 1.2.4 content开启闭合图片生成可以针对不同语言指定不同的前后引号。但是这个功能很鸡肋，不如直接使用“”‘’方便。 &lt;p lang=&quot;ch&quot;&gt;&lt;q&gt;中文使用“”&lt;/q&gt;&lt;/p&gt; &lt;p lang=&quot;en&quot;&gt;&lt;q&gt;英文使用&quot;&quot;&lt;/q&gt;&lt;/p&gt; /*为不同的语言指定引号的表现*/ ：lang(ch) &gt; q { quotes: ‘“’ ‘”’；} ：lang(en) &gt; q { quotes: ‘&quot;’ ‘&quot;’；} /*在q标签前后插入引号*/ q:before { content: open-quote;} q:after { content: close-quote;}1.2.5 content atter属性值内容生成这个功能比较实用，案例src缺省时img元素的alt信息展示 1.2.6 深入了解content计数器计数器效果可以说是content部分的重中之重，因为此功能强大、实用、且不具有可替代性，甚至可以实现连JavaScript都实现不好的功能。 CSS计数器就和我们军训报数一样，班级命名、报数规则、开始报数，这三个关键点刚好对应CSS计数器的两个属性和一个方法。 1、属性counter-reset（计数器-重置） 注意：如果不设置，默认起始值为0。 /*确定计数器名称wangxiaoer，起始值2*/ .xxx { counter-reset: wangxiaoer 2;}完整案例： CSS计数器counter-reset值为2 CSS计数器counter-reset两个命名并存 2、属性counter-increment（计数器递增） 注意：如果不设置，默认变化值为1。 /*变化的值为2*/ counter-increament: counter 2 /*变化的值为-1*/ counter-increament: counter -1CSS计数器的技术规则：普照规则 普照规则:普照源（counter-reset）唯一，每普照（counter-increment）一次，普照源增加一次计数值。 案例： CSS计数器counter-reset/counter-increment递增 CSS计数器counter-increment父子连续普照与递增 CSS计数器counter-increment递增机制 3、方法counter（）/counters（） counter（）作用：显示计数、不过方法、用法多个 /*name是counter-reset的名称，style参数选择递增递减方式*/ counter（ name，style）style参数的作用是递增递减英文字母或者罗马文等案例：CSS计数器counter()方法style参数示意 counter支持级联：一个counter属性值可以有多个counter（）方法，案例：CSS计数器多个counter并存 counters（）：嵌套技术的代名词。 /*name是counter-reset的名称，string为字符串*/ counters（ name，string） /*也支持style*/ counters（ name，string, style）string为字符串,表示子序号的连接字符串，如1.1的string就是.,案例：CSS计数器counters的string参数与嵌套 注意：普照源是唯一的。要想实现嵌套，必须让每一个列表容器拥有一个“普照源”，通过子辈对父辈的counter-reset重置、配合counters（）方法才能实现计数嵌套效果。 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的大儿子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的大孙子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的二孙子&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的小孙子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小二的三儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小三&lt;/div&gt; &lt;div class=&quot;counter&quot;&gt;我是王小四 &lt;div class=&quot;reset&quot;&gt; &lt;div class=&quot;counter&quot;&gt;我是王小四的大儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;错误示范：CSS计数器counters的错误示范 注意：这种计数效果在模拟书籍的目录效果时十分实用。这里需要强调的是：显示counter计数值的那个DOM元素在文档流中的位置一定要在counter-increment元素的后面，否则是没有技术效果的。 1.2.4 content内容生成的混合特性各种content内容生成语法是可以混合在一起使用的。 二、温和的padding属性padding性格温和，与人相处友好，在使用padding属性进行页面开发过程中，很少会出现意想不到的情况。 padding指的是盒子的内补间 2.1 padding与元素的尺寸因为CSS中默认的box-sizing是content-box,所以使用padding会增加元素的尺寸。 误区：内联元素的padding只会影响水平方向，不会影响垂直方向。这是错误的！ 正解：内联元素padding对视觉层和布局层具有双重影响。案例：内联元素垂直padding也有作用 应用： 利用padding的常规应用：在不影响当前布局的情况下，优雅的增加链接或按钮的点击区域大小。如 `article a { padding: .25em 0; }` 利用内联元素padding特性的应用：内联元素padding与高度可控的分隔线 标题下方留出一定位置： 源代码： &lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt; h3{ line-height: 30px; font-size: 14px; }现在： &lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt; h3{ line-height: 30px; font-size: 14px; h3 &gt; span { padding-top: 58px; }2.2 padding的百分比值 与margin属性不同，padding不支持负值 padding支持百分比值，且padding百分比值无论是水平方向还是竖直方向均是相对于宽度计算的。 /一个正方形/ div { padding: 50%; } /一个宽高比2：1的矩形/ div { padding: 25% 50%; } 应用案例：百分比padding值与等比例头图效果 2.3 标签元素内置的padding ol/ul列表内置padding-left，但是单位是px不是em。根据张鑫旭老师的经验，font-size是12-14px时，22px是一个比较好的padding-left设定值，所有浏览器都能正常显示，且非常贴近边缘。 ol,ul { padding-left:22px; } 很多表单都内置padding 案例：button 与 label 配合使用，使得即语义良好行为保留又UI效果好。 &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;label for=&quot;but&quot;&gt;按钮&lt;/label&gt; button{ position: absolute; clip: rect(0 0 0 0); } label{ display: inline-block; line-height: 20px; padding: 10px; }2.4 padding与图形绘制padding属性与background-clip属性配合，可以在有限的标签下实现一些CSS图形绘制效果。 案例：三道杠和双层圆点图形生成 三、致谢本文内容我对张鑫旭老师《CSS世界》第四章1、2小节的的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Vis-Class1_可视化释义","slug":"Vis-Class—-one","date":"2019-08-07T09:42:59.000Z","updated":"2019-08-16T10:15:32.470Z","comments":true,"path":"2019/08/07/Vis-Class—-one/","link":"","permalink":"http://yoursite.com/2019/08/07/Vis-Class—-one/","excerpt":"浙江大学2019年可视化与可视分析暑期学校第一课：陈为老师《可视化释义》笔记。","text":"浙江大学2019年可视化与可视分析暑期学校第一课：陈为老师《可视化释义》笔记。 SummerCourse2019ZJU Class 1 Introduction release Wei Chen chenwei@cad.zju.edu.cn OUTLINE 1.1 What is data visualization 1.2 Visualization is hot &amp; cool &amp; young 1.3 How to create visualization? 1、What is data visualization --- 1.1 “Data visualization is the creation and study of the visual representation of data” - wiki Input: data Output: visual form Goal: insight vi·su·al·i·za·tion: Formation of mental visual images The act or process of interpreting in visual terms or of putting into visible form eg:Aaron Koblin, TED 2006 1.2 Why is a Diagram (Sometimes)Worth 10,000 Words Larkin and Simon, Cognitive Science, 1987 图表表达与句型表达具有信息和计算上的等价性 [Simon 1978] 图表具有拓扑和几何的关联，将信息基于位置进行索引，所见处即所得 句型表达具有时间或逻辑方面的序列，显式地表达了单个元素。 句型表达假设每句话是串行阵列；而图表表达有一个简洁的语义网络，认知时只需要在不同的节点间定位。 在求解问题时，图表表达可以提供搜索与认知的便利；句型表达在搜索时需要记住更多的信息。eg:Visu Algo通过动画可视化数据结构和算法 1.3 How to do Helps us think Uses perception to offload cognition Serves as an external aid to augment working memory Boosts our cognitive abilities 2、Visualization is hot & cool & young --- **2.1 Top VIS Conferences** VAST (Visual Analytics Science and Technology) InfoVis (Information Visualization) SciVis (Scientific Visualization) 2.2 What is VIS Research? Visualization Pipeline Technique Papers Application/Design Study Papers System Papers Evaluation Papers Theory/Model papers 2.3 Some of Web Milestones Project 时间线 蚂蚁金服DT时代新布局：可视化神器G2 Baidu EChart 3、How to create visualization? --- 3.1 Act I: Foundations Design Principles Process &amp; Data Tasks &amp; Interaction Perception Visual Encodings Color 3.2 Act II:Methods SingleViews MultipleViews Filtering &amp;Aggregation Dimensionality Reduction Evaluation 3.3 Act III:Techniques Statistical Graphs Trees &amp; Networks Maps Text &amp; Images 3.4How to create a visualization yourself 数据清洗工具OpenRefine（以前称为Google Refine）; 中文教程 数据可视化工具Tableau; 中文教程 统计计算和统计制图的优秀工具:R 在视觉艺术环境中编码的语言:Processing 最流行的可视化库之一:D3 (JS);中文教程 配色方案:ColorBrewer","categories":[],"tags":[{"name":"Vis","slug":"Vis","permalink":"http://yoursite.com/tags/Vis/"}]},{"title":"Git常用操作总结","slug":"Git常用操作总结","date":"2019-08-05T10:07:56.000Z","updated":"2019-08-16T10:15:34.031Z","comments":true,"path":"2019/08/05/Git常用操作总结/","link":"","permalink":"http://yoursite.com/2019/08/05/Git常用操作总结/","excerpt":"Git常用操作总结 - 参考自廖雪峰老师的git教程","text":"Git常用操作总结 - 参考自廖雪峰老师的git教程 一.创建版本库 $ mkdir learngit// 创建文件夹learngit $ cd learngit $ pwd//显示当前路径 ①初始化一个Git仓库： git init//将当前目录变成一个Git可以管理的仓库②添加文件到Git仓库： 1.git add&lt;file&gt; ; 2.git commit $ git add readme.txt // 将文件添加到Git仓库（把文件修改添加到暂存区） $ git add file1.txt // 添加file1.txt文件 $ git add file2.txt file3.txt // 同时添加file2.txt和file3.txt两个文件 $ git commit -m “wrote a readme.txt.” // 将文件提交到仓库（把暂存区的所有内容提交到当前分支） 二.时光机穿梭①查看工作区状态，文件是否被修改过： git status②查看修改的内容： git diff eg:$ git diff readme.txt // 查看工作区的readme.txt与缓存区的readme.txt的区别 1.版本回退①HEAD:当前版本 ②HEAD^:上个版本 ③定位版本：git reset --hard commit_id ④git log：穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本 ⑤git reflog：要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 $ git log // 查看最近到最远的提交记录（详情: commit id + Author + Date + comment） $ git log –pretty=oneline // 查看最近到最远的提交记录（简写：commit id + comment） $ git reset –hard HEAD^ // 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本） $ git reset –hard 1234567 // 回到指定版本号commit id（此处：commit id 假设为1234567**，Git会根据commit id的前几位自动寻找对应的版本） $ cat readme.txt // 查看readme.txt的内容 $ git reflog // 查看每一次命令记录历史，确保能回到任意版本 2.工作区和暂存区①工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区 ②版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 ③暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区。 $ git diff readme.txt // 比较工作区（working directory）和暂存区（stage/index）的区别 $ git diff --cached // 比较暂存区（stage/index）和分支（master）的区别第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 3.管理修改①每次修改，如果不add到暂存区，就不会加入到commit中 4.撤销修改①git checkout -- file：丢弃工作区的修改 ②git reset HEAD file：把暂存区的修改撤销掉，重新放回工作区5.删除文件①git rm：从版本库中删除文件 $ rm test.txt // 删除工作区文件（类似于手动删除） $ git status // 查看当前工作区与缓存区状态 $ git rm test.txt // 情况1：确认删除 $ git commit -m “remove test.txt” // 情况1：确认删除后，提交到版本库 $ git checkout – readme.txt // 情况2：误删，需要回退（即：用版本库里的版本替换工作区的版本） 三.远程仓库1.添加远程库①关联一个远程库： git remote add origin git@server-name:path/repo-name.git// 关联一个远程仓库 eg:git remote add origin git@github.com:yangfff/learngit.git ②关联后第一次推送master分支的所有内容： git push -u origin master③此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 git push -u origin master // 第一次推送master分支的所有内容ps:由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 注：在GitHub上创建新仓库时，如果勾选了README.md选项时，可能会出现下面错误，提示：远程仓库有readme.txt,而本地仓库没有README.txt,此时应该先进行合并文件，再进行推送。 git pull --rebase origin master // 推送之前，进行合并合并文件之后，发现本地仓库中多了README.md文件，此时再进行推送修改到远程仓库就可以了。 再次执行：git push -u origin master, 即可推送本地仓库到远程仓库了查看GitHub上的文件，已经更新！ 2.从远程库克隆①要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆 ②Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 $ git clone git@github.com:yangfff/learngit.git // 以SSH方式克隆 $ git clone https://github.com/yangfff/learngit.git // 以Https协议方式克隆四.分支管理1.创建与合并分支查看分支： git branch 创建分支： git branch&lt;name&gt; 切换分支： git cheakout&lt;name&gt; 创建+切换分支： git cheakout -b &lt;name&gt; 合并某分支到当前分支：git merge&lt;name&gt; 删除分支：git branch - d &lt;name&gt;2.解决冲突①查看分支合并图： git log --graph // 查看分支合并图 git log --graph --pretty=oneline --abbrev-commit // 查看分支合并缩略图3.分支管理策略①合并分支时加–no-ff参数：普通模式合并，合并后的历史有分支，禁用fast forward eg:git log –no-ff-m”merge with no–ff”dev 4.Bug分支git stash // 隐藏分支工作现场，为修复bug准备 git stash list // 查看有哪些分支隐藏的工作现场，为恢复工作现场做准备 git stash apply // 恢复工作现场，但不删除存储的stash内容，结合git stash drop进行删除 git stash drop // 删除存储的stash内容，恢复到隐藏前的工作现场 git stash pop // 恢复到隐藏前的工作现场，相当于git stash apply和git stash drop git stash apply stash@{0} // 可以多次stash，通过git stash list查看所有的stash，然后可以恢复到指定的隐藏的工作现场5.Feature分支①开发一个新feature，最好新建一个分支； ②如果要丢弃一个没有被合并过的分支，可以通过 git branch -D &lt;name&gt;//强行删除6.多人协作①git remote -v：查看远程库信息 ②git push origin branch-name：从本地推送分支 ③git pull：推送失败时，抓取远程的新提交 ④git checkout -b branch-name origin/branch-name：在本地创建和远程分支对应的分支（本地和远程分支的名称最好一致） ⑤git branch –set-upstream branch-name origin/branch-name：建立本地分支和远程分支的关联 五.标签管理1.创建标签①git tag ：新建一个标签（默认为HEAD，也可以指定commit id） ②git tag -a -m “blablabla…”：可以指定标签信息 ③git tag -s -m “blablabla…”：可以用PGP签名信息 ④git tag：查看所有标签 2.操作标签①git push origin ：推送一个本地标签 ②git push origin –tags：推送全部未推送过的本地标签 ③git tag -d ：删除一个本地标签 ④git push origin :refs/tags/：删除一个远程标签 六.使用GitHub①在GitHub上，可以任意Fork开源仓库； ②自己拥有Fork后的仓库的读写权限； ③可以推送pull request给官方仓库来贡献代码。 七.自定义Git1.忽略特殊文件①忽略某些文件时，需要编写.gitignore； 2.配置别名①我们只需要敲一行命令，告诉Git，以后st就表示status： git config --global alias.st status eg: $ git config –global alias.co checkout $ git config –global alias.ci commit $ git config –global alias.br branch $ git config –global alias.unstage ‘reset HEAD’ $ git config –global alias.last ‘log -1’ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 3.搭建Git服务器GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 例如大众点评code.dianpingoa.com","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"流、元素与基本尺寸","slug":"流、元素与基本尺寸","date":"2019-08-01T04:15:46.000Z","updated":"2019-08-13T08:13:34.424Z","comments":true,"path":"2019/08/01/流、元素与基本尺寸/","link":"","permalink":"http://yoursite.com/2019/08/01/流、元素与基本尺寸/","excerpt":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。","text":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。 “流”之所以影响了整个CSS世界，就是因为影响了CSS世界的基石HTML。HTNML标签通常分为两类：块级元素和内联元素。 注意： 按照W3C的CSS规范，这里应该是“块级元素”和“内联级元素”。但是在W3C的HTML规范里，已经明确把HTML元素分为了“块级元素”和“内联元素”。我们这里采用现实中常用的HTML的内联元素这一说法。 一、块级元素（block-level element）1.1 基本特性： 基本特性：换行特性（一个水平流上只能单独显示一个元素，多个块级元素则换行显示。） 注意：块级元素的流体特性主要表现在水平方向上。 1.2 块级元素和“display 为block 的元素”不是一个概念display:list-item、display:table均块级元素，因为他们符合块级元素的基本特征，即换行特征。 1.3 用display值为block和list-item来配合clear属性来清除浮动带来的影响不使用list-item的原因：字母比较多、会出现项目符号、ie浏览器不支持伪元素的display值为listitem。 如案例： .clear: after { content: &apos;&apos;; display: table; // 也可以是block，或者是list-item clear: both; }二、list-item 元素会出现项目符号的原因2.1 标记盒子：注意:标记盒子可以理解为主块级之外的附加盒子。 list-item 元素会出现项目符号是因为生成了一个附加的盒子，学名“标记盒子”（marker box），专门用来放圆点、数字这些项目号。 IE浏览器下伪元素不支持list-item 或许就是无法创建这个“标记盒子”导致的。 2.2 外在盒子和容器盒子注意:容器盒子可以理解为内在盒子。 内在盒子：负责元素是一行显示还是只能换行显示。 容器盒子：负责宽高、内容呈现等。 [按照display的属性值我们可以知道： display值为block的元素由外在的“块级盒子”和内在的“块级容器盒子”组成。 display值为inline-block的元素由外在的“内联盒子”和内在的“块级容器盒子”组成。 display值为inline的元素内外均是“内联盒子”。 display值为inline-table的元素外面是“内联盒子”，里面是“table 盒子”。 2.3 width/height 作用在“容器盒子”点此查看案例演示：和文字平起平坐的表格 案例结果：该元素和文字一行显示，且表现如同真正的表格元素（子元素宽度等分） 三、width/height作用的细节3.1 width默认值auto的4种表现：1、充分利用可用空间，宽度默认100%于父级容器的。 比如：&lt;div&gt;、&lt;p&gt;这些元素的宽度默认是100%于父级容器的。 这种充分利用可用空间的行为还有个专有名字，叫作fill-available。 2、自适应大小，具有包裹性。 典型代表：浮动、绝对定位、inline-block 元素或table 元素。 3、收缩到最小 这个最容易出现在table-l表格ayout 为auto 的中： 当一列空间都不够时，文字能断就断，但中文随便断的，英文单词不能断。 4、超出容器限制除非明确width的相关设置，否则上面3种都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如：内容很长的连续的英文和数字，或者内联元素被设置了white-space：nowrap,则表现为如下： 像这一种子元素既保持了inline-block元素的收缩性，又同时让内容宽度最大，直接无视父级容器的宽度限制，后来在CSS3中有了专门的属性值描述，教室max-cintent. 上面的几个只有第一个是“外部尺寸”，其余全部是“内部尺寸”。而这唯一的“外部尺寸”，是“流”的精髓所在。 四、外部尺寸与流体特性元素尺寸由外部的容器决定 正常流宽度是一种margin/border/padding和content 内容区域自动分配水平空间的机制，尽量用无宽带的流来布局。 格式化宽度：在position属性值为absolute 或fixed 的元素中。在默认情况下，宽度由内部尺寸决定。当left/top 或top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position 属性值不是static）的祖先元素计算。margin、border、padding 和content 内容区域同样会自动分配水平（和垂直）空间 五、内部尺寸与流体特性元素尺寸由内部元素决定，“内部尺寸”有下面3 种表现形式： 包裹性:元素尺寸由内部元素决定，但永远小于“包含块”容器的尺寸（除非容器尺寸小于元素的“首选最小宽度”）按钮: 按钮就是inline-block 元素。 按钮文字越多宽度越宽（内部尺寸特性），但如果文字足够多，则会在容器的宽度处自动换行（自适应特性）。 标签按钮才会自动换行，标签按钮，默white-space:pre，是不会换行的，需要将pre 值重置为默认的normal。 按钮最大宽度就是容器的240 像素 首选最小宽度:元素最适合的最小宽度.外部容器的宽度是240 像素，假设宽度是0，里面的inline-block 元素的宽度是首选最小宽度。具体表现规则： 东亚文字（如中文）最小宽度为每个汉字的宽度。 西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。 如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS 中的word-break:break-all。 类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度。 最大宽度:是元素可以有的最大宽度。“最大宽度”实际等同于“包裹性”元素设置white-space:nowrap 声明后的宽度。如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度。 六、width 值作用的细节width 是作用在“内在盒子”上的，“内在盒子”又被分成了4 个盒子，分别是content box、padding box、border box和margin box。 content box ： content-box，padding box ：padding-box，border box ：border-box。margin box没有名字。 margin 的背景永远是透明的。 在CSS2.1 的规范中，有一段非常露骨的描述：content box 环绕着width 和height 给定的矩形。这种宽度设定和表现并不合理： 流动性丢失：对于块状元素，如果width:auto，则元素会如水流般充满整个容器，而一旦设定了width具体数值，则元素的流动性就会被阻断。 与现实世界表现不一致的困扰。 七、CSS 流体布局下的宽度分离原则所谓“宽度分离原则”，就是CSS 中的width 属性不与影响宽度的padding/border（有时候包括margin）属性共存。写法： .father { width: 180px; } .son { margin: 0 20px; padding: 20px; border: 1px solid; }为何要宽度分离:当一件事情的发展可以被多个因素所左右的时候，这个事情最终的结果就会变数很大而不可预期。宽度在这里也是类似，由于盒尺寸中的4 个盒子都能影响宽度，自然页面元素的最终宽度就很容易发生变化而导致意想不到的布局发生。使用“宽度分离”后，咱们不需要烧脑子去计算了，而且页面结构反而更稳固。 八、改变width/height 作用细节的box-sizingbox-sizing 的作用：改变了width 作用的盒子。box-sizing:border-box 就是让100 像素的宽度直接作用在border box上，从默认的content box 变成border box。此时，content box 从宽度值中释放，形成了局部的流动性，和padding 一起自动分配width 值。 box-sizing 并不支持margin-box。 如何评价*{box-sizing:border-box}。从纯个人角度讲，不喜欢这种做法的。 这种做法易产生没必要的消耗，通配符*应该是一个慎用的选择器，因为它会选择所有的标签元素。 这种做法并不能解决所有问题。box-sizing 不支持margin-box，只有当元素没有水平margin 时候，box-sizing 才能真正无计算，而“宽度分离”等策略则可以彻底解决所有的宽度计算的问题。 替换元素css重置更合适： input, textarea, img, video, object { box-sizing: border-box; } 九、关于height对于width 属性，就算父元素width 为auto，其百分比值也是支持的。 对于height 属性，如果父元素height 为auto，只要子元素在文档流中，其百分比值完全就被忽略了。百分比高度值要想起作用，其父级必须有一个可以生效的高度值。 如何让元素支持height:100%效果： 设定显式的高度值。 使用绝对定位。绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于padding box 的，也就是说会把padding 大小值计算在内，但是，非绝对定位元素则是相对于content box 计算的。 十、min-width/max-width和min-height/max-heightmax-width 和max-height 的初始值是none,min-width/min-height 的初始值都是auto。 超越!important 指的是max-width 会覆盖width，而且这种覆盖不是普通的覆盖，是超级覆盖。 &lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important;&quot;&gt; img { max-width: 256px; }答案是256px。 min-width覆盖max-width，此规则发生在min-width和max-width冲突的时候。 任意高度元素的展开收起动画技术：.element { height: 0; overflow: hidden; transition: height .25s;}.element.active { height: auto; /* 没有transition 效果，只是生硬地展开 */}可以试试下面方法 .element { max - height: 0; overflow: hidden; transition: max - height .25s;}.element.active { max - height: 666px; /* 一个足够大的最大高度值 */}注意：即虽然说从适用范围讲，max- height 值越大使用场景越多，但是，如果max-height 值太大，在收起的时候可能会有“效果延迟”的问题。因此，我个人建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也会因为时间很短，很难被用户察觉，并不会影响体验。 十一、内联元素块级负责结构，内联负责内容。 “内联元素”的“内联”特指“外在盒子”，和“display 为inline的元素”不是一个概念。 “内联元素”的典型特征就是可以和文字在一行显示。 内容区域（content area）：域指一种围绕文字看不见的盒子可以理解为把文本选中的背景色区域作为内容区域。 注意：在IE 和Firefox 浏览器下，文字的选中背景总能准确反映内容区域范围，但是Chrome 浏览器下，::selection 范围并不总是准确的，例如，和图片混排或者有垂直padding 的时候，范围会明显过大，这一点需要注意。 内联盒子（inline box）：“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类： 内联盒子:外部含内联标签&lt;span&gt;、&lt;a&gt;和&lt;em&gt;等。匿名内联盒子:光秃秃的文字。 行框盒子（line box）:每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。 包含盒子（containing box）:标签就是一个“包含盒子”（实线框标注），此盒子由一行一行的“行框盒子”组成。 十二、幽灵空白节点在HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 注意:这里有一个前提，文档声明必须是HTML5 文档声明，如果还是很多年前的老声明，则不存在“幽灵空白节点”。 十三、致谢本文内容是我对张鑫旭老师《CSS世界》一书第三章的学习笔记，由衷的钦佩张鑫旭老师，向张鑫旭老师学习！也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS世界的专业术语","slug":"CSS世界的专业术语","date":"2019-07-31T08:21:13.000Z","updated":"2019-08-02T04:12:48.604Z","comments":true,"path":"2019/07/31/CSS世界的专业术语/","link":"","permalink":"http://yoursite.com/2019/07/31/CSS世界的专业术语/","excerpt":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。","text":"本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。 一、CSS世界的专业术语案例： .vacabulary{ height: 99px; color: transparent; }1. 属性例如上面案例中的高度和颜色就是CSS世界的属性，CSS属性就是魔法师。 2. 值CSS的各种属性值就是魔法师的魔法技能。在CSS世界中，值得分类十分广泛，比较常用的有： 整数值，如z-index:1中，1属于,同时也属于 数值，如line-height：1.5中的1.5 百分比值，如padding：50%中的50% 长度值，如99px 颜色值，如#999 此外，还有字符串值、位置值等类型。在CSS3新世界中，还有角度值、频率值、时间值等类型。 3. 关键词 关键字：CSS中很关键的英文单词。例如上面案例中的transparent（全透明黑色）就是典型的关键词，还有常见的solid（实线的）、inherit(继承)。 泛关键字：所有CSS属性都可以使用的关键字，例如initial（默认）、inherit（继承）和unset（不设置） 4. 变量CSS中目前可以称为变量的比较有效，CSS3中的currentColor就是变量，非常有用：currentColor-CSS3超高校级好用CSS变量; 以及阮一峰老师的自定义CSS变量教程：CSS 变量教程 5. 长度单位CSS中的单位有时间单位（如s、ms）,还有角度单位（如deg、rad等），但最常见的还是长度单位。长度单位分为： 绝对长度单位：彼此固定，不会因为其他元素的尺寸变化而变化。主要有px、cm、mm、Q、in、pc、pt(eg:除px外，其他基本不用) 相对长度单位：指定相对于另一长度的长度。主要有em、ex、ch、rem、%和可视区百分比长度单位 vm、vh、vmin、vmax 注意： 2%属于数值，这里的%不是长度单位 “值”里面的&lt;length和长度单位的关系：&lt;numberre&gt;+长度单位=&lt;length&gt;; 6. 功能符值以函数的形式指定（就是被括号括起来的那种），主要用来表示颜色（rgba和hsla）、背景图片地址（url)、元素属性值、计算（calc）和过渡效果等，如rgba (0,0,0,0)、url(“css-world.png”)、attr(“herf”)、scale(-1) 7. 属性值属性冒号后面的内容统一称为属性值 8. 声明属性名+属性值 9. 声明块声明块就是花括号{}包裹的一系列声明 10. 规则或规则集出现了选择器，而且后面跟着声明块，如本文最上面的案例。 11. 选择器用来瞄准目标元素的东西。 类选择器：如.umbrella ID选择器：如#id 属性 选择器：如[attribute] [target] 选择带有 target 属性所有元素 伪类选择器：一般前面有一个： 伪元素选择器：有两个冒号的原则，::selection ::selection 选择被用户选取的元素部分。 这里放上更详细的介绍：CSS 选择器参考手册 12. 关系选择器根据与其他元素的关系选择元素的选择器，常见的有： 后代选择器 空格连接 相邻后代选择器 &gt;连接 兄弟选择器 ~连接 （注意：是当前元素后面所有的的合规则的那个同父的兄弟元素） 相邻兄弟选择器： +连接 （注意：仅仅选择当前元素相邻的那一个同父元素的合规则的兄弟元素。且适用于IE7以上版本） 13. @规则指的是以@字符开头的一些规则，例如@media、@font-face、@page或@support 二、CSS世界中的“未定义行为”现实世界中，法律约束我们的行为，如果越界，就叫违法；在CSS世界中，有Web标准约束元素的行为，如果越界就称为bug。不过不可能面面俱到，法律会有法律空白，在CSS世界也会有”未定义行为”。例如以下这个案例：FireFox mousedown干掉:active实例页面 HTML： 正常情况： &lt;a href=&quot;javascript:&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt; 包含JS： &lt;a href=&quot;javascript:&quot; id=&quot;button&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt;CSS： .active-btn { display: inline-block; background-color: #cd0000; } .active-btn:active { background-color: #ae0000; }JavaScript： var button = document.getElementById(&quot;button&quot;); if (button.addEventListener) { button.addEventListener(&quot;mousedown&quot;, function(event) { // 此处省略N行 event.preventDefault(); }); }现象描述：在FireFox浏览器中，点击“正常情况按钮”会出现按钮点击样式，但点击“包含js的按钮”，则不会有按钮点击样式 原因分析：因为规范上并没有对这种场景的具体描述，所以FireFox认为：active发生在mousedown事件之后。（IE/Chrome反之认为） 像这种规范估计不到的细枝末节的实现，就称之“未定义行为” 三、致谢本文内容我对张鑫旭老师《CSS世界》一书第二章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS世界概述","slug":"CSS世界概述","date":"2019-07-31T02:28:28.000Z","updated":"2019-08-01T02:48:18.136Z","comments":true,"path":"2019/07/31/CSS世界概述/","link":"","permalink":"http://yoursite.com/2019/07/31/CSS世界概述/","excerpt":"欢迎来到CSS世界，这里有几个比较大的平行世界，不同世界有浏览器王国的命运也不一样，这里还有许多厉害的魔法师哦！","text":"欢迎来到CSS世界，这里有几个比较大的平行世界，不同世界有浏览器王国的命运也不一样，这里还有许多厉害的魔法师哦！ 一、CSS世界的世界观在CSS世界中： 世界：操作系统不同的操作系统代表了不同的评选世界，CSS世界有几个比较大的平行世界，即： Window世界 OS X世界 移动端iOS世界 Android世界 王国：浏览器不同世界的浏览器王国的命运不一样，例如： 在OS X世界中，IE王国是不存在的，而Safari王国异常强大 而在Window世界中，Safari王国异常落寞 魔法师：CSS属性CSS的各种属性值就是魔法师的魔法技能 魔法石：HTML选择法器：选择器例如，使用.umbrella法器，即可对所有class=”umbrella”的元素进行改变 二、CSS世界为什么被创造出来2.1 CSS的诞生在最开始的时候，互联网领域的信息就是图片和文字，网站的功能就是信息展示。那时候的网站前端技术关心的是图片和文字的呈现，而 CSS世界的诞生就是为图文信息展示服务 2.2 CSS完胜SVG的武器——流在很长一段时间里，网站的主要功能都是图片和文字信息的展示，而SVG的强项是图片，但是文字内容的呈现不敢恭维，所以SVG被打入冷宫，CSS一如既往被重用。 CSS为什么有强大的图文显示能力？ 流！ 2.3 什么是流？流，即是“文档流”的简称，“流”实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的“水流”。 “流”就是CSS世界中引导元素排列和定位的一条看不见的“水流” CSS世界构建的基石是HTML,而HTML最具代表的两个基石正好是CSS世界中的块级元素和内联元素的代表，对应着盛水容器的水和木头 现实中的水流：水流自动铺满容器，放入木头，水位升高，木头依次排序。CSS世界中的流：div自动铺满容器，图片文字依次排列，不足则换行。 流是如何影响整个CSS世界的 通过控制HTML默认的表现符合流，来使流”统治CSS世界 通过破坏“流”来实现特殊布局 通过改变流的流向来改变表现形式 流体布局利用元素“流”的特性实现的各类布局效果。例如“div+CSS布局” 注意：“自适应布局”是凡具有自适应特性的一类布局的统称，“流体布局要小寨的多。例如表格布局是自适应布局，但不是流体布局” 2.4 CSS的世界的一些备注 对CSS2.1的全面支持是从微软公司的IE8开始的。 比CSS还要老,他有自己的世界。“流”的特性对并不适用，一些CSS属性的表现，如单元格的vertical-align，也和普通元素不一样。 CSS新世界——CSS3:布局更为丰富，视觉表现长足进步。 三、致谢本文内容我对张鑫旭老师《CSS世界》一书第一章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励! 作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程","slug":"建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程","date":"2019-07-29T13:21:14.000Z","updated":"2019-07-31T05:43:00.098Z","comments":true,"path":"2019/07/29/建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程/","link":"","permalink":"http://yoursite.com/2019/07/29/建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程/","excerpt":"感谢TRHX的建站博客,真的非常详细，给予我莫大的帮助！另外在建站过程中，发现了一个需要注意的问题。","text":"感谢TRHX的建站博客,真的非常详细，给予我莫大的帮助！另外在建站过程中，发现了一个需要注意的问题。 致谢感谢TRHX的“使用Github Pages和Hexo搭建自己的独立博客【超级详细的小白教程】”,真的非常详细，给予我的网站莫大的帮助！感谢作者！ 建站过程中需要注意的问题1、无法用“https:/yangfff.github.io”打开网页的问题以及解决问题描述：无法用“https:/yangfff.github.io”打开网页 原因分析：没有配置号 Git 个人信息 直接原因：在“ _config.yml 文件”中repository是SSH格式的，但是却没有将Github项目的 Clone or download 按钮，选择为 Use SSH _config.yml 文件： deploy: type: git repository: git@github.com:yangfff/yangfff.github.io.git branch: master解决方法：将Github项目的 Clone or download 按钮，选择为 Use SSH","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-29T12:04:03.048Z","updated":"2019-07-31T05:34:39.127Z","comments":true,"path":"2019/07/29/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/29/hello-world/","excerpt":"Welcom!Let’s Go! Create a new post1$ hexo new \"My New Post\" Run server1$ hexo s Deploy to remote sites1$ hexo d -g","text":"Welcom!Let’s Go! Create a new post1$ hexo new \"My New Post\" Run server1$ hexo s Deploy to remote sites1$ hexo d -g Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}