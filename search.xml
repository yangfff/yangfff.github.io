<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Canvas制作一个自定义画板</title>
      <link href="/2019/08/16/%E4%BD%BF%E7%94%A8Canvas%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%BB%E6%9D%BF/"/>
      <url>/2019/08/16/%E4%BD%BF%E7%94%A8Canvas%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%BB%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>制作一个自定义画板，进一步熟悉一下Canvas的API 用法。</p><a id="more"></a><h2 id="一、画板的建立"><a href="#一、画板的建立" class="headerlink" title="一、画板的建立"></a>一、画板的建立</h2><p>需求分析：</p><p>（1）当鼠标按下的时候，开始描画，此处需要加入鼠标按下事件。<br>（2）当鼠标弹起的时候，结束描画，此处需要加入鼠标弹起事件。<br>（3）在鼠标按下并且移动的时候，在鼠标经过的路径上画线，此处需要加入鼠标移动<br>事件。</p><p>代码实现：</p><p>下列代码画了一个黑色矩形区域，作为画板。</p><pre><code>// 画一个黑色矩形ctx.fillStyle=&quot;black&quot;;ctx.fillRect(0,0,600,300);</code></pre><p>下面建立了 3 个变量，变量 onoff 用来控制鼠标是否按下，只有当鼠标按下的时候才会</p><pre><code>开始绘图。变量 oldx、oldy 表示鼠标发生移动前的坐标。// 按下标记var onoff = false;var oldx = -10;var oldy = -10;</code></pre><p>下面设置画笔的颜色为白色，线宽为 4。</p><pre><code>// 设置颜色var linecolor = &quot;white&quot;;// 设置线宽var linw = 4;</code></pre><p>下面给 Canvas 添加了鼠标按下侦听事件，当鼠标按下的时候，会调用 down 函数。</p><pre><code>// 添加鼠标按下事件canvas.addEventListener(&quot;mousedown&quot;,down,false);</code></pre><p>下面给 Canvas 添加了鼠标弹起侦听事件，当鼠标弹起的时候，会调用 up 函数。</p><pre><code>// 添加鼠标弹起事件canvas.addEventListener(&quot;mouseup&quot;,up,false);</code></pre><p>下面给 Canvas 添加了鼠标移动侦听事件，当鼠标在 Canvas 上移动的时候，会持续调用draw 函数。</p><pre><code>// 添加鼠标移动事件canvas.addEventListener(&quot;mousemove&quot;,draw,true);</code></pre><p><strong>三个函数：</strong></p><p>down 函数是在鼠标按下的时候调用的。当调用 down 函数的时候，会将 onoff 变量设置为 true，表示开始绘图，并给 oldx、oldy 赋予鼠标当前位置的坐标值。</p><pre><code>function down(event){ onoff = true; oldx = event.pageX-10; oldy = event.pageY-10;}</code></pre><p>up 函数是在鼠标弹起的时候调用的。当调用 up 函数的时候，将 onoff 变量设置为 false，表示结束绘图。</p><pre><code>function up(){ onoff = false;}</code></pre><p>draw 函数是在鼠标发生移动的时候不断持续调用的。当调用 draw 函数的时候，首先判断 onoff 变量的值，即判断鼠标是否处于按下状态，如果鼠标处于按下状态，则开始画线。</p><pre><code>function draw(event){ if(onoff == true){      var newx = event.pageX-10;      var newy = event.pageY-10;      ctx.beginPath();     ctx.moveTo(oldx,oldy);     ctx.lineTo(newx,newy);     ctx.strokeStyle=linecolor;     ctx.lineWidth=linw;     ctx.lineCap=&quot;round&quot;;     ctx.stroke();     oldx = newx;     oldy = newy; }</code></pre><p>每次画线时，需要确定线条的起始位置和结束位置，线条的起始位置就是坐标(oldx,oldy)，然后把当前鼠标位置作为线条的结束位置，代码如下所示 ：</p><pre><code>var newx = event.pageX-10; var newy = event.pageY-10; </code></pre><p>接着，利用 moveTo 和 lineTo 画线，代码如下所示 ：</p><pre><code>ctx.beginPath();ctx.moveTo(oldx,oldy);ctx.lineTo(newx,newy);ctx.strokeStyle=linecolor;ctx.lineWidth=linw;ctx.lineCap=&quot;round&quot;;ctx.stroke();</code></pre><p>上面的代码是画一条从坐标 (oldx,oldy) 到坐标 (newx,newy) 的线段，并设置了线条的颜色、宽度和线帽的类型。</p><p>在此次绘制结束后，新的鼠标位置将作为下一次画线的起始位置，代码如下所示 ：</p><pre><code>oldx = newx;oldy = newy;</code></pre><p>实现效果：</p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%94%BB%E6%9D%BF1.png" alt></p><h2 id="二、加入按钮操作改变画笔颜色和线条宽度的功能"><a href="#二、加入按钮操作改变画笔颜色和线条宽度的功能" class="headerlink" title="二、加入按钮操作改变画笔颜色和线条宽度的功能"></a>二、加入按钮操作改变画笔颜色和线条宽度的功能</h2><p>下面的代码加入了 6 个按钮，并加入了单击事件，当单击不同按钮的时候，就会相应地改变画笔的颜色。</p><pre><code>&lt;button style=&quot;width:80px;background-color:yellow;&quot; onclick=&apos;linecolor = &quot;yellow&quot;;&apos;&gt;YELLOW&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:red;&quot; onclick=&apos;linecolor = &quot;red&quot;;&apos;&gt;RED&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:blue;&quot; onclick=&apos;linecolor = &quot;blue&quot;;&apos;&gt;BLUE&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:green;&quot; onclick=&apos;linecolor = &quot;green&quot;;&apos;&gt;GREEN&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&apos;linecolor = &quot;white&quot;;&apos;&gt;WHITE&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:black;color:white;&quot; onclick=&apos;linecolor = &quot;black&quot;;&apos;&gt;BLACK&lt;/button&gt;</code></pre><p>下面的代码加入了 3 个按钮，并加入了单击事件，当单击不同按钮的时候，就会相应地改变线条的宽度。</p><pre><code>&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 4;&quot;&gt;4px&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 8;&quot;&gt;8px&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 16;&quot;&gt;16px&lt;/button&gt;</code></pre><p>实现效果：</p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%94%BB%E6%9D%BF2.png" alt></p><h2 id="三、画布的导出功能"><a href="#三、画布的导出功能" class="headerlink" title="三、画布的导出功能"></a>三、画布的导出功能</h2><p>画板的图片导出功能，即复制Canvas 画板上的图像，使其保存为图片格式。</p><p>要将 Canvas 画板保存为图片格式，只需要使用下面的方法即可：</p><pre><code>canvas.toDataURL(&quot;image/png&quot;);</code></pre><p>现在可在页面上新建一个 <img> 标签，然后将复制的 Canvas 内容用 <img> 表示出来。</p><p>代码如下：</p><pre><code>/**添加一个导出按钮/&lt;button id=&quot;but10&quot; style=&quot;width:80px;background-color:pink;&quot; onclick=&quot;copyimage();&quot;&gt;EXPORT&lt;/button&gt;/*新建一个 &lt;img &gt; 标签*/&lt;img src=&quot;&quot; id=&quot;image_png&quot;  width=&quot;600&quot; height=&quot;300&quot;&gt;/*将复制的 Canvas 内容用 &lt;img&gt; 表示出来*/function copyimage(event){    var img_png_src = canvas.toDataURL(&quot;image/png&quot;);    document.getElementById(&quot;image_png&quot;).src = img_png_src;}</code></pre><p>实现效果：</p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%94%BB%E6%9D%BF3.png" alt></p><h2 id="四、完整代码"><a href="#四、完整代码" class="headerlink" title="四、完整代码"></a>四、完整代码</h2><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;300&quot;&quot;&gt;&lt;/canvas&gt;&lt;br&gt;&lt;button style=&quot;width:80px;background-color:yellow;&quot; onclick=&apos;linecolor = &quot;yellow&quot;;&apos;&gt;YELLOW&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:red;&quot; onclick=&apos;linecolor = &quot;red&quot;;&apos;&gt;RED&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:blue;&quot; onclick=&apos;linecolor = &quot;blue&quot;;&apos;&gt;BLUE&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:green;&quot; onclick=&apos;linecolor = &quot;green&quot;;&apos;&gt;GREEN&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&apos;linecolor = &quot;white&quot;;&apos;&gt;WHITE&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:black;color:white;&quot; onclick=&apos;linecolor = &quot;black&quot;;&apos;&gt;BLACK&lt;/button&gt;&lt;br&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 4;&quot;&gt;4px&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 8;&quot;&gt;8px&lt;/button&gt;&lt;button style=&quot;width:80px;background-color:white;&quot; onclick=&quot;linw = 16;&quot;&gt;16px&lt;/button&gt;&lt;br&gt;&lt;button id=&quot;but10&quot; style=&quot;width:80px;background-color:pink;&quot; onclick=&quot;copyimage();&quot;&gt;EXPORT&lt;/button&gt;&lt;br&gt;&lt;img src=&quot;&quot; id=&quot;image_png&quot;  width=&quot;600&quot; height=&quot;300&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);//画一个黑色矩形ctx.fillStyle=&quot;black&quot;;ctx.fillRect(0,0,600,300);//按下标记var onoff = false;var oldx = -10;var oldy = -10;//设置颜色var linecolor = &quot;white&quot;;//设置线宽var linw = 4;//添加鼠标移动事件canvas.addEventListener(&quot;mousemove&quot;,draw,true);//添加鼠标按下事件canvas.addEventListener(&quot;mousedown&quot;,down,false);//添加鼠标弹起事件canvas.addEventListener(&quot;mouseup&quot;,up,false);function down(event){    onoff = true;    oldx = event.pageX-10;    oldy = event.pageY-10;}function up(){    onoff = false;}function draw(event){    if(onoff == true){         var newx = event.pageX-10;         var newy = event.pageY-10;         ctx.beginPath();        ctx.moveTo(oldx,oldy);        ctx.lineTo(newx,newy);        ctx.strokeStyle=linecolor;        ctx.lineWidth=linw;        ctx.lineCap=&quot;round&quot;;        ctx.stroke();        oldx = newx;        oldy = newy;    };};function copyimage(event){    var img_png_src = canvas.toDataURL(&quot;image/png&quot;);    document.getElementById(&quot;image_png&quot;).src = img_png_src;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5-Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas高级功能</title>
      <link href="/2019/08/16/Canvas%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/16/Canvas%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍Canvas 中的缩放、平移、旋转和倾斜等基本变形功能的实现，并且利用这些基本变形的组合操作实现了图片的扭曲以及介绍一下色彩的渲染 </p><a id="more"></a><h2 id="一、变形"><a href="#一、变形" class="headerlink" title="一、变形"></a>一、变形</h2><p>默认情况下，一个画布的坐标空间会使用画布的左上角 (0,0) 作为原点，x 值向右增加，y 值向下增加。这个坐标空间中的单位通常会被转换为像素，然后，可通过转换坐标空间在绘图过程中实现移动、缩放或旋转等操作。这些操作是通过 translate()、scale() 和 rotate() 等方法来实现的，它们会对画布的变换矩阵产生影响。</p><h3 id="1-1-放大与缩小"><a href="#1-1-放大与缩小" class="headerlink" title="1.1 放大与缩小"></a>1.1 放大与缩小</h3><p><strong>用scale函数来实现图形的放大和缩小：</strong></p><pre><code>scale(x, y); </code></pre><ul><li><p>第一个参数 x 表示在 x 轴进行缩放，即水平缩放</p></li><li><p>第二个参数 y 表示在 y 轴上进行缩放，即在竖直方向上进行缩放</p>  <script type="text/javascript">  var c=document.getElementById("myCanvas");  var ctx=c.getContext("2d");  /*画一个宽150，高100的黑色矩形*/  ctx.beginPath();  ctx.strokeStyle = "#000000";  ctx.strokeRect(10,10,150,100);  /*将原先的矩形沿x、y方向放大3倍，并重画一个灰色矩形*/  ctx.scale(3,3);  ctx.beginPath();  ctx.strokeStyle = "#cccccc";  ctx.strokeRect(10,10,150,100);  /*将黑色矩形缩小到0.5倍*/  ctx.scale(0.5,0.5);  ctx.beginPath();  ctx.strokeStyle = "#cccccc";  ctx.strokeRect(50,50,150,100);  </script></li></ul><p><strong>用scale函数参数为负来实现图形的翻转：</strong></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot; style=&quot;background-color: #cccccc;&quot;&gt;你的浏览器不支持HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,10,10);      ctx.scale(1,-1);    ctx.drawImage(image,250,-250);};  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-平移"><a href="#1-2-平移" class="headerlink" title="1.2 平移"></a>1.2 平移</h3><p>使用 translate 函数可以实现对图形进行平移的功能。</p><pre><code>translate (x, y);</code></pre><ul><li><p>第一个参数 x 表示在 x 轴进行平移，即在水平方向上平移</p></li><li><p>第二个参数 y 表示在 y 轴上进行缩放，即在竖直方向上平移。</p>  <script type="text/javascript">  var c=document.getElementById("myCanvas");  var ctx=c.getContext("2d");  ctx.beginPath();  ctx.strokeStyle = "#000000";  ctx.strokeRect(10,10,150,100);  ctx.translate(50,100);  ctx.beginPath();  ctx.strokeStyle = "#cccccc";  ctx.strokeRect(10,10,150,100);  </script></li></ul><h3 id="1-3-旋转"><a href="#1-3-旋转" class="headerlink" title="1.3 旋转"></a>1.3 旋转</h3><p>使用rotate函数可以实现图形的旋转功能。</p><pre><code>rotate (angle);</code></pre><p><strong>注意：</strong>传入rotate的参数angle是弧度不是角度。如果角度是angle，那么换算成弧度就是<br>angle*Math.PI/180。</p><p>以Canvas的起始坐标（0，0）为中心进行旋转：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(200,50,100,50);ctx.rotate(45*Math.PI/180);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(200,50,100,50);&lt;/script&gt;</code></pre><p>使用1.2中的translate函数，让图形以自己为中心旋转：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(200,50,100,50);/*先将Canvas的起始坐标移动到所画矩形的中心处，然后旋转，再将Canvas起始坐标返回*/ctx.translate(250,75);ctx.rotate(45*Math.PI/180);ctx.translate(-250, -75);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(200,50,100,50);&lt;/script&gt;</code></pre><h3 id="1-4-利用-transform-矩阵实现多样化的变形"><a href="#1-4-利用-transform-矩阵实现多样化的变形" class="headerlink" title="1.4 利用 transform 矩阵实现多样化的变形"></a>1.4 利用 transform 矩阵实现多样化的变形</h3><p>上面分别讲了缩放、平移以及旋转的实现方法。其实所有这些变形都是可以通过变形矩阵 transform 来实现的。</p><pre><code>transform (a,b,c,d,e,f); </code></pre><p>该函数的各个变量对应以下变换矩阵中相应位置的参数：</p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A21.png" alt></p><h5 id="1-4-1-缩放"><a href="#1-4-1-缩放" class="headerlink" title="1.4.1 缩放"></a>1.4.1 缩放</h5><p>设原始坐标为（x,y）,缩放后坐标为（x1,y1）缩放倍数分别为a,d,那么：</p><p>x1 = a*x</p><p>x2 = d*y</p><p>得到矩阵公式：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A22.png" alt></p><p>这样就可以用transform(a,0,0,d,0,0)来代替scale（a,d）了。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(10,10,150,100);/*将原先的矩形沿x、y方向放大3倍，并重画一个灰色矩形*/ctx.transform(3,0,0,3,0,0); ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(10,10,150,100);&lt;/script&gt;</code></pre><h5 id="1-4-2-平移"><a href="#1-4-2-平移" class="headerlink" title="1.4.2 平移"></a>1.4.2 平移</h5><p>设原始坐标为（x,y）,缩放后坐标为（x1,y1）x,y平移量分别为e,f,那么：</p><p>x1 = x+e</p><p>x2 = y+f</p><p>得到矩阵公式：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E9%98%B5.png" alt></p><p>这样就可以用transform(1,0,0,1,e,f)来代替translate（e,f）了。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(10,10,150,100);ctx.transform (1,0,0,1,50,100);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(10,10,150,100);&lt;/script&gt;</code></pre><h5 id="1-4-3-旋转"><a href="#1-4-3-旋转" class="headerlink" title="1.4.3 旋转"></a>1.4.3 旋转</h5><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A23.png" alt></p><p>现在可以用 transform (cos θ, sin θ, –sin θ, cos θ,0,0) 来替换 rotate (θ) 了</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(200,50,100,50);ctx.transform (Math.cos(45*Math.PI/180),Math.sin(45*Math.PI/180),-Math.sin(45*Math.PI/180), Math.cos(45*Math.PI/180),0,0);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(200,50,100,50);&lt;/script&gt;</code></pre><p>变换矩阵也可以通过 setTransform 函数来实现，setTransform 的参数与 transform 一样，不同的是，setTransform 函数是先消去之前的 transform 变换，然后重新进行变换的</p><p><strong>transform:</strong>第二次在第一次的基础上再旋转10度，相当于旋转了15度</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(200,50,100,50);/*首先旋转5度*/ctx.transform (Math.cos(5*Math.PI/180),Math.sin(5*Math.PI/180),-Math.sin(5*Math.PI/180), Math.cos(5*Math.PI/180),0,0);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(200,50,100,50);/*第二次在第一次的基础上再旋转10度，相当于旋转了15度*/ctx.transform (Math.cos(10*Math.PI/180),Math.sin(10*Math.PI/180),-Math.sin(10*Math.PI/180), Math.cos(10*Math.PI/180),0,0);ctx.beginPath();ctx.strokeStyle = &quot;#999999&quot;;ctx.strokeRect(200,50,100,50);</code></pre><p><strong>setTransform:</strong>清楚transform历史，重新旋转</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.strokeStyle = &quot;#000000&quot;;ctx.strokeRect(200,50,100,50);/*首先旋转5度*/ctx.transform (Math.cos(5*Math.PI/180),Math.sin(5*Math.PI/180),-Math.sin(5*Math.PI/180), Math.cos(5*Math.PI/180),0,0);ctx.beginPath();ctx.strokeStyle = &quot;#cccccc&quot;;ctx.strokeRect(200,50,100,50);/*清除第一次旋转5度的历史，重新对原来的图形旋转10度*/ctx.setTransform (Math.cos(10*Math.PI/180),Math.sin(10*Math.PI/180),-Math.sin(10*Math.PI/180), Math.cos(10*Math.PI/180),0,0);ctx.beginPath();ctx.strokeStyle = &quot;#999999&quot;;ctx.strokeRect(200,50,100,50);&lt;/script&gt;</code></pre><h5 id="1-4-4-倾斜"><a href="#1-4-4-倾斜" class="headerlink" title="1.4.4 倾斜"></a>1.4.4 倾斜</h5><p><strong>倾斜1:</strong></p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%80%BE%E6%96%9C1.png" alt><br>图中3点p0、p2、p3遵循公式：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A24.png" alt><br>将上面的矩形公式代入steTransform函数中</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&apos;myCanvas&apos;);  var ctx=c.getContext(&apos;2d&apos;);ctx.setTransform(1,10/150,-40/100,1,40,10);  ctx.rect(50,50,150,100);  ctx.stroke();&lt;/script&gt;</code></pre><p>结果：<img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%BB%93%E6%9E%9C1.png" alt></p><hr><p><strong>倾斜2:</strong><br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%80%BE%E6%96%9C2.png" alt><br>图中3点p1、p2、p3遵循公式：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A25.png" alt><br>将上面的矩形公式代入steTransform函数中</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&apos;myCanvas&apos;);  var ctx=c.getContext(&apos;2d&apos;);ctx.setTransform(130/150,-20/150,-20/100,80/100,0,0);ctx.rect(50,50,150,100);  ctx.stroke();&lt;/script&gt;</code></pre><p>结果：<img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%BB%93%E6%9E%9C2.png" alt></p><h5 id="1-4-5-图片扭曲效果"><a href="#1-4-5-图片扭曲效果" class="headerlink" title="1.4.5 图片扭曲效果"></a>1.4.5 图片扭曲效果</h5><p>图中的扭曲变形效果需要通过多种变形组合来实现：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%9F%A9%E5%BD%A2%E5%8F%98%E5%BD%A2.png" alt></p><p>先实现两个倾斜的变形，然后利用clip函数江图片的一部分绘制出来：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&apos;myCanvas&apos;);var ctx=c.getContext(&apos;2d&apos;);var img = new Image();img.src=&quot;face.jpg&quot;;img.onload = function(){ctx.save();/*左半边图的绘制：以三个点为顶点绘制一个三角形，然后利用clip函数将这个三角形作为绘图的可视区域*//*以三个点为顶点绘制一个三角形*/ctx.beginPath();ctx.moveTo(80,0);ctx.lineTo(320,40);ctx.lineTo(0,200);ctx.closePath();ctx.clip();/*以刚才三角形的三个顶点来进行倾斜变形*/ctx.setTransform((320-80)/240,40/240,-80/240,200/240,80,0);/*绘制图片：因为绘图的区域是一个三角形，所以绘制完的图片只有一部分*/ctx.drawImage(img,0,0);ctx.restore();ctx.save();/*右半边图的绘制，方法一样*/ctx.beginPath();ctx.moveTo(320,40);ctx.lineTo(0,200);ctx.lineTo(200,150);ctx.closePath();ctx.clip();ctx.setTransform(200/240,(150-200)/240,(200-320)/240,(150-40)/240,0,200);ctx.drawImage(img,0,0-240);ctx.restore();};&lt;/script&gt;</code></pre><h2 id="二、图形的渲染"><a href="#二、图形的渲染" class="headerlink" title="二、图形的渲染"></a>二、图形的渲染</h2><h3 id="2-1-绘制颜色渐变效果的图形"><a href="#2-1-绘制颜色渐变效果的图形" class="headerlink" title="2.1 绘制颜色渐变效果的图形"></a>2.1 绘制颜色渐变效果的图形</h3><p>颜色的渐变分为线性渐变和径向渐变</p><h5 id="2-1-1-线性渐变"><a href="#2-1-1-线性渐变" class="headerlink" title="2.1.1 线性渐变"></a>2.1.1 线性渐变</h5><p>使用 createLinearGradient 函数和 addColorStop 函数可以实现线性渐变功能：<br>    createLinearGradient(x1,y1,x2,y2)</p><p>其中的 4 个参数分别是渐变的出发点坐标 (x1，y1) 与终点坐标 (x2，y2)。</p><pre><code>addColorStop (position,color)</code></pre><p>其中，position 参数必须是一个 0.0 到 1.0 之间的数值，表示渐变中颜色地点的相对地位；color 参数表示渐变的颜色。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var grd=ctx.createLinearGradient(0,0,200,0);grd.addColorStop(0.2,&quot;#00ff00&quot;);grd.addColorStop(0.8,&quot;#ff0000&quot;);ctx.fillStyle=grd;ctx.fillRect(0,0,200,100);&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%B8%90%E5%8F%981.png" alt></p><h5 id="2-1-1-径向渐变"><a href="#2-1-1-径向渐变" class="headerlink" title="2.1.1 径向渐变"></a>2.1.1 径向渐变</h5><p>使用 createRadialGradient 函数和 addColorStop 函数可以实现径向渐变功能。</p><pre><code>createRadialGradient (x0,y0,r0,x1,y1,r1) </code></pre><p>其中，参数 x0、y0 为开始圆的圆心坐标，r0 为开始圆的直径 ；x1、y1 为结束圆的圆心坐标，r1 为结束圆的直径。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var grd=ctx.createRadialGradient(100,100,10,100,100,50);grd.addColorStop(0,&quot;#00ff00&quot;);grd.addColorStop(1,&quot;#ff0000&quot;);ctx.fillStyle=grd;ctx.fillRect(0,0,200,200);&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%B8%90%E5%8F%982.png" alt></p><h3 id="2-2-颜色合成"><a href="#2-2-颜色合成" class="headerlink" title="2.2 颜色合成"></a>2.2 颜色合成</h3><p>globalCompositeOperation 属性说明了绘制到画布上的颜色是如何与画布上已有的颜色组合起来的。</p><p>使用代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle=&quot;#00ff00&quot;;ctx.fillRect(10,10,50,50);ctx.globalCompositeOperation=&quot;source-over&quot;;ctx.beginPath();ctx.fillStyle=&quot;#ff0000&quot;;ctx.arc(50,50,30,0,2*Math.PI);ctx.fill();&lt;/script&gt;</code></pre><p>下面列出了其中可能要设置的值以及它们的含义。</p><p><strong>注：</strong></p><blockquote><ol><li>source 一词指的是将要绘制到画布上的颜色</li><li>destination 指的是画布上已经存在的颜色</li><li>默认值是source-over</li></ol></blockquote><ul><li>copy ：只绘制新图形，删除其他所有内容。</li><li>darker ：在图形重叠的地方，其颜色由两个颜色值相减后决定。</li><li>destination-atop ：画布上已有的内容只会在它和新图形重叠的地方保留。新图形绘制于内容之后。</li><li>destination-in ：在新图形及画布上已有图形重叠的地方，画布上已有内容都保留。所</li><li>有其他内容均为透明的。</li><li>destination-out ：在画布上已有内容和新图形不重叠的地方，已有内容保留。所有其他</li><li>内容均为透明的。</li><li>destination-over ：新图形绘制于画布上已有内容的后面。</li><li>lighter ：在图形重叠的地方，其颜色由两种颜色值的加值来决定。</li><li>source-atop ：只有在新图形和画布上已有内容重叠的地方才绘制新图形。</li><li>source-in ：在新图形以及画布上已有内容重叠的地方才绘制新图形。所有其他内容均为透明的。</li><li>ource-out ：只有在和画布上已有图形不重叠的地方才绘制新图形。</li><li>source-over ：新图形绘制于画布上已有图形的顶部。这是默认的设置。</li><li>xor ：在重叠和正常绘制的其他地方，图形都成为透明的。</li></ul><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%B1%9E%E6%80%A7.png" alt><br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%B1%9E%E6%80%A72.png" alt></p><h3 id="2-3-颜色反转"><a href="#2-3-颜色反转" class="headerlink" title="2.3 颜色反转"></a>2.3 颜色反转</h3><p>所谓颜色反转，就是对图形的每个像素进行颜色取反</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,0,0);      var imgdata = ctx.getImageData(0,0,250,250);     var pixels = imgdata.data;      // 遍历每个像素并对 RGB 值进行取反    for (var i=0, n=pixels.length; i&lt;n; i+= 4){         pixels[i] = 255-pixels[i];         pixels[i+1] = 255-pixels[i+1];         pixels[i+2] = 255-pixels[i+2];     }     // 在指定位置进行像素重绘    ctx.putImageData(imgdata, 250, 0); };  &lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E9%A2%9C%E8%89%B2%E5%8F%8D%E8%BD%AC.png" alt></p><h3 id="2-4-灰度控制"><a href="#2-4-灰度控制" class="headerlink" title="2.4 灰度控制"></a>2.4 灰度控制</h3><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,0,0);      var imgdata = ctx.getImageData(0,0,250,250);     var pixels = imgdata.data;      // 遍历每个像素并对 RGB 值进行取反    for (var i=0, n=pixels.length; i&lt;n; i+= 4){         var grayscale = pixels[i]*.3+pixels[i+1]*.59+pixels[i+2]*.11;        pixels[i  ] = grayscale;     // red         pixels[i+1] = grayscale;     // green         pixels[i+2] = grayscale;     // blue    }     // 在指定位置进行像素重绘    ctx.putImageData(imgdata, 250, 0); };  &lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%81%B0%E5%BA%A6.png" alt></p><h3 id="2-5-阴影效果"><a href="#2-5-阴影效果" class="headerlink" title="2.5 阴影效果"></a>2.5 阴影效果</h3><p>Canvas API 中包含了自动为你所绘制的任何图形添加下拉阴影的属性。</p><p>阴影的颜色可用shadowColor 属性来指定，并且可以通过 shadowOffsetX 和 hadowOffsetY 属性来改变。</p><p>另外，应用到阴影边缘的羽化量也可以使用 shadowBlur 属性来设置。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);/*设定阴影颜色为红色*/ctx.shadowColor=&quot;#ff0000&quot;;/*设定羽化程度为10*/ctx.shadowBlur=10;/*指定阴影的水平偏移量和垂直偏移量*/ctx.shadowOffsetX=20; ctx.shadowOffsetY=30;var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,0,0);  };  &lt;/script&gt;</code></pre><h2 id="三、致谢"><a href="#三、致谢" class="headerlink" title="三、致谢"></a><label style="color:orange">三、致谢</label></h2><p>本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第三章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励!</p><p>本章内容将会在下一篇进行一个实战，制作一个简单的自定义画板。</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5-Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5-Canvas的基本功能</title>
      <link href="/2019/08/16/HTML5-Canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/16/HTML5-Canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>利用 Canvas 的 API，展示一些基本图形的绘制及操作方法，包括画线、画图、文字操作及图片操作等。（内含代码清单）</p><a id="more"></a><h2 id="一、绘制基本图形"><a href="#一、绘制基本图形" class="headerlink" title="一、绘制基本图形"></a><label style="color:orange">一、绘制基本图形</label></h2><h3 id="1-1-画线"><a href="#1-1-画线" class="headerlink" title="1.1 画线"></a>1.1 画线</h3><p><strong>简约版：</strong></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;你的浏览器不支持 HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth = 10;ctx.strokeStyle = &quot;red&quot;;ctx.beginPath();ctx.moveTo(10,10);ctx.lineTo(150,50);ctx.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>注释版：</strong></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;/*在HTML中嵌入Canvas标签，如果浏览器不支持Canvas标签，那么浏览器会自动跳过Canvas标签，运行Canvas内部HTML代码*/&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;你的浏览器不支持 HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;    /*获取HTML中的Canvas标签*/    var c=document.getElementById(&quot;myCanvas&quot;);    /*返回一个用来绘制环境类型的环境，目前只支持2d环境*/     var ctx=c.getContext(&quot;2d&quot;);    /*线宽*/    ctx.lineWidth = 10;    /*笔画颜色，这里颜色值可以是英文字母、RGB值、十六进制颜色*/    ctx.strokeStyle = &quot;red&quot;;    /*线帽有三种，分别是butt、round、square    butt:默认。向线条的每个末端添加平直的边缘。    round:向线条的每个末端添加圆形线帽。    square:向线条的每个末端添加正方形线帽。*/    ctx.lineCup=&quot;butt&quot;;    /*创建一个新路径*/    ctx.beginPath();    /*画笔光标起始位置*/    ctx.moveTo(10,10);    /*画笔光标终止位置*/    ctx.lineTo(150,50);    /*开始绘制定义好的路径*/    ctx.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-画矩形"><a href="#1-2-画矩形" class="headerlink" title="1.2 画矩形"></a>1.2 画矩形</h3><p><strong>空心矩形：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth = 10;ctx.strokeStyle = &quot;red&quot;;ctx.beginPath();/*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ctx.strokeRect(10,10,70,40);&lt;/script&gt;</code></pre><p>注：<code>ctx.strokeRect(10,10,70,40);</code>等价于<code>ctx.rect(10,10,70,40);ctx.stroke();</code></p><p><strong>实心矩形：</strong></p><pre><code>/*使用fillRect函数*/&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;red&quot;;ctx.beginPath();/*用strokeRect函数绘制矩形，四个参数：起点坐标x、起点坐标y、矩形长、矩形宽*/ctx.fillRect(10,10,70,40);&lt;/script&gt;</code></pre><p>注：<code>ctx.fillRect(10,10,70,40);</code>等价于<code>ctx.rect(10,10,70,40);ctx.fill();</code></p><h3 id="1-3-画圆"><a href="#1-3-画圆" class="headerlink" title="1.3 画圆"></a>1.3 画圆</h3><p>圆其实就是360度的圆弧。在Canvas中，可使用arc函数来画一个圆弧。</p><p><strong>空心圆：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth = 5;ctx.strokeStyle = &quot;red&quot;;ctx.beginPath();/*用arc函数绘制圆弧，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ctx.arc(100,100,70,0,360*Math.PI/180,true);ctx.stroke();&lt;/script&gt;</code></pre><p><strong>实心圆：</strong></p><pre><code>/*使用fill函数*/&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth = 5;ctx.strokeStyle = &quot;red&quot;;ctx.beginPath();/*用arc函数绘制矩形，六个参数：圆弧中心坐标x、圆弧中心坐标y、圆弧半径、起始角度、终止角度（要转化成弧度）、是否逆时针*/ctx.arc(100,100,70,0,360*Math.PI/180,true);ctx.fill();&lt;/script&gt;</code></pre><h3 id="1-4-圆角矩形"><a href="#1-4-圆角矩形" class="headerlink" title="1.4  圆角矩形"></a>1.4  圆角矩形</h3><p>Canvas中没有直接画圆角矩形的API，但是我么可以用arcTo函数完成圆角的绘制，然后结合直线绘制，就可以完成圆角矩形的绘制了。</p><p><strong>绘制一个圆角：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(70,20);/*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ctx.arcTo(120,30,120,70,50);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p><strong>绘制圆角矩形：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.moveTo(40,20);ctx.lineTo(100,20);/*用arcTo函数为当前的子路径添加一条圆弧。5个参数：P1坐标x、P1坐标y、P2坐标x、P2坐标y、圆弧半径*/ctx.arcTo(120,20,120,40,20);ctx.lineTo(120,70);ctx.arcTo(120,90,100,90,20);ctx.lineTo(40,90);ctx.arcTo(20，90，20，70，20);ctx.lineTo(20，40);ctx.arcTo(20，20，40，20，20);ctx.stroke();&lt;/script&gt;</code></pre><h3 id="1-5-擦除Canvas画板"><a href="#1-5-擦除Canvas画板" class="headerlink" title="1.5 擦除Canvas画板"></a>1.5 擦除Canvas画板</h3><p>使用clearRect函数擦除一个矩形区域。他需要4个参数：起点坐标x、坐标y、擦除区域的长和宽。</p><p><strong>绘制一个红色实心矩形，再擦除一个50*50的小矩形：</strong></p><pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;你的浏览器不支持 HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;red&quot;;ctx.beginPath();ctx.fillRect(10,10,200,100);ctx.clearRect(30,30,50,50);ctx.stroke();&lt;/script&gt;</code></pre><h2 id="二、绘制复杂图形"><a href="#二、绘制复杂图形" class="headerlink" title="二、绘制复杂图形"></a><label style="color:orange">二、绘制复杂图形</label></h2><h3 id="2-1-画曲线"><a href="#2-1-画曲线" class="headerlink" title="2.1 画曲线"></a>2.1 画曲线</h3><p><strong>二次贝塞尔曲线：</strong></p><p>二次贝塞尔曲线有一个控制点，再Canvas中用quadraticCurveTo(cpx,cpy,x,y)函数绘制。cpx,cpy表示控制点的坐标，x，y表示终点坐标。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();ctx.moveTo(100,100);ctx.quadraticCurveTo(20,50,200,20);ctx.stroke();&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt></p><p><strong>三次贝塞尔曲线：</strong></p><p>二次、三次贝塞尔曲线的区别在于三次的有两个控制点。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;);ctx.moveTo(68，130);var cX1 = 20;var cY1 = 10;var cX2 = 268;var cY2 = 10;var endX = 268;var endY = 170;ctx.bezierCurveTo(cX1,cY1,cX2,cY2,endC,endY);ctx.stroke();&lt;/script&gt;</code></pre><h3 id="2-2-利用clip在指定区域绘图"><a href="#2-2-利用clip在指定区域绘图" class="headerlink" title="2.2 利用clip在指定区域绘图"></a>2.2 利用clip在指定区域绘图</h3><p>clip函数使用当前路径作为绘制操作的剪辑区域。可以理解为窗户，不论绘制了多大的图形，最后看到的图像只能由clip这扇窗来决定。</p><p><strong>先画圆，使用clip，再画矩形，最后只能看到圆</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.arc(100,100,40,0,360*Math.PI/180,true);ctx.clip();ctx.beginPath();//设定颜色ctx.fillStyle=&quot;lightblue&quot;;//绘制矩形ctx.fillRect(0,0,300,150);&lt;/script&gt;</code></pre><h3 id="2-3-绘制自定义图形"><a href="#2-3-绘制自定义图形" class="headerlink" title="2.3 绘制自定义图形"></a>2.3 绘制自定义图形</h3><p><strong>结合各种方法，绘制特殊图形，例如：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath(); ctx.moveTo(100, 150);   ctx.bezierCurveTo(50, 100, 100, 0, 150, 50);   ctx.bezierCurveTo(200, 0, 250, 100, 200, 150);  ctx.bezierCurveTo(250, 200, 200, 300, 150, 250);  ctx.bezierCurveTo( 100, 300, 50, 200,100, 150);    ctx.closePath(); ctx.moveTo(100, 150);ctx.lineTo(150, 50); ctx.lineTo(200, 150); ctx.lineTo(150, 250); ctx.lineTo(100, 150); ctx.lineWidth = 5;   ctx.strokeStyle = &quot;#ff0000&quot;;   ctx.stroke();   &lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E7%89%B9%E6%AE%8A%E5%9B%BE%E5%BD%A2.png" alt></p><h2 id="三、绘制文本"><a href="#三、绘制文本" class="headerlink" title="三、绘制文本"></a><label style="color:orange">三、绘制文本</label></h2><h3 id="3-1-绘制文字"><a href="#3-1-绘制文字" class="headerlink" title="3.1 绘制文字"></a>3.1 绘制文字</h3><p><strong>使用fillText绘制实心文字</strong></p><p>fillText(text,x,y,max Width)函数，4各参数分别是：文本字符串、坐标x、坐标y、文本宽度。其中文本宽度可以省略，当其省略时，文本宽度会自动定为整个文本的宽度。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);//设定文字大小和字体ctx.font=&quot;30px Arial&quot;;//描画文字ctx.fillText(&quot;Hello World&quot;,100,50);//或添加文本宽度参数：//ctx.fillText(&quot;Hello World&quot;,100,50,50);&lt;/script&gt;</code></pre><p><strong>使用strokeText绘制空心文字：</strong><br>strokeText与fillText用法相同，只是fillText为实心文字，strokeText为空心文字</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);//设定文字大小和字体ctx.font=&quot;30px Arial&quot;;//描画文字ctx.strokeText(&quot;Hello World&quot;,100,50);&lt;/script&gt;</code></pre><h3 id="3-2-文字设置"><a href="#3-2-文字设置" class="headerlink" title="3.2 文字设置"></a>3.2 文字设置</h3><h5 id="3-2-1-文字大小"><a href="#3-2-1-文字大小" class="headerlink" title="3.2.1 文字大小"></a>3.2.1 文字大小</h5><p>使用font参数：例如：ctx.font=”50px Arial”;</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();//设定文字大小为30pxctx.font=&quot;30px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,100,50);ctx.beginPath();//设定文字大小为50pxctx.font=&quot;50px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,100,150);ctx.beginPath();//设定文字大小为100pxctx.font=&quot;70px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,100,250);&lt;/script&gt;</code></pre><h5 id="3-2-2-文字字体"><a href="#3-2-2-文字字体" class="headerlink" title="3.2.2 文字字体"></a>3.2.2 文字字体</h5><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();//设定文字字体为Arialctx.font=&quot;30px Arial&quot;;ctx.fillText(&quot;Hello World (Arial)&quot;,50,50);ctx.beginPath();//设定文字字体为Verdanactx.font=&quot;30px Verdana&quot;;ctx.fillText(&quot;Hello World (Verdana)&quot;,50,100);ctx.beginPath();//设定文字字体为Times New Romanctx.font=&quot;30px Times New Roman&quot;;ctx.fillText(&quot;Hello World (Times New Roman)&quot;,50,150);ctx.beginPath();//设定文字字体为Courier Newctx.font=&quot;30px Courier New&quot;;ctx.fillText(&quot;Hello World (Courier New)&quot;,50,200);ctx.beginPath();//设定文字字体为serifctx.font=&quot;30px serif&quot;;ctx.fillText(&quot;Hello World (serif)&quot;,50,250);ctx.beginPath();//设定文字字体为sans-serifctx.font=&quot;30px sans-serif&quot;;ctx.fillText(&quot;Hello World (sans-serif)&quot;,50,300);&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%96%87%E5%AD%97%E5%AD%97%E4%BD%93.png" alt></p><h5 id="3-2-3-文字粗体效果"><a href="#3-2-3-文字粗体效果" class="headerlink" title="3.2.3 文字粗体效果"></a>3.2.3 文字粗体效果</h5><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();//设定font-weight为normalctx.font=&apos;normal 30px Arial&apos;;ctx.fillText(&quot;Hello World (normal)&quot;,50,50);ctx.beginPath();//设定font-weight为bold ctx.font=&apos;bold 30px Arial&apos;;ctx.fillText(&quot;Hello World (bold)&quot;,50,90);ctx.beginPath();//设定font-weight为bolderctx.font=&apos;bolder 30px Arial&apos;;ctx.fillText(&quot;Hello World (bolder)&quot;,50,130);ctx.beginPath();//设定font-weight为lighterctx.font=&apos;lighter 30px Arial&apos;;ctx.fillText(&quot;Hello World (lighter)&quot;,50,170);ctx.beginPath();//设定font-weight为100ctx.font=&apos;100 30px Arial&apos;;ctx.fillText(&quot;Hello World (100)&quot;,50,210);ctx.beginPath();//设定font-weight为600ctx.font=&apos;600 30px Arial&apos;;ctx.fillText(&quot;Hello World (600)&quot;,50,250);ctx.beginPath();//设定font-weight为900ctx.font=&apos;900 30px Arial&apos;;ctx.fillText(&quot;Hello World (900)&quot;,50,290);&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%AD%97%E4%BD%93%E7%B2%97%E7%BB%86.png" alt></p><h5 id="3-2-4-文字斜体效果"><a href="#3-2-4-文字斜体效果" class="headerlink" title="3.2.4 文字斜体效果"></a>3.2.4 文字斜体效果</h5><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.beginPath();//设定font-weight为normalctx.font=&apos;normal 30px Arial&apos;;ctx.fillText(&quot;Hello World (normal)&quot;,50,50);ctx.beginPath();//设定font-style为italic ctx.font=&apos;italic 30px Arial&apos;;ctx.fillText(&quot;Hello World (italic)&quot;,50,90);ctx.beginPath();//设定font-style为obliquectx.font=&apos;oblique 30px Arial&apos;;ctx.fillText(&quot;Hello World (oblique)&quot;,50,130);&lt;/script&gt;</code></pre><h3 id="3-3-文字的对齐效果"><a href="#3-3-文字的对齐效果" class="headerlink" title="3.3 文字的对齐效果"></a>3.3 文字的对齐效果</h3><h5 id="3-3-1-水平对齐"><a href="#3-3-1-水平对齐" class="headerlink" title="3.3.1 水平对齐"></a>3.3.1 水平对齐</h5><pre><code>&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.moveTo(160,0);ctx.lineTo(160,300);ctx.stroke();ctx.beginPath();ctx.textAlign=&apos;start&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&quot;Hello World&quot;,160,50);ctx.beginPath();ctx.textAlign=&apos;end&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&quot;Hello World&quot;,160,100);ctx.beginPath();ctx.textAlign=&apos;left&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&quot;Hello World&quot;,160,150);ctx.beginPath();ctx.textAlign=&apos;center&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&quot;Hello World&quot;,160,200);ctx.beginPath();ctx.textAlign=&apos;right&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&quot;Hello World&quot;,160,250);&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90.png" alt></p><h5 id="3-3-2-竖直对齐"><a href="#3-3-2-竖直对齐" class="headerlink" title="3.3.2 竖直对齐"></a>3.3.2 竖直对齐</h5><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&apos;myCanvas&apos;);var ctx=c.getContext(&apos;2d&apos;);ctx.textBaseline=&apos;alphabetic&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,50);ctx.moveTo(0,50);ctx.lineTo(250,50);ctx.stroke();ctx.textBaseline=&apos;bottom&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,100);ctx.moveTo(0,100);ctx.lineTo(250,100);ctx.stroke();ctx.textBaseline=&apos;hanging&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,150);ctx.moveTo(0,150);ctx.lineTo(250,150);ctx.stroke();ctx.textBaseline=&apos;ideographic&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,200);ctx.moveTo(0,200);ctx.lineTo(250,200);ctx.stroke();ctx.textBaseline=&apos;middle&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,250);ctx.moveTo(0,250);ctx.lineTo(250,250);ctx.stroke();ctx.textBaseline=&apos;top&apos;;ctx.font=&apos;30px Arial&apos;;ctx.fillText(&apos;Hello World&apos;,50,300);ctx.moveTo(0,300);ctx.lineTo(250,300);ctx.stroke();&lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%96%87%E5%AD%97%E7%AB%96%E7%9B%B4%E6%96%B9%E5%90%91%E5%AF%B9%E9%BD%90.png" alt></p><h2 id="四、图片操作"><a href="#四、图片操作" class="headerlink" title="四、图片操作"></a><label style="color:orange">四、图片操作</label></h2><h3 id="4-1-利用drawImage绘制图片"><a href="#4-1-利用drawImage绘制图片" class="headerlink" title="4.1 利用drawImage绘制图片"></a>4.1 利用drawImage绘制图片</h3><p>drawImage函数有3种函数原型，语法如下：</p><p>drawImages（image，dx, dy）;<br>drawImages（image，dx, dy, dw, dh）;<br>drawImages（image，sx, sy, sw, sh, dx, dy, dw, dh）;</p><ul><li>image是要绘制的对象，可以说HTMLImageRlement、HTML-CanvasElement或者HTMLVideoElement</li><li>dx、dy是image在Canvas中定位的坐标值</li><li>dw、dh表示image在Canvas中即将绘制区域（相对dx、dy坐标的偏移量）的宽度与高度值</li><li>sx、sy是image所要绘制的起始位置</li><li>sw、sh表示image所要绘制区域（相对sw、sy坐标的偏移量）的宽度与高度值</li></ul><p><strong>方式1：在Canvas中通过<img>标签的id取得图片数据</strong></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;img标签&lt;br /&gt;&lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt;canvas画板&lt;br /&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;你的浏览器不支持HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;face&quot;);img.onload = function(){       ctx.drawImage(img,10,10);   };   &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>步骤1：在html中加入<img>标签</p><p><code>&lt;img id=&quot;face&quot; src=&quot;face.jpg&quot; alt=&quot;The Face&quot; width=&quot;240&quot; height=&quot;240&quot; /&gt;&lt;br /&gt;</code></p><p>步骤2：在Canvas中通过<img>标签的id取得图片数据</p><p><code>var img=document.getElementById(&quot;face&quot;);</code></p><p>步骤3：用drawImage函数江图片绘制到画板上</p><p><code>ctx.drawImage(img,10,10);</code></p><p><strong>方式2：在Canvas中通过 JavaScript 的 Image 对象来获取数据（个人推荐这种）</strong></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;你的浏览器不支持HTML5&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){       ctx.drawImage(image,10,10);   };    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>步骤1：建立image对象</p><p><code>var image = new Image();</code></p><p>步骤2：通过设置scr属性，载入图片</p><p><code>image.src = &quot;face.jpg&quot;;</code></p><p>步骤3：添加onload事件侦听，当图片载入完成时，将其绘制到画板</p><pre><code>image.onload = function(){       ctx.drawImage(image,10,10);   }; </code></pre><p><strong>drawImage函数的3种函数原型的用法与区别：</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){       /*从坐标（10，10）开始绘制整张图片*/     ctx.drawImage(image,10,10);      /*从坐标（260，10）开始绘制整张图片到长100、宽100的矩形区域内*/    ctx.drawImage(image,260,10,100,100);     /*截取图片从（50，50）到（100，100）的部分，从坐标（260，130开始绘制，放大长100，宽100的矩形区域内）*/    ctx.drawImage(image,50,50,100,100,260,130,100,100);   };    &lt;/script&gt;</code></pre><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86.png" alt></p><h3 id="4-2-利用getImageData和putImageData绘制图片（不推荐）"><a href="#4-2-利用getImageData和putImageData绘制图片（不推荐）" class="headerlink" title="4.2 利用getImageData和putImageData绘制图片（不推荐）"></a>4.2 利用getImageData和putImageData绘制图片（不推荐）</h3><p>putImageData（imagedata，dx, dy, sx, sy, sw, sh）</p><ul><li>imagedata为像素数据</li><li>dx、dy是绘制图片的定位坐标值</li><li>sx、sy是imagedata所要绘制图片的起始位置</li><li>sw、sh表示imagedata所要绘制区域（相对imagedata的sx、sy坐标的偏移量）的宽度与高度值</li></ul><p>这里第四个参数及以后的所有参数都可以省略，如果省略则表示绘制整个imagedata。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,10,10);      var imgData=ctx.getImageData(50,50,200,200);    ctx.putImageData(imgData,10,260);     ctx.putImageData(imgData,200,260,50,50,100,100);};    &lt;/script&gt;</code></pre><p>步骤1：图片数据读取完成后，首先江图片数据绘制到Canvas画板上</p><p><code>ctx.drawImage(image,10,10);</code></p><p>步骤2：用getImageData函数从画板上取得像素数据</p><p><code>var imgData=ctx.getImageData(50,50,200,200);</code></p><p>步骤3：将取得的整个像素数据绘制到画板上</p><p><code>ctx.putImageData(imgData,10,260);</code></p><p>或将取得的整个像素数据的一部分绘制到画板上</p><p><code>ctx.putImageData(imgData,200,260,50,50,100,100);</code></p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%862.png" alt></p><p><strong>注意：</strong>这种方法种使用了getImageData函数获取图片数据，这个函数在Google Chrome等浏览器中会涉及跨域问题，所以无法直接在浏览器种浏览。必须通过服务器来访问。当然，我么可以在本地服务器是浏览。</p><h3 id="4-3-利用createImageData新建像素"><a href="#4-3-利用createImageData新建像素" class="headerlink" title="4.3 利用createImageData新建像素"></a>4.3 利用createImageData新建像素</h3><p>createImageData函数有两种函数原型：</p><ol><li>返回指定大小的imageData对象：</li></ol><p><code>createImageData（sw, sh）;</code></p><ol start="2"><li>返回与指定对象相同大小的imageData对象</li></ol><p><code>createImageData(imageData);</code></p><p><strong>注意：通过createImageData返回的是一个空的imageData对象，必须要针对起像素进行复制才能显示到Canvas 画板上</strong></p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var image = new Image();    image.src = &quot;face.jpg&quot;;  image.onload = function(){        ctx.drawImage(image,10,10);      var imgData=ctx.getImageData(50,50,200,200);    var imgData01=ctx.createImageData(imgData);    for (i=0; i&lt;imgData01.width*imgData01.height*4;i+=4){        imgData01.data[i+0]=255;        imgData01.data[i+1]=0;        imgData01.data[i+2]=0;        imgData01.data[i+3]=255;    }    ctx.putImageData(imgData01,10,260);     var imgData02=ctx.createImageData(100,100);    for (i=0; i&lt;imgData02.width*imgData02.height*4;i+=4){        imgData02.data[i+0]=255;        imgData02.data[i+1]=0;        imgData02.data[i+2]=0;        imgData02.data[i+3]=155;    }    ctx.putImageData(imgData02,220,260); };    &lt;/script&gt;</code></pre><p><strong>代码解析：</strong></p><ol><li><p>图片数据读取完成后，首先将图片数据绘制到 Canvas 画板上。</p><p> <code>ctx.drawImage(image,10,10);</code></p></li><li><p>用 getImageData 函数从画板上取得像素数据。</p><p> <code>var imgData=ctx.getImageData(50,50,200,200);</code></p></li><li><p>使用 createImageData 返回与 imgData 相同大小的 ImageData 对象。</p><p> <code>var imgData01=ctx.createImageData(imgData);</code></p></li><li><p>imgData01 进行赋值。</p><p> for (i=0; i&lt;imgData01.width<em>imgData01.height</em>4;i+=4){<br>  imgData01.data[i+0]=255;<br>  imgData01.data[i+1]=0;<br>  imgData01.data[i+2]=0;<br>  imgData01.data[i+3]=255;<br> }</p></li><li><p>利用 putImageData 将 imgData01 画到 Canvas 画板上。</p><p> <code>ctx.putImageData(imgData01,10,260);</code></p></li><li><p>使用 createImageData 返回一个大小为 100×100 的 ImageData 对象。</p><p> <code>var imgData02=ctx.createImageData(100,100);</code></p></li><li><p>对 imgData02 进行赋值。</p><p> for (i=0; i&lt;imgData02.width<em>imgData02.height</em>4;i+=4){<br>  imgData02.data[i+0]=255;<br>  imgData02.data[i+1]=0;<br>  imgData02.data[i+2]=0;<br>  imgData02.data[i+3]=155;<br> }</p></li><li><p>利用 putImageData 将 imgData02 画到 Canvas 画板上。</p><p> <code>ctx.putImageData(imgData02,220,260);</code></p></li></ol><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%863.png" alt></p><h2 id="五、致谢"><a href="#五、致谢" class="headerlink" title="五、致谢"></a><label style="color:orange">五、致谢</label></h2><p>写这篇学习总结的时候是学校开学的前夕，实验室还没有人。早上我给自己泡了一杯茶，累了就去弹两首古琴曲子然后继续回来学。这篇总结写完的时候，太阳的余辉正撒在我的书桌上。我抬头望着窗外的云朵，好像忽然懂了《时光恋旅人》里主角父亲穿越时空一遍遍看书的感受了，哈哈哈，在时空隧道里，想来我一个人也可以相处的很愉快吧。</p><p>本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第二章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5-Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的面向对象</title>
      <link href="/2019/08/16/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/16/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>可以说，JavaScript 是一种基于对象的语言，但是，它又不是一种真正的面向对象的编程语言，因为它的语法中不存在 class（类）。</p><p>本节将分析和解决如何在 JavaScript 中实现封装和继承等面向对象的问题。</p><a id="more"></a><h2 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a><label style="color:orange">一、类</label></h2><p>一个没有任何属性和方法的<strong>类的定义：</strong></p><pre><code>function MyClass(){};</code></pre><p>其实这就是个简单函数的声明，这个函数就是一个类的定义的实现。</p><p><strong>使用这个类：</strong></p><pre><code>var cls1 = new MyClass();</code></pre><p>这样，利用 new 就可以生成 MyClass的一个实例了。</p><blockquote><p>所以，在JavaScript中，可以说函数就是类，类就是函数。</p></blockquote><p><strong>一个实例的封装包含属性和方法的封装：</strong></p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;};var cls1 = new MyClass(&quot;yf&quot;,18);alert(cls1.name + &quot;:&quot; + cls1.age);//[yf:18]</code></pre><p>在函数内使用 this 就能给函数本身增加属性值。上面的代码中就给 MyClass 函数增加了 name 和 age 两个属性。</p><p><strong>利用this给这个类增加一个toString 方法：</strong></p><p>方式1：</p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;    this.toString() = function(){        alert(this.name + &quot;:&quot; + this.age);        };    };var cls1 = new MyClass(&quot;yf&quot;,18);cls1.toString();//[yf:18]</code></pre><p>方式2（这种方式只是给 cls1 这个实例增加了方法，并未给 MyClass 本身增加方法。）：</p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;};var cls1 = new MyClass(&quot;yf&quot;,18);cls1.toString() = function(){    alert(this.name + &quot;:&quot; + this.age);};cls1.toString();//[yf:18]</code></pre><p>比如，使用方式2时下面的代码会出错 ：</p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;};var cls1 = new MyClass(&quot;yf&quot;,18);cls1.toString() = function(){    alert(this.name + &quot;:&quot; + this.age);};cls1.toString();//[yf:18]var cls2 = new MyClass(&quot;cx&quot;,19);cls2.toString();// 报错</code></pre><p><strong>使用函数的prototype对象来添加方法：</strong></p><p>每一个函数都会包含一个 prototype 属性，这个属性指向了一个 prototype 对象，我们可以指定函数对应的 prototype 对象。如果不指定，则函数的 prototype 属性将指向一个默认的 prototype 对象，并且此默认 prototype 对象的 constructor 属性又会指向该函数。</p><p>当用构造函数创建一个新的对象时，新的对象会获取构造函数的 prototype 属性所指向的 prototype 对象的所有属性和方法，这样一来，构造函数对应的 prototype 对象所做的任何操作都会反映到它所生成的对象上，所有的这些对象将共享与构造函数对应的 prototype 对象的属性和方法。</p><p>虽然新创建的对象可以使用它的构造函数所指向的 prototype 对象的属性和方法，但不能像构造函数那样直接调用 prototype 对象（对象没有 prototype 属性）。</p><blockquote><p>简而言之，如果我么使用函数的prototype对象来给函数添加方法，那么创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这个函数的所有方法。</p></blockquote><p>具体代码：</p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;}MyClass.prototype.toString = function(){    alert(this.name + &quot;:&quot; + thus.age);}var cls1 = new MyClass(&quot;yf&quot;,18);clas1.toString();//[yf:18]var cls2 = new MyClass(&quot;cx&quot;,19);clas2.toString();//[cx:19]</code></pre><p>对于prototype对象来说，由于存在的是指向的关系，所以避免了不必要的浪费。<img src="http://pvjdnjjsz.bkt.clouddn.com/prototype%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E5%9B%BE.png" alt="prototype属性说明图"></p><p>如果要加入多个方法，可以用下面的方式实现封装：</p><pre><code>function MyClass(name,age){    this.name = name;    this.age = age;}MyClass.prototype = {    toString:function(){        alert(this.name + &quot;:&quot; + thus.age);    };    sayHello:function(){        alert(this.name + &quot;,你好!&quot;);    };}var cls1 = new MyClass(&quot;yf&quot;,18);cls1.toString();//[yf:18]cls1.sayHellow ();//[yf, 你好!]</code></pre><h2 id="二、静态类"><a href="#二、静态类" class="headerlink" title="二、静态类"></a><label style="color:orange">二、静态类</label></h2><p>其实，下面的函数本身就可以当作静态类来用 ：</p><pre><code>var StaticClass = function(){};StaticClass.name = &quot;StaticName&quot;;StaticClass.Sum = function(value1,value2){    return value1 + value2;};alert(StaticClass.name);//[StaticName]alert(StaticClass.Sum(1,3));//[4]</code></pre><p>这样，在使用静态类的时候，就无须创建新的实例了，可直接用“类名 + 点 + 属性或方<br>法”的方式。</p><h2 id="三、继承"><a href="#三、继承" class="headerlink" title="三、继承"></a><label style="color:orange">三、继承</label></h2><p>上面只讲了类的封装，那么如何实现类的继承呢？如有如下两个构造函数 ：</p><pre><code>function PeopleClass(){    this.type = &quot; 人 &quot;;};PeopleClass.prototype = {    getType:function(){    alert(&quot; 这是一个人 &quot;);    }};function StudentClass(name,sex){    this.name = name;    this.sex = sex;};</code></pre><p><strong>属性的继承：使用 apply 方法将父对象的构造函数绑定在子对象上</strong></p><pre><code>function PeopleClass(){    this.type = &quot; 人 &quot;;};PeopleClass.prototype = {    getType:function(){    alert(&quot; 这是一个人 &quot;);    }};function StudentClass(name,sex){    PeopleClass.apply(this, arguments);    this.name = name;    this.sex = sex;};var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;);alert(stu.type);//[ 人 ]</code></pre><p>从运行结果来看，StudentClass 继承了 PeopleClass 的属性“人”。</p><p><strong>方法的继承：循环使用父对象的 prototype 进行复制</strong></p><pre><code>function PeopleClass(){    this.type = &quot; 人 &quot;;};PeopleClass.prototype = {    getType:function(){    alert(&quot; 这是一个人 &quot;);    }};function StudentClass(name,sex){    PeopleClass.apply(this, arguments);var prop;for(prop in PeopleClass.prototype){    var proto = this.constructor.prototype;    if(!proto[prop]){        proto[prop] = PeopleClass.prototype[prop];    }    proto[prop][&quot;super&quot;] = PeopleClass.prototype;            }    this.name = name;    this.sex = sex;};var stu = new StudentClass(&quot;yf&quot;,&quot; 女 &quot;);alert(stu.type);//[ 人 ]stu.getType();//[ 这是一个人 ]</code></pre><h2 id="三、致谢"><a href="#三、致谢" class="headerlink" title="三、致谢"></a><label style="color:orange">三、致谢</label></h2><p>本文内容是我对张路斌老师《HTML5 Canvas 游戏开发实战》第一章的学习总结，感谢张路斌老师，也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的代码清单</title>
      <link href="/2019/08/15/HTML5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95/"/>
      <url>/2019/08/15/HTML5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>HTML5 有很多令人心动的特性和新功能，这里罗列了一些HTML5新特性的示例代码。包含使用 video 标签播放动画、使用 audio 标签播放音频、使用 Canvas 标签绘制图形、取得当前的位置、将大量的数据保存在客户端、form 的强化</p><a id="more"></a><h2 id="一、HTML5新特性"><a href="#一、HTML5新特性" class="headerlink" title="一、HTML5新特性"></a><label style="color:orange">一、HTML5新特性</label></h2><ol><li><p>强化了Web网页的表现性能，增加了本地数据库等 Web 应用的功能，以及图像操作等。</p></li><li><p>HTML5 在图像上引入了 Canvas 标签，通过 Canvas，用户可以动态生成各种图形图像、图表以及动画，而不再依赖于 Flash、silverlight 等插件了。</p></li><li><p>HTML5 在地理位置操作上引入了 Geolocation API，其特点在于 ：</p><ul><li><p>本身不去获取用户的位置，而是通过第三方接口来获取，例如 IP、GPS、WIFI 等方式。</p></li><li><p>用户可以随时开启和关闭，在被程序调用时也会首先征得用户同意，保证了用户的隐私。</p></li></ul></li><li><p>HTML5 还在数据储存上增加了本地数据库，可以使用 WebSQL 来储存数据，并且引入了 web storage API 实现了离线缓存功能，以此替代了 cookies，使得数据保存空间更<br>大、更安全。</p></li></ol><h2 id="二、HTML5新特性代码清单"><a href="#二、HTML5新特性代码清单" class="headerlink" title="二、HTML5新特性代码清单"></a><label style="color:orange">二、HTML5新特性代码清单</label></h2><h3 id="2-1-使用-video-标签播放动画"><a href="#2-1-使用-video-标签播放动画" class="headerlink" title="2.1  使用 video 标签播放动画"></a>2.1  使用 video 标签播放动画</h3><pre><code>/*这段代码可以实现播放动画功能*/&lt;video width=&quot;640&quot; height=&quot;360&quot; preload=&quot;auto&quot; poster=&quot;hoge.png&quot; controls autoplay&gt;&lt;!-- 针对播放 webm 格式动画的浏览器 --&gt;&lt;source src=&quot;hoge.webm&quot; type=&apos;video/webm; codecs=&quot;vp8, vorbis&quot;&apos;&gt;&lt;!-- 针对播放 ogv 格式动画的浏览器 -&gt;&lt;source src=&quot;hoge.ogv&quot; type=&apos;video/ogg; codecs=&quot;theora, vorbis&quot;&apos;&gt;&lt;!-- 针对播放 mp4 格式动画的浏览器 --&gt;&lt;source src=&quot;hoge.mp4&quot; type=&apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt;&lt;!-- 当浏览器无法使用 video 标签的时候 --&gt;&lt;p&gt; 无法播放动画。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt;&lt;/video&gt;</code></pre><h3 id="2-2-使用-audio-标签播放音频"><a href="#2-2-使用-audio-标签播放音频" class="headerlink" title="2.2 使用 audio 标签播放音频"></a>2.2 使用 audio 标签播放音频</h3><pre><code>/*这段代码可以实现音频播放功能*/&lt;audio controls loop&gt;&lt;!-- 针对播放 ogg 格式音频的浏览器 --&gt;&lt;source src=&quot;hoge.ogg&quot;&gt;&lt;!-- 针对播放 wav 格式音频的浏览器 --&gt;&lt;source src=&quot;hoge.wav&quot;&gt;&lt;!-- 针对播放 mp3 格式音频的浏览器 --&gt;&lt;source src=&quot;hoge.mp3&quot;&gt;&lt;!-- 当浏览器无法使用 audio 标签的时候 --&gt;&lt;p&gt; 无法播放音频。&lt;a href=&quot;hoge.html&quot;&gt; 推荐环境请看这里。&lt;/a&gt;&lt;/p&gt;&lt;/audio&gt;</code></pre><h3 id="2-3-使用-Canvas-标签绘制图形"><a href="#2-3-使用-Canvas-标签绘制图形" class="headerlink" title="2.3 使用 Canvas 标签绘制图形"></a>2.3 使用 Canvas 标签绘制图形</h3><p>使用 Canvas 标签，只需要向 HTML5 里添加 Canvas 元素即可，代码如下 ：</p><pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</code></pre><p>另外，Canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript<br>内部完成。使用案例如下：</p><p>案例一：</p><pre><code>/*这段代码可以绘制一个矩形*/&lt;canvas id=&quot;canvas&quot; width=&quot;640&quot; height=&quot;360&quot;&gt;&lt;/canvas&gt;&lt;script&gt;// 获取 context 对象var canvas = document.getElementById(&apos;canvas&apos;); if(canvas.getContext){ var context = canvas.getContext(&apos;2d&apos;);  // 设置颜色context.fillStyle = &apos;rgb(255,0,0)&apos;;  // 从坐标 (20,30) 开始，画一个 64×36 大小的矩形context.fillRect(20,30,64,36); } &lt;/script&gt;</code></pre><p>案例二:</p><pre><code>/*这段代码可以须在 JavaScript 内部实现绘制一个矩形*/onload = function() { draw();};function draw() { /* 使用 id 来寻找 Canvas 元素 */ var canvas = document.getElementById(&apos;canvassample&apos;); /* 验证 Canvas 元素是否存在，以及浏览器是否支持 Canvas 元素 */ if ( ! canvas || ! canvas.getContext ) return false; /* 创建 context 对象 */ var ctx = canvas.getContext(&apos;2d&apos;); /* 画一个红色矩形 */ cxt.fillStyle=&quot;#FF0000&quot;; cxt.fillRect(0,0,150,75);}</code></pre><h3 id="2-4-轻松取得当前的位置"><a href="#2-4-轻松取得当前的位置" class="headerlink" title="2.4  轻松取得当前的位置"></a>2.4  轻松取得当前的位置</h3><pre><code>/*这段代码可以获取当前位置的纬度和经度*/&lt;script&gt;window.addEventListener(&apos;load&apos;. function () { // 判断可否使用 geolocationif(navigator.geolocation){ // 定期获取所在地navigator.geolocation.watchPosition(update); } }, false); // 取得位置并表示function update(position){ // 纬度var lat = position.coords.latitude; // 经度var lng = position.coords.longitude; // 把纬度和经度显示出来document.write(&apos; 纬度 ：&apos;+lat+&apos;，经度 ：&apos;+lng); } &lt;/script&gt;</code></pre><h3 id="2-5-将大量的数据保存在客户端"><a href="#2-5-将大量的数据保存在客户端" class="headerlink" title="2.5 将大量的数据保存在客户端"></a>2.5 将大量的数据保存在客户端</h3><pre><code>/*这段代码中的 JavaScript 使用 LocalStorage 来保存大量的数据*/&lt;script&gt;// 用 localStorage 来保存数据localStorage.key = &apos; 想要保存的值 &apos;;// 将 localStorage 中的值取出来var hoge = localStorage.key;//“想要保存的值”在页面上显示document.write(hoge); &lt;/script&gt;</code></pre><h3 id="2-6-form-的强化"><a href="#2-6-form-的强化" class="headerlink" title="2.6     form 的强化"></a>2.6     form 的强化</h3><pre><code>/*这段代码是form 的几个比较常用的功能*/&lt;!-- 验证用户输入格式是否正确，只需要改变 type 的类型即可 --&gt;&lt;input name=&quot;email&quot; type=&quot;email&quot;&gt;&lt;!-- 对于必须输入的项目，只需给 input 标签加上 require 属性即可 --&gt;&lt;input name=&quot;text&quot; type=&quot;text&quot; require&gt;&lt;!-- 当失去焦点的时候给出相应的提示，只需给 input 标签加上 placeholder 属性即可 --&gt;&lt;input name=&quot;text&quot; type=&quot;text&quot; placeholder=&quot; 例 ：姓名 &quot;&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒尺寸四大家族之margin与border</title>
      <link href="/2019/08/15/%E7%9B%92%E5%B0%BA%E5%AF%B8%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F%E4%B9%8Bmargin%E4%B8%8Eborder/"/>
      <url>/2019/08/15/%E7%9B%92%E5%B0%BA%E5%AF%B8%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F%E4%B9%8Bmargin%E4%B8%8Eborder/</url>
      
        <content type="html"><![CDATA[<p>盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！</p><a id="more"></a><h2 id="一、激进的margin属性"><a href="#一、激进的margin属性" class="headerlink" title="一、激进的margin属性"></a><label style="color:orange">一、激进的margin属性</label></h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1565780139522&di=b575402c2cd1462e57aefeed7cb5e333&imgtype=0&src=http%3A%2F%2Fs4.sinaimg.cn%2Fmw690%2F001O8Eu1zy7fhRAYCBl23%26690" alt></p><h3 id="1-1-margin与元素尺寸以及相关布局"><a href="#1-1-margin与元素尺寸以及相关布局" class="headerlink" title="1.1 margin与元素尺寸以及相关布局"></a>1.1 margin与元素尺寸以及相关布局</h3><p>这里的各类“尺寸”命名和对应的盒子类型全部参考自 jQuery 中与尺寸相关 API 的名称。</p><ul><li><p>元素尺寸：对应 jQuery 中的$().width()和$().height()方法，包括 padding<br>和 border，也就是元素的 border box 的尺寸。在原生的 DOM API 中写作 offsetWidth<br>和 offsetHeight，所以，有时候也成为“元素偏移尺寸”。</p></li><li><p>元素内部尺寸：对应 jQuery 中的$().innerWidth()和$().innerHeight()方法，<br>表示元素的内部区域尺寸，包括 padding 但不包括 border，也就是元素的 padding<br>box 的尺寸。在原生的 DOM API 中写作 clientWidth 和 clientHeight，所以，<br>有时候也称为“元素可视尺寸”。</p></li><li><p>元素外部尺寸：对应 jQuery 中的$().outerWidth(true)和$().outerHeight<br>(true)方法，表示元素的外部尺寸，不仅包括 padding 和 border，还包括 margin，<br>也就是元素的 margin box 的尺寸。没有相对应的原生的 DOM API。</p></li></ul><p><strong>注意：</strong>“外部尺寸”有个很不一样的特性，就是尺寸的大小有可能是负数</p><h3 id="1-2-margin的百分比值"><a href="#1-2-margin的百分比值" class="headerlink" title="1.2 margin的百分比值"></a>1.2 margin的百分比值</h3><h3 id="1-3-正确看待CSS世界里的margin合并"><a href="#1-3-正确看待CSS世界里的margin合并" class="headerlink" title="1.3 正确看待CSS世界里的margin合并"></a>1.3 正确看待CSS世界里的margin合并</h3><h3 id="1-4-深入理解CSS中的margin：auto"><a href="#1-4-深入理解CSS中的margin：auto" class="headerlink" title="1.4 深入理解CSS中的margin：auto"></a>1.4 深入理解CSS中的margin：auto</h3><h3 id="1-5-margin无效情形解析"><a href="#1-5-margin无效情形解析" class="headerlink" title="1.5 margin无效情形解析"></a>1.5 margin无效情形解析</h3><h2 id="二、border属性"><a href="#二、border属性" class="headerlink" title="二、border属性"></a><label style="color:orange">二、border属性</label></h2><h3 id="2-1-为什么border-width不支持百分比值"><a href="#2-1-为什么border-width不支持百分比值" class="headerlink" title="2.1 为什么border-width不支持百分比值"></a>2.1 为什么border-width不支持百分比值</h3><h3 id="2-2-了解各种border-style类型"><a href="#2-2-了解各种border-style类型" class="headerlink" title="2.2 了解各种border-style类型"></a>2.2 了解各种border-style类型</h3><h3 id="2-3-border-color和color"><a href="#2-3-border-color和color" class="headerlink" title="2.3 border-color和color"></a>2.3 border-color和color</h3><h3 id="2-4-border与透明边框技巧"><a href="#2-4-border与透明边框技巧" class="headerlink" title="2.4 border与透明边框技巧"></a>2.4 border与透明边框技巧</h3><h3 id="2-5-border与图形构建"><a href="#2-5-border与图形构建" class="headerlink" title="2.5 border与图形构建"></a>2.5 border与图形构建</h3><h3 id="2-6-border等高布局技术"><a href="#2-6-border等高布局技术" class="headerlink" title="2.6 border等高布局技术"></a>2.6 border等高布局技术</h3>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒尺寸四大家族之content与padding</title>
      <link href="/2019/08/13/%E7%9B%92%E5%B0%BA%E5%AF%B8%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F/"/>
      <url>/2019/08/13/%E7%9B%92%E5%B0%BA%E5%AF%B8%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<p>盒尺寸中的4个盒子content box、padding box、border box 和margin box分别对应CSS世界中的content、padding、border和margin属性，这四个属性称为“盒尺寸四大家族”，让我们前去探秘吧！</p><a id="more"></a><h2 id="一、深入理解content"><a href="#一、深入理解content" class="headerlink" title="一、深入理解content"></a><label style="color:orange">一、深入理解content</label></h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1565780139522&di=b575402c2cd1462e57aefeed7cb5e333&imgtype=0&src=http%3A%2F%2Fs4.sinaimg.cn%2Fmw690%2F001O8Eu1zy7fhRAYCBl23%26690" alt></p><h3 id="1-1-content与替换元素"><a href="#1-1-content与替换元素" class="headerlink" title="1.1 content与替换元素"></a>1.1 content与替换元素</h3><h5 id="1-1-1-替换元素"><a href="#1-1-1-替换元素" class="headerlink" title="1.1.1 替换元素"></a>1.1.1 替换元素</h5><blockquote><p>替换元素：通过修改某个属性值呈现的内容就可以被替换的元素。</p></blockquote><p>典型例子：&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;、表单元素&lt;textarea&gt;、&lt;input&gt;、</p><p>替换元素特点：</p><ul><li>内容外观不受页面上的CSS影响</li><li>有自己的尺寸</li><li>在很多CSS属性上有自己的一套变现规则（例如vertical-align属性）</li></ul><h5 id="1-1-2-替换元素的默认dispaly值"><a href="#1-1-2-替换元素的默认dispaly值" class="headerlink" title="1.1.2 替换元素的默认dispaly值"></a>1.1.2 替换元素的默认dispaly值</h5><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4display%E5%B1%9E%E6%80%A72.jpg" alt="替换元素的默认dispaly值"></p><p>用途：显示替换元素时候可以设置style.display=’inline’而无需style.display=’inline-block’。</p><h5 id="1-1-3-替换元素的计算尺寸"><a href="#1-1-3-替换元素的计算尺寸" class="headerlink" title="1.1.3 替换元素的计算尺寸"></a>1.1.3 替换元素的计算尺寸</h5><blockquote><p>替换元素的尺寸从内到外：固有尺寸、HTML尺寸、CSS尺寸</p></blockquote><ul><li><p>固有尺寸：固定大小，例如<code>&lt;input&gt;</code>:<input>，此时的尺寸即为固有尺寸，使用px为单位。</p></li><li><p>HTML尺寸：只能通过HTML原生属性改变。如<code>&lt;img width=&quot;300&quot; height=&quot;100&quot;&gt;</code>:</p>  <img width="300" height="100"></li><li><p>CSS尺寸：通过CSS设置的width和height或者max-width/min-width和max-height/min-height设置的尺寸对应盒尺寸的content box</p></li></ul><p><strong>应用：</strong>Web开发时，为提高加载性能以及节约带宽费用，首屏以下的图片就会通过滚屏加载的形式异步加载，然后，这个即将被异步加载的图片为了布局稳健、体验良好，往往使用一张透明的图片占位。例如</p><pre><code>&lt;img scr=&quot;transparent.png&quot;&gt;</code></pre><p>实际上，这张透明的占位图片也是多余资源，我么直接：</p><pre><code>&lt;img&gt;</code></pre><p>然后配合CSS可以实现一样的效果：</p><pre><code>img { visibility: hidden;      display: inline-block;     }img[scr] {visibility: vidible; }</code></pre><p>注意：这里的<img><strong>直接没有</strong>scr属性，而是scr=””,scr=””这在很多浏览器下依然会有请求，而且请求的是当前页面数据。当图片的scr属性缺省时，图片不会有任何请求，这是最高效的实现方式。</p><h5 id="1-1-4-替换元素与非替换元素"><a href="#1-1-4-替换元素与非替换元素" class="headerlink" title="1.1.4 替换元素与非替换元素"></a>1.1.4 替换元素与非替换元素</h5><p>观点1：他们之间只隔了一个src属性。应用案例：<a href="https://demo.cssworld.cn/4/1-2.php" target="_blank" rel="noopener">基于伪元素的图片内容生成技术</a></p><p>观点2：他们之间只隔了一个CSS content属性。应用案例：<a href="https://demo.cssworld.cn/4/1-4.php" target="_blank" rel="noopener">使用content属性，让普通标签元素变成替换元素</a>；<a href="https://demo.cssworld.cn/4/1-5.php" target="_blank" rel="noopener">完美的文字换图显示方案</a></p><pre><code>HTML：&lt;img class=&quot;emoji&quot; src=&quot;laugh.png&quot;&gt;CSS：.emoji:hover {content: url(laugh-tear.png);}</code></pre><p><strong>注意：</strong>想要在移动端使用该技术，建议换成SVG矢量图片</p><h5 id="1-1-5-content与替换元素关系剖析"><a href="#1-1-5-content与替换元素关系剖析" class="headerlink" title="1.1.5 content与替换元素关系剖析"></a>1.1.5 content与替换元素关系剖析</h5><blockquote><p>在CSS世界，我们把content属性生成的对象称为“匿名替换元素”，content属性生成的内容都是替换元素。</p></blockquote><p>content属性生成的元素和普通元素内容有不同的特性表现：</p><ul><li>使用content生成的文本是无法选择复制的</li><li>不能左右empty伪类（<a href="https://demo.cssworld.cn/4/1-6.php" target="_blank" rel="noopener">案例在此</a>）</li><li>content动态生成值无法获取</li><li>其他略</li></ul><h3 id="1-2-content内容生成技术"><a href="#1-2-content内容生成技术" class="headerlink" title="1.2 content内容生成技术"></a>1.2 content内容生成技术</h3><p>实际项目中，content属性大都是用在：：before/：：after这两个伪元素中，所以“content内容生成技术”有时候也称“：：before/：：after伪元素技术”</p><h5 id="1-2-1-content辅助元素生成"><a href="#1-2-1-content辅助元素生成" class="headerlink" title="1.2.1 content辅助元素生成"></a>1.2.1 content辅助元素生成</h5><p><a href="https://demo.cssworld.cn/4/1-7.php" target="_blank" rel="noopener">案例content辅助元素与布局</a></p><h5 id="1-2-2-content字符内容生成"><a href="#1-2-2-content字符内容生成" class="headerlink" title="1.2.2 content字符内容生成"></a>1.2.2 content字符内容生成</h5><p><a href="https://demo.cssworld.cn/4/1-8.php" target="_blank" rel="noopener">案例配合@font-face规则实现图标字体效果</a></p><p><a href="https://demo.cssworld.cn/4/1-9.php" target="_blank" rel="noopener">案例content换行符与打点loading效果</a></p><h5 id="1-2-3-content图片生成"><a href="#1-2-3-content图片生成" class="headerlink" title="1.2.3 content图片生成"></a>1.2.3 content图片生成</h5><p>伪元素中的图片更多的是使用background-image模拟，类似：</p><pre><code>div：before {    content：‘’;    background： url(1.jpg);}</code></pre><p>content图片生成并不常用，因为不好控制图片尺寸，所以，只有不需要控制尺寸的图片才有优势。<br><a href="https://demo.cssworld.cn/4/1-10.php" target="_blank" rel="noopener">案例content图片生成与新标签页地址标记</a></p><h5 id="1-2-4-content开启闭合图片生成"><a href="#1-2-4-content开启闭合图片生成" class="headerlink" title="1.2.4 content开启闭合图片生成"></a>1.2.4 content开启闭合图片生成</h5><p>可以针对不同语言指定不同的前后引号。但是这个功能很鸡肋，不如直接使用“”‘’方便。</p><pre><code>&lt;p lang=&quot;ch&quot;&gt;&lt;q&gt;中文使用“”&lt;/q&gt;&lt;/p&gt;&lt;p lang=&quot;en&quot;&gt;&lt;q&gt;英文使用&quot;&quot;&lt;/q&gt;&lt;/p&gt;/*为不同的语言指定引号的表现*/：lang(ch) &gt; q { quotes: ‘“’ ‘”’；}：lang(en) &gt; q { quotes: ‘&quot;’ ‘&quot;’；}/*在q标签前后插入引号*/q:before { content: open-quote;}q:after { content: close-quote;}</code></pre><h5 id="1-2-5-content-atter属性值内容生成"><a href="#1-2-5-content-atter属性值内容生成" class="headerlink" title="1.2.5 content atter属性值内容生成"></a>1.2.5 content atter属性值内容生成</h5><p>这个功能比较实用，<a href="https://demo.cssworld.cn/4/1-2.php" target="_blank" rel="noopener">案例src缺省时img元素的alt信息展示</a></p><h5 id="1-2-6-深入了解content计数器"><a href="#1-2-6-深入了解content计数器" class="headerlink" title="1.2.6 深入了解content计数器"></a>1.2.6 深入了解content计数器</h5><p>计数器效果可以说是content部分的重中之重，因为此功能强大、实用、且不具有可替代性，甚至可以实现连JavaScript都实现不好的功能。</p><p>CSS计数器就和我们军训报数一样，班级命名、报数规则、开始报数，这三个关键点刚好对应CSS计数器的两个属性和一个方法。</p><p>1、属性counter-reset（计数器-重置）</p><p>注意：如果不设置，默认起始值为0。</p><pre><code>/*确定计数器名称wangxiaoer，起始值2*/.xxx { counter-reset: wangxiaoer 2;}</code></pre><p>完整案例：</p><p><a href="https://demo.cssworld.cn/4/1-11.php" target="_blank" rel="noopener">CSS计数器counter-reset值为2</a></p><p><a href="https://demo.cssworld.cn/4/1-12.php" target="_blank" rel="noopener">CSS计数器counter-reset两个命名并存</a></p><p>2、属性counter-increment（计数器递增）</p><p>注意：如果不设置，默认变化值为1。</p><pre><code>/*变化的值为2*/counter-increament: counter 2/*变化的值为-1*/counter-increament: counter -1</code></pre><p>CSS计数器的技术规则：普照规则</p><blockquote><p>普照规则:普照源（counter-reset）唯一，每普照（counter-increment）一次，普照源增加一次计数值。</p></blockquote><p>案例：</p><p><a href="https://demo.cssworld.cn/4/1-13.php" target="_blank" rel="noopener">CSS计数器counter-reset/counter-increment递增</a></p><p><a href="https://demo.cssworld.cn/4/1-14.php" target="_blank" rel="noopener">CSS计数器counter-increment父子连续普照与递增</a></p><p><a href="https://demo.cssworld.cn/4/1-15.php" target="_blank" rel="noopener">CSS计数器counter-increment递增机制</a></p><p>3、方法counter（）/counters（）</p><blockquote><p>counter（）作用：显示计数、不过方法、用法多个</p></blockquote><pre><code>/*name是counter-reset的名称，style参数选择递增递减方式*/counter（ name，style）</code></pre><p>style参数的作用是递增递减英文字母或者罗马文等案例：<a href="https://demo.cssworld.cn/4/1-16.php" target="_blank" rel="noopener">CSS计数器counter()方法style参数示意</a></p><p>counter支持级联：一个counter属性值可以有多个counter（）方法，案例：<a href="https://demo.cssworld.cn/4/1-17.php" target="_blank" rel="noopener">CSS计数器多个counter并存</a></p><blockquote><p>counters（）：嵌套技术的代名词。</p></blockquote><pre><code>/*name是counter-reset的名称，string为字符串*/counters（ name，string）/*也支持style*/counters（ name，string, style）</code></pre><p>string为字符串,表示子序号的连接字符串，如1.1的string就是.,案例：<a href="https://demo.cssworld.cn/4/1-18.php" target="_blank" rel="noopener">CSS计数器counters的string参数与嵌套</a></p><p>注意：普照源是唯一的。要想实现嵌套，必须让每一个列表容器拥有一个“普照源”，通过子辈对父辈的counter-reset重置、配合counters（）方法才能实现计数嵌套效果。</p><pre><code>&lt;div class=&quot;reset&quot;&gt;&lt;div class=&quot;counter&quot;&gt;我是王小二    &lt;div class=&quot;reset&quot;&gt;        &lt;div class=&quot;counter&quot;&gt;我是王小二的大儿子&lt;/div&gt;        &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子            &lt;div class=&quot;reset&quot;&gt;                &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的大孙子&lt;/div&gt;                &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的二孙子&lt;/div&gt;                &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的小孙子&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;counter&quot;&gt;我是王小二的三儿子&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;counter&quot;&gt;我是王小三&lt;/div&gt;&lt;div class=&quot;counter&quot;&gt;我是王小四    &lt;div class=&quot;reset&quot;&gt;        &lt;div class=&quot;counter&quot;&gt;我是王小四的大儿子&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>错误示范：<a href="https://demo.cssworld.cn/4/1-19.php" target="_blank" rel="noopener">CSS计数器counters的错误示范</a></p><p><strong>注意：</strong>这种计数效果在模拟书籍的目录效果时十分实用。这里需要强调的是：显示counter计数值的那个DOM元素在文档流中的位置一定要在counter-increment元素的后面，否则是没有技术效果的。</p><h5 id="1-2-4-content内容生成的混合特性"><a href="#1-2-4-content内容生成的混合特性" class="headerlink" title="1.2.4 content内容生成的混合特性"></a>1.2.4 content内容生成的混合特性</h5><p>各种content内容生成语法是可以混合在一起使用的。</p><h2 id="二、温和的padding属性"><a href="#二、温和的padding属性" class="headerlink" title="二、温和的padding属性"></a><label style="color:orange">二、温和的padding属性</label></h2><p>padding性格温和，与人相处友好，在使用padding属性进行页面开发过程中，很少会出现意想不到的情况。</p><blockquote><p>padding指的是盒子的内补间</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1565780139522&di=b575402c2cd1462e57aefeed7cb5e333&imgtype=0&src=http%3A%2F%2Fs4.sinaimg.cn%2Fmw690%2F001O8Eu1zy7fhRAYCBl23%26690" alt></p><h3 id="2-1-padding与元素的尺寸"><a href="#2-1-padding与元素的尺寸" class="headerlink" title="2.1 padding与元素的尺寸"></a>2.1 padding与元素的尺寸</h3><p>因为CSS中默认的box-sizing是content-box,所以使用padding会增加元素的尺寸。</p><p>误区：内联元素的padding只会影响水平方向，不会影响垂直方向。这是错误的！</p><p>正解：内联元素padding对视觉层和布局层具有双重影响。案例：<a href="https://demo.cssworld.cn/4/2-1.php" target="_blank" rel="noopener">内联元素垂直padding也有作用</a></p><p>应用：</p><ol><li><p>利用padding的常规应用：在不影响当前布局的情况下，优雅的增加链接或按钮的点击区域大小。如</p><p> `article a {</p><pre><code>padding: .25em 0;</code></pre><p> }`</p></li><li><p>利用内联元素padding特性的应用：<br><a href="https://demo.cssworld.cn/4/2-2.php" target="_blank" rel="noopener">内联元素padding与高度可控的分隔线</a></p></li><li><p>标题下方留出一定位置：</p></li></ol><p>源代码：</p><pre><code>&lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt;h3{    line-height: 30px;    font-size: 14px;}</code></pre><p>现在：</p><pre><code>&lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt;h3{    line-height: 30px;    font-size: 14px;h3 &gt; span {    padding-top: 58px;}</code></pre><h3 id="2-2-padding的百分比值"><a href="#2-2-padding的百分比值" class="headerlink" title="2.2 padding的百分比值"></a>2.2 padding的百分比值</h3><ol><li><p>与margin属性不同，padding不支持负值</p></li><li><p>padding支持百分比值，且padding百分比值无论是水平方向还是竖直方向均是相对于宽度计算的。</p><p> /<em>一个正方形</em>/<br> div { padding: 50%; }</p><p> /<em>一个宽高比2：1的矩形</em>/<br> div { padding: 25% 50%; }</p></li></ol><p>应用案例：<a href="https://demo.cssworld.cn/4/2-3.php" target="_blank" rel="noopener">百分比padding值与等比例头图效果</a></p><h3 id="2-3-标签元素内置的padding"><a href="#2-3-标签元素内置的padding" class="headerlink" title="2.3 标签元素内置的padding"></a>2.3 标签元素内置的padding</h3><ol><li><p>ol/ul列表内置padding-left，但是单位是px不是em。<br>根据张鑫旭老师的经验，font-size是12-14px时，22px是一个比较好的padding-left设定值，所有浏览器都能正常显示，且非常贴近边缘。</p><p> ol,ul {</p><pre><code>padding-left:22px;</code></pre><p> }</p></li><li><p>很多表单都内置padding</p></li></ol><p>案例：button 与 label 配合使用，使得即语义良好行为保留又UI效果好。</p><pre><code>&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt;&lt;label for=&quot;but&quot;&gt;按钮&lt;/label&gt;button{    position: absolute;    clip: rect(0 0 0 0);}label{    display: inline-block;    line-height: 20px;    padding: 10px;}</code></pre><h3 id="2-4-padding与图形绘制"><a href="#2-4-padding与图形绘制" class="headerlink" title="2.4 padding与图形绘制"></a>2.4 padding与图形绘制</h3><p>padding属性与background-clip属性配合，可以在有限的标签下实现一些CSS图形绘制效果。</p><p>案例：<a href="https://demo.cssworld.cn/4/2-4.php" target="_blank" rel="noopener">三道杠和双层圆点图形生成</a></p><h2 id="三、致谢"><a href="#三、致谢" class="headerlink" title="三、致谢"></a><label style="color:orange">三、致谢</label></h2><p>本文内容我对张鑫旭老师《CSS世界》第四章1、2小节的的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vis-Class1_可视化释义</title>
      <link href="/2019/08/07/Vis-Class%E2%80%94-one/"/>
      <url>/2019/08/07/Vis-Class%E2%80%94-one/</url>
      
        <content type="html"><![CDATA[<p>浙江大学2019年可视化与可视分析暑期学校第一课：陈为老师《可视化释义》笔记。</p><a id="more"></a><h1 id="SummerCourse2019ZJU"><a href="#SummerCourse2019ZJU" class="headerlink" title="SummerCourse2019ZJU"></a>SummerCourse2019ZJU</h1><hr><h2 id="1"> Class 1 Introduction release </h2><blockquote><p><a href="http://www.cad.zju.edu.cn/home/chenwei" target="_blank" rel="noopener">Wei Chen</a></p><p><a href="mailto:chenwei@cad.zju.edu.cn" target="_blank" rel="noopener">chenwei@cad.zju.edu.cn</a></p></blockquote><p><strong>OUTLINE</strong></p><p><a href="#1.1">1.1 What is data visualization</a></p><p><a href="#1.2">1.2 Visualization is hot &amp; cool &amp; young</a></p><p><a href="#1.3">1.3 How to create visualization?</a></p><h3 id="1.1">1、What is data visualization</h3>---<p><strong>1.1 “Data visualization is the creation and study of the visual representation of data” - wiki</strong></p><p> <strong>Input:</strong> data <strong>Output:</strong> visual form <strong>Goal:</strong> insight</p><p> <strong>vi·su·al·i·za·tion:</strong></p><blockquote><ul><li>Formation of mental visual images</li><li>The act or process of interpreting in visual terms or of putting into visible form</li></ul></blockquote><p>eg:<a href="http://www.aaronkoblin.com/work/flightpatterns" target="_blank" rel="noopener">Aaron Koblin, TED 2006</a></p><p><strong>1.2 Why is a Diagram (Sometimes)Worth 10,000 Words</strong></p><p><em>Larkin and Simon, Cognitive Science, 1987</em></p><ul><li>图表表达与句型表达具有信息和计算上的等价性 [Simon 1978]</li><li>图表具有拓扑和几何的关联，将信息基于位置进行索引，所见处即所得</li><li>句型表达具有时间或逻辑方面的序列，显式地表达了单个元素。</li><li>句型表达假设每句话是串行阵列；而图表表达有一个简洁的语义网络，认知时只需要在不同的节点间定位。</li><li>在求解问题时，图表表达可以提供搜索与认知的便利；句型表达在搜索时需要记住更多的信息。<a href="https://visualgo.net/en" target="_blank" rel="noopener">eg:Visu Algo通过动画可视化数据结构和算法</a></li></ul><p><strong>1.3 How to do</strong></p><ul><li>Helps us think</li><li>Uses perception to offload cognition</li><li>Serves as an external aid to augment working memory</li><li>Boosts our cognitive abilities</li></ul><h3 id="1.2">2、Visualization is hot & cool & young</h3>---**2.1 Top VIS Conferences**<ul><li>VAST (Visual Analytics Science and Technology)</li><li>InfoVis (Information Visualization)</li><li>SciVis (Scientific Visualization)</li></ul><p><strong>2.2 What is VIS Research?</strong></p><ul><li>Visualization Pipeline</li><li>Technique Papers</li><li>Application/Design Study Papers</li><li>System Papers</li><li>Evaluation Papers</li><li>Theory/Model papers</li></ul><p><strong>2.3 Some of Web</strong></p><ul><li><a href="http://www.math.yorku.ca/SCS/Gallery/milestone/" target="_blank" rel="noopener">Milestones Project 时间线</a></li><li><a href="https://g2.alipay.com" target="_blank" rel="noopener">蚂蚁金服DT时代新布局：可视化神器G2</a></li><li><a href="https://www.echartsjs.com/" target="_blank" rel="noopener">Baidu EChart</a></li></ul><h3 id="1.3">3、How to create visualization?</h3>---<p><strong>3.1 Act I: Foundations</strong></p><ul><li>Design Principles</li><li>Process &amp; Data</li><li>Tasks &amp; Interaction</li><li>Perception</li><li>Visual Encodings</li><li>Color</li></ul><p><strong>3.2 Act II:Methods</strong></p><ul><li>SingleViews</li><li>MultipleViews</li><li>Filtering &amp;Aggregation</li><li>Dimensionality Reduction</li><li>Evaluation</li></ul><p><strong>3.3 Act III:Techniques</strong></p><ul><li>Statistical Graphs</li><li>Trees &amp; Networks</li><li>Maps</li><li>Text &amp; Images</li></ul><p><strong>3.4How to create a visualization yourself</strong></p><ul><li><a href="http://openrefine.org/" target="_blank" rel="noopener">数据清洗工具OpenRefine</a>（以前称为Google Refine）; <a href="https://www.cnblogs.com/anovana/p/8267435.html" target="_blank" rel="noopener">中文教程</a></li><li><a href="https://www.tableau.com/" target="_blank" rel="noopener">数据可视化工具Tableau</a>; <a href="https://www.w3cschool.cn/tableau/" target="_blank" rel="noopener">中文教程</a></li><li><a href="https://www.r-project.org/" target="_blank" rel="noopener">统计计算和统计制图的优秀工具:R</a></li><li><a href="https://processing.org/" target="_blank" rel="noopener">在视觉艺术环境中编码的语言:Processing</a></li><li><a href="https://d3js.org/" target="_blank" rel="noopener">最流行的可视化库之一:D3 (JS)</a>;<a href="http://d3.decembercafe.org" target="_blank" rel="noopener">中文教程</a></li><li><a href="http://colorbrewer2.org/" target="_blank" rel="noopener">配色方案:ColorBrewer</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用操作总结</title>
      <link href="/2019/08/05/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/05/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Git常用操作总结 - 参考自廖雪峰老师的git教程</p><a id="more"></a><h2 id="一-创建版本库"><a href="#一-创建版本库" class="headerlink" title="一.创建版本库"></a>一.创建版本库</h2><blockquote><p>$ mkdir learngit// 创建文件夹learngit</p><p>$ cd learngit</p><p>$ pwd//显示当前路径</p></blockquote><p>①初始化一个Git仓库：</p><pre><code>git init//将当前目录变成一个Git可以管理的仓库</code></pre><p>②添加文件到Git仓库：</p><pre><code>1.git add&lt;file&gt; ;  2.git commit</code></pre><blockquote><p>$ git add readme.txt // 将文件添加到Git仓库（把文件修改添加到暂存区）</p><p>$ git add file1.txt // 添加file1.txt文件</p></blockquote><blockquote><p>$ git add file2.txt file3.txt // 同时添加file2.txt和file3.txt两个文件</p></blockquote><blockquote><p>$ git commit -m “wrote a readme.txt.” // 将文件提交到仓库（把暂存区的所有内容提交到当前分支）</p></blockquote><h2 id="二-时光机穿梭"><a href="#二-时光机穿梭" class="headerlink" title="二.时光机穿梭"></a>二.时光机穿梭</h2><p>①查看工作区状态，文件是否被修改过：</p><pre><code>git status</code></pre><p>②查看修改的内容：</p><pre><code>git diff</code></pre><blockquote><p>eg:$ git diff readme.txt // 查看工作区的readme.txt与缓存区的readme.txt的区别</p></blockquote><h3 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1.版本回退"></a>1.版本回退</h3><pre><code>①HEAD:当前版本②HEAD^:上个版本③定位版本：git reset --hard commit_id④git log：穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本⑤git reflog：要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</code></pre><blockquote><p>$ git log // 查看最近到最远的提交记录（详情: commit id + Author + Date + comment）</p></blockquote><blockquote><p>$ git log –pretty=oneline // 查看最近到最远的提交记录（简写：commit id + comment）</p></blockquote><blockquote><p>$ git reset –hard HEAD^ // 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本）</p></blockquote><blockquote><p>$ git reset –hard 1234567 // 回到指定版本号commit id（此处：commit id 假设为1234567<strong>**</strong>，Git会根据commit id的前几位自动寻找对应的版本）</p></blockquote><blockquote><p>$ cat readme.txt // 查看readme.txt的内容</p></blockquote><blockquote><p>$ git reflog // 查看每一次命令记录历史，确保能回到任意版本　　</p></blockquote><h3 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2.工作区和暂存区"></a>2.工作区和暂存区</h3><p>①工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p><p>②版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>③暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区。 </p><pre><code>$ git diff readme.txt // 比较工作区（working directory）和暂存区（stage/index）的区别$ git diff --cached // 比较暂存区（stage/index）和分支（master）的区别</code></pre><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h3 id="3-管理修改"><a href="#3-管理修改" class="headerlink" title="3.管理修改"></a>3.管理修改</h3><p>①每次修改，如果不add到暂存区，就不会加入到commit中</p><h3 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4.撤销修改"></a>4.撤销修改</h3><pre><code>①git checkout -- file：丢弃工作区的修改②git reset HEAD file：把暂存区的修改撤销掉，重新放回工作区</code></pre><h3 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5.删除文件"></a>5.删除文件</h3><pre><code>①git rm：从版本库中删除文件</code></pre><blockquote><p>$ rm test.txt // 删除工作区文件（类似于手动删除）</p></blockquote><blockquote><p>$ git status // 查看当前工作区与缓存区状态</p><p>$ git rm test.txt // 情况1：确认删除</p></blockquote><blockquote><p>$ git commit -m “remove test.txt” // 情况1：确认删除后，提交到版本库</p></blockquote><blockquote><p>$ git checkout – readme.txt // 情况2：误删，需要回退（即：用版本库里的版本替换工作区的版本）</p></blockquote><h2 id="三-远程仓库"><a href="#三-远程仓库" class="headerlink" title="三.远程仓库"></a>三.远程仓库</h2><h3 id="1-添加远程库"><a href="#1-添加远程库" class="headerlink" title="1.添加远程库"></a>1.添加远程库</h3><p>①关联一个远程库：</p><pre><code>git remote add origin git@server-name:path/repo-name.git// 关联一个远程仓库</code></pre><blockquote><p>eg:git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yangfff/learngit.git</p></blockquote><p>②关联后第一次推送master分支的所有内容：</p><pre><code>git push -u origin master</code></pre><p>③此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改</p><pre><code>git push -u origin master // 第一次推送master分支的所有内容</code></pre><p>ps:由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>注：在GitHub上创建新仓库时，如果勾选了README.md选项时，可能会出现下面错误，提示：远程仓库有readme.txt,而本地仓库没有README.txt,此时应该先进行合并文件，再进行推送。</p><pre><code>git pull --rebase origin master // 推送之前，进行合并</code></pre><p>合并文件之后，发现本地仓库中多了README.md文件，此时再进行推送修改到远程仓库就可以了。</p><pre><code>再次执行：git push -u origin master, 即可推送本地仓库到远程仓库了</code></pre><p>查看GitHub上的文件，已经更新！</p><h3 id="2-从远程库克隆"><a href="#2-从远程库克隆" class="headerlink" title="2.从远程库克隆"></a>2.从远程库克隆</h3><p>①要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆</p><p>②Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快</p><pre><code>$ git clone git@github.com:yangfff/learngit.git // 以SSH方式克隆$ git clone https://github.com/yangfff/learngit.git // 以Https协议方式克隆</code></pre><h2 id="四-分支管理"><a href="#四-分支管理" class="headerlink" title="四.分支管理"></a>四.分支管理</h2><h3 id="1-创建与合并分支"><a href="#1-创建与合并分支" class="headerlink" title="1.创建与合并分支"></a>1.创建与合并分支</h3><pre><code>查看分支：    git branch创建分支：    git branch&lt;name&gt;切换分支：    git cheakout&lt;name&gt;创建+切换分支：    git cheakout -b &lt;name&gt;合并某分支到当前分支：git merge&lt;name&gt;删除分支：git branch - d &lt;name&gt;</code></pre><h3 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2.解决冲突"></a>2.解决冲突</h3><p>①查看分支合并图：</p><pre><code>git log --graph // 查看分支合并图git log --graph --pretty=oneline --abbrev-commit // 查看分支合并缩略图</code></pre><h3 id="3-分支管理策略"><a href="#3-分支管理策略" class="headerlink" title="3.分支管理策略"></a>3.分支管理策略</h3><p>①合并分支时加–no-ff参数：普通模式合并，合并后的历史有分支，禁用fast forward</p><p>eg:git log –no-ff-m”merge with no–ff”dev</p><h3 id="4-Bug分支"><a href="#4-Bug分支" class="headerlink" title="4.Bug分支"></a>4.Bug分支</h3><pre><code>git stash // 隐藏分支工作现场，为修复bug准备git stash list // 查看有哪些分支隐藏的工作现场，为恢复工作现场做准备git stash apply // 恢复工作现场，但不删除存储的stash内容，结合git stash drop进行删除git stash drop // 删除存储的stash内容，恢复到隐藏前的工作现场git stash pop // 恢复到隐藏前的工作现场，相当于git stash apply和git stash dropgit stash apply stash@{0} // 可以多次stash，通过git stash list查看所有的stash，然后可以恢复到指定的隐藏的工作现场</code></pre><h3 id="5-Feature分支"><a href="#5-Feature分支" class="headerlink" title="5.Feature分支"></a>5.Feature分支</h3><p>①开发一个新feature，最好新建一个分支；</p><p>②如果要丢弃一个没有被合并过的分支，可以通过</p><pre><code>git branch -D &lt;name&gt;//强行删除</code></pre><h3 id="6-多人协作"><a href="#6-多人协作" class="headerlink" title="6.多人协作"></a>6.多人协作</h3><p>①git remote -v：查看远程库信息</p><p>②git push origin branch-name：从本地推送分支</p><p>③git pull：推送失败时，抓取远程的新提交</p><p>④git checkout -b branch-name origin/branch-name：在本地创建和远程分支对应的分支（本地和远程分支的名称最好一致）</p><p>⑤git branch –set-upstream branch-name origin/branch-name：建立本地分支和远程分支的关联</p><h2 id="五-标签管理"><a href="#五-标签管理" class="headerlink" title="五.标签管理"></a>五.标签管理</h2><h3 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1.创建标签"></a>1.创建标签</h3><p>①git tag <name>：新建一个标签（默认为HEAD，也可以指定commit id）</name></p><p>②git tag -a <tagname> -m “blablabla…”：可以指定标签信息</tagname></p><p>③git tag -s <tagname> -m “blablabla…”：可以用PGP签名信息</tagname></p><p>④git tag：查看所有标签</p><h3 id="2-操作标签"><a href="#2-操作标签" class="headerlink" title="2.操作标签"></a>2.操作标签</h3><p>①git push origin <tagname>：推送一个本地标签</tagname></p><p>②git push origin –tags：推送全部未推送过的本地标签</p><p>③git tag -d <tagname>：删除一个本地标签</tagname></p><p>④git push origin :refs/tags/<tagname>：删除一个远程标签</tagname></p><h2 id="六-使用GitHub"><a href="#六-使用GitHub" class="headerlink" title="六.使用GitHub"></a>六.使用GitHub</h2><p>①在GitHub上，可以任意Fork开源仓库；</p><p>②自己拥有Fork后的仓库的读写权限；</p><p>③可以推送pull request给官方仓库来贡献代码。</p><h2 id="七-自定义Git"><a href="#七-自定义Git" class="headerlink" title="七.自定义Git"></a>七.自定义Git</h2><h3 id="1-忽略特殊文件"><a href="#1-忽略特殊文件" class="headerlink" title="1.忽略特殊文件"></a>1.忽略特殊文件</h3><p>①忽略某些文件时，需要编写.gitignore；</p><h3 id="2-配置别名"><a href="#2-配置别名" class="headerlink" title="2.配置别名"></a>2.配置别名</h3><p>①我们只需要敲一行命令，告诉Git，以后st就表示status：</p><pre><code>git config --global alias.st status</code></pre><blockquote><p>eg:</p></blockquote><blockquote><p>$ git config –global alias.co checkout</p></blockquote><blockquote><p>$ git config –global alias.ci commit</p></blockquote><blockquote><p>$ git config –global alias.br branch</p></blockquote><blockquote><p>$ git config –global alias.unstage ‘reset HEAD’</p></blockquote><blockquote><p>$ git config –global alias.last ‘log -1’</p></blockquote><blockquote><p>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”</p></blockquote><h3 id="3-搭建Git服务器"><a href="#3-搭建Git服务器" class="headerlink" title="3.搭建Git服务器"></a>3.搭建Git服务器</h3><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>例如大众点评code.dianpingoa.com</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流、元素与基本尺寸</title>
      <link href="/2019/08/01/%E6%B5%81%E3%80%81%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%B0%BA%E5%AF%B8/"/>
      <url>/2019/08/01/%E6%B5%81%E3%80%81%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<p>本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。</p><a id="more"></a><p>“流”之所以影响了整个CSS世界，就是因为影响了CSS世界的基石HTML。HTNML标签通常分为两类：块级元素和内联元素。</p><p><strong><em>注意：</em></strong> 按照W3C的CSS规范，这里应该是“块级元素”和“内联级元素”。但是在W3C的HTML规范里，已经明确把HTML元素分为了“块级元素”和“内联元素”。我们这里采用现实中常用的HTML的内联元素这一说法。</p><h2 id="一、块级元素（block-level-element）"><a href="#一、块级元素（block-level-element）" class="headerlink" title="一、块级元素（block-level element）"></a><label style="color:orange">一、块级元素（block-level element）</label></h2><h3 id="1-1-基本特性："><a href="#1-1-基本特性：" class="headerlink" title="1.1 基本特性："></a>1.1 基本特性：</h3><blockquote><p>基本特性：换行特性（一个水平流上只能单独显示一个元素，多个块级元素则换行显示。）</p></blockquote><p><strong>注意：</strong>块级元素的流体特性主要表现在水平方向上。</p><h3 id="1-2-块级元素和“display-为block-的元素”不是一个概念"><a href="#1-2-块级元素和“display-为block-的元素”不是一个概念" class="headerlink" title="1.2 块级元素和“display 为block 的元素”不是一个概念"></a>1.2 块级元素和“display 为block 的元素”不是一个概念</h3><p>display:list-item、display:table均块级元素，因为他们符合块级元素的基本特征，即换行特征。</p><h3 id="1-3-用display值为block和list-item来配合clear属性来清除浮动带来的影响"><a href="#1-3-用display值为block和list-item来配合clear属性来清除浮动带来的影响" class="headerlink" title="1.3 用display值为block和list-item来配合clear属性来清除浮动带来的影响"></a>1.3 用display值为block和list-item来配合clear属性来清除浮动带来的影响</h3><p>不使用list-item的原因：字母比较多、会出现项目符号、ie浏览器不支持伪元素的display值为listitem。</p><p>如<a href="https://demo.cssworld.cn/3/1-1.php" target="_blank" rel="noopener">案例</a>：</p><pre><code>.clear: after {    content: &apos;&apos;;    display: table; // 也可以是block，或者是list-item    clear: both;  }</code></pre><h2 id="二、list-item-元素会出现项目符号的原因"><a href="#二、list-item-元素会出现项目符号的原因" class="headerlink" title="二、list-item 元素会出现项目符号的原因"></a><label style="color:orange">二、list-item 元素会出现项目符号的原因</label></h2><h3 id="2-1-标记盒子："><a href="#2-1-标记盒子：" class="headerlink" title="2.1 标记盒子："></a>2.1 标记盒子：</h3><p><strong>注意:</strong>标记盒子可以理解为主块级之外的附加盒子。</p><p>list-item 元素会出现项目符号是因为生成了一个附加的盒子，学名“标记盒子”（marker box），专门用来放圆点、数字这些项目号。</p><p>IE浏览器下伪元素不支持list-item 或许就是无法创建这个“标记盒子”导致的。</p><h3 id="2-2-外在盒子和容器盒子"><a href="#2-2-外在盒子和容器盒子" class="headerlink" title="2.2 外在盒子和容器盒子"></a>2.2 外在盒子和容器盒子</h3><p><strong>注意:</strong>容器盒子可以理解为内在盒子。</p><blockquote><p>内在盒子：负责元素是一行显示还是只能换行显示。</p><p>容器盒子：负责宽高、内容呈现等。</p></blockquote><p>[按照display的属性值我们可以知道：</p><ul><li>display值为block的元素由外在的“块级盒子”和内在的“块级容器盒子”组成。</li><li>display值为inline-block的元素由外在的“内联盒子”和内在的“块级容器盒子”组成。</li><li>display值为inline的元素内外均是“内联盒子”。</li><li>display值为inline-table的元素外面是“内联盒子”，里面是“table 盒子”。</li></ul><h3 id="2-3-width-height-作用在“容器盒子”"><a href="#2-3-width-height-作用在“容器盒子”" class="headerlink" title="2.3 width/height 作用在“容器盒子”"></a>2.3 width/height 作用在“容器盒子”</h3><p><a href="https://demo.cssworld.cn/3/1-2.php" target="_blank" rel="noopener">点此查看案例演示：和文字平起平坐的表格</a></p><p>案例结果：该元素和文字一行显示，且表现如同真正的表格元素（子元素宽度等分）</p><h2 id="三、width-height作用的细节"><a href="#三、width-height作用的细节" class="headerlink" title="三、width/height作用的细节"></a><label style="color:orange">三、width/height作用的细节</label></h2><h3 id="3-1-width默认值auto的4种表现："><a href="#3-1-width默认值auto的4种表现：" class="headerlink" title="3.1 width默认值auto的4种表现："></a>3.1 width默认值auto的4种表现：</h3><p><strong>1、充分利用可用空间，宽度默认100%于父级容器的。</strong></p><p>比如：&lt;div&gt;、&lt;p&gt;这些元素的宽度默认是100%于父级容器的。</p><p>这种充分利用可用空间的行为还有个专有名字，叫作<strong>fill-available</strong>。</p><p><strong>2、自适应大小，具有包裹性。</strong></p><p>典型代表：浮动、绝对定位、inline-block 元素或table 元素。</p><p><strong>3、收缩到最小</strong></p><p>这个最容易出现在table-l表格ayout 为auto 的中：<br><img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%94%B6%E7%BC%A9%E4%B8%8E%E5%8C%85%E8%A3%B9.png" alt="table-l表格ayout 为auto 的中"></p><p>当一列空间都不够时，文字能断就断，但中文随便断的，英文单词不能断。</p><p><strong>4、超出容器限制</strong><br>除非明确width的相关设置，否则上面3种都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如：内容很长的连续的英文和数字，或者内联元素被设置了white-space：nowrap,则表现为如下：</p><p><img src="http://pvjdnjjsz.bkt.clouddn.com/%E8%B6%85%E5%87%BA%E5%AE%B9%E5%99%A8%E9%99%90%E5%88%B6.png" alt></p><p>像这一种子元素既保持了inline-block元素的收缩性，又同时让内容宽度最大，直接无视父级容器的宽度限制，后来在CSS3中有了专门的属性值描述，教室max-cintent.</p><blockquote><p>上面的几个只有第一个是“外部尺寸”，其余全部是“内部尺寸”。而这唯一的“外部尺寸”，是“流”的精髓所在。</p></blockquote><h2 id="四、外部尺寸与流体特性"><a href="#四、外部尺寸与流体特性" class="headerlink" title="四、外部尺寸与流体特性"></a><label style="color:orange">四、外部尺寸与流体特性</label></h2><p>元素尺寸由外部的容器决定</p><p>正常流宽度是一种margin/border/padding和content 内容区域自动分配水平空间的机制，尽量用无宽带的流来布局。</p><p>格式化宽度：在position属性值为absolute 或fixed 的元素中。在默认情况下，宽度由内部尺寸决定。当left/top 或top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position 属性值不是static）的祖先元素计算。margin、border、padding 和content 内容区域同样会自动分配水平（和垂直）空间</p><h2 id="五、内部尺寸与流体特性"><a href="#五、内部尺寸与流体特性" class="headerlink" title="五、内部尺寸与流体特性"></a><label style="color:orange">五、内部尺寸与流体特性</label></h2><p>元素尺寸由内部元素决定，“内部尺寸”有下面3 种表现形式：</p><p>包裹性:元素尺寸由内部元素决定，但永远小于“包含块”容器的尺寸（除非容器尺寸小于元素的“首选最小宽度”）按钮:</p><p>按钮就是inline-block 元素。</p><p>按钮文字越多宽度越宽（内部尺寸特性），但如果文字足够多，则会在容器的宽度处自动换行（自适应特性）。</p><p><button>标签按钮才会自动换行，</button><input>标签按钮，默white-space:pre，<br>是不会换行的，需要将pre 值重置为默认的normal。</p><p>按钮最大宽度就是容器的240 像素</p><p>首选最小宽度:元素最适合的最小宽度.外部容器的宽度是240 像素，假设宽度是0，里面的inline-block 元素的宽度是首选最小宽度。具体表现规则：</p><p>东亚文字（如中文）最小宽度为每个汉字的宽度。</p><p>西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。</p><p>如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS 中的word-break:break-all。</p><p>类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度。</p><p>最大宽度:是元素可以有的最大宽度。“最大宽度”实际等同于“包裹性”元素设置white-space:nowrap 声明后的宽度。如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度。</p><h2 id="六、width-值作用的细节"><a href="#六、width-值作用的细节" class="headerlink" title="六、width 值作用的细节"></a><label style="color:orange">六、width 值作用的细节</label></h2><p>width 是作用在“内在盒子”上的，“内在盒子”又被分成了4 个盒子，分别是content box、padding box、border box和margin box。</p><p>content box ： content-box，padding box ：padding-box，border box ：border-box。margin box没有名字。</p><p>margin 的背景永远是透明的。</p><p>在CSS2.1 的规范中，有一段非常露骨的描述：content box 环绕着width 和height 给定的矩形。这种宽度设定和表现并不合理：</p><p>流动性丢失：对于块状元素，如果width:auto，则元素会如水流般充满整个容器，而一旦设定了width具体数值，则元素的流动性就会被阻断。</p><p>与现实世界表现不一致的困扰。</p><h2 id="七、CSS-流体布局下的宽度分离原则"><a href="#七、CSS-流体布局下的宽度分离原则" class="headerlink" title="七、CSS 流体布局下的宽度分离原则"></a><label style="color:orange">七、CSS 流体布局下的宽度分离原则</label></h2><p>所谓“宽度分离原则”，就是CSS 中的width 属性不与影响宽度的padding/border（有时候包括margin）属性共存。写法：<br>      .father {<br>        width: 180px;<br>      }<br>      .son {<br>        margin: 0 20px;<br>        padding: 20px;<br>        border: 1px solid;<br>      }<br>为何要宽度分离:当一件事情的发展可以被多个因素所左右的时候，这个事情最终的结<br>果就会变数很大而不可预期。宽度在这里也是类似，由于盒尺寸中的4 个盒子都能影响宽度，自然页面元素的最终宽度就很容易发生变化而导致意想不到的布局发生。使用“宽度分离”后，咱们不需要烧脑子去计算了，而且页面结构反而更稳固。</p><h2 id="八、改变width-height-作用细节的box-sizing"><a href="#八、改变width-height-作用细节的box-sizing" class="headerlink" title="八、改变width/height 作用细节的box-sizing"></a><label style="color:orange">八、改变width/height 作用细节的box-sizing</label></h2><p>box-sizing 的作用：改变了width 作用的盒子。box-sizing:border-box 就是让100 像素的宽度直接作用在border box上，从默认的content box 变成border box。此时，content box 从宽度值中释放，形成了局部的流动性，和padding 一起自动分配width 值。</p><p>box-sizing 并不支持margin-box。</p><p>如何评价*{box-sizing:border-box}。从纯个人角度讲，不喜欢这种做法的。</p><p>这种做法易产生没必要的消耗，通配符*应该是一个慎用的选择器，因为它会选择所<br>有的标签元素。</p><p>这种做法并不能解决所有问题。box-sizing 不支持margin-box，只有当元素没<br>有水平margin 时候，box-sizing 才能真正无计算，而“宽度分离”等策略则可以彻底解决<br>所有的宽度计算的问题。</p><p>替换元素css重置更合适：</p><p>   input, textarea, img, video, object {<br>     box-sizing: border-box;<br>   }</p><h2 id="九、关于height"><a href="#九、关于height" class="headerlink" title="九、关于height"></a><label style="color:orange">九、关于height</label></h2><p>对于width 属性，就算父元素width 为auto，其百分比值也是支持的。</p><p>对于height 属性，如果父元素height 为auto，只要子元素在文档流中，其百分比值完全就被忽略了。百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p><p>如何让元素支持height:100%效果：</p><p>设定显式的高度值。</p><p>使用绝对定位。绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于padding box 的，也就是说会把padding 大小值计算在内，但是，非绝对定位元素则是相对于content box 计算的。</p><h2 id="十、min-width-max-width和min-height-max-height"><a href="#十、min-width-max-width和min-height-max-height" class="headerlink" title="十、min-width/max-width和min-height/max-height"></a><label style="color:orange">十、min-width/max-width和min-height/max-height</label></h2><p>max-width 和max-height 的初始值是none,min-width/min-height 的初始值都是auto。</p><p>超越!important 指的是max-width 会覆盖width，而且这种覆盖不是普通的覆盖，是超级覆盖。</p><pre><code>&lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important;&quot;&gt;img { max-width: 256px; }</code></pre><p>答案是256px。</p><p>min-width覆盖max-width，此规则发生在min-width和max-width冲突的时候。</p><p>任意高度元素的展开收起动画技术：<br>.element {<br>  height: 0;<br>  overflow: hidden;<br>  transition: height .25s;<br>}<br>.element.active {<br>  height: auto; /* 没有transition 效果，只是生硬地展开 */<br>}<br>可以试试下面方法</p><p>.element {<br>  max - height: 0;<br>  overflow: hidden;<br>  transition: max - height .25s;<br>}<br>.element.active {<br>  max - height: 666px; /* 一个足够大的最大高度值 */<br>}<br>注意：即虽然说从适用范围讲，max- height 值越大使用场景越多，但是，如果max-height 值太大，在收起的时候可能会有“效果延迟”的问题。因此，我个人建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也<br>会因为时间很短，很难被用户察觉，并不会影响体验。</p><h2 id="十一、内联元素"><a href="#十一、内联元素" class="headerlink" title="十一、内联元素"></a><label style="color:orange">十一、内联元素</label></h2><p>块级负责结构，内联负责内容。</p><p>“内联元素”的“内联”特指“外在盒子”，和“display 为inline的元素”不是一个概念。</p><p>“内联元素”的典型特征就是可以和文字在一行显示。</p><p>内容区域（content area）：域指一种围绕文字看不见的盒子可以理解为把文本选中的背景色区域作为内容区域。</p><p>注意：在IE 和Firefox 浏览器下，文字的选中背景总能准确反映内容区域范围，但是Chrome 浏览器下，::selection 范围并不总是准确的，例如，和图片混排或者有垂直padding 的时候，范围会明显过大，这一点需要注意。</p><p>内联盒子（inline box）：“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类：</p><p>内联盒子:外部含内联标签&lt;span&gt;、&lt;a&gt;和&lt;em&gt;等。<br>匿名内联盒子:光秃秃的文字。</p><p>行框盒子（line box）:每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</p><p>包含盒子（containing box）:</p><p>标签就是一个“包含盒子”（实线框标注），此盒子由一行一行的“行框盒子”组成。</p><h2 id="十二、幽灵空白节点"><a href="#十二、幽灵空白节点" class="headerlink" title="十二、幽灵空白节点"></a><label style="color:orange">十二、幽灵空白节点</label></h2><p>在HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p><p><strong>注意:</strong>这里有一个前提，文档声明必须是HTML5 文档声明，如果还是很多年前的老声明，则不存在“幽灵空白节点”。</p><h2 id="十三、致谢"><a href="#十三、致谢" class="headerlink" title="十三、致谢"></a><label style="color:orange">十三、致谢</label></h2><p>本文内容是我对张鑫旭老师《CSS世界》一书第三章的学习笔记，由衷的钦佩张鑫旭老师，向张鑫旭老师学习！也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS世界的专业术语</title>
      <link href="/2019/07/31/CSS%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"/>
      <url>/2019/07/31/CSS%E4%B8%96%E7%95%8C%E7%9A%84%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>本文介绍的是CSS世界中务必了解的专业术语，包括属性、值、关键词、变量、长度单位、功能符、属性值、生命、声明块、规则或规则集、选择器、关系选择器、@规则以及CSS世界中的“未定义行为”。</p><a id="more"></a><h2 id="一、CSS世界的专业术语"><a href="#一、CSS世界的专业术语" class="headerlink" title="一、CSS世界的专业术语"></a><label style="color:orange">一、CSS世界的专业术语</label></h2><p>案例：</p><pre><code>.vacabulary{    height: 99px;    color: transparent;}</code></pre><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>例如上面案例中的高度和颜色就是CSS世界的属性，CSS属性就是魔法师。</p><h3 id="2-值"><a href="#2-值" class="headerlink" title="2. 值"></a>2. 值</h3><p>CSS的各种属性值就是魔法师的魔法技能。<br>在CSS世界中，值得分类十分广泛，比较常用的有：</p><ul><li>整数值，如z-index:1中，1属于<intrger>,同时也属于<number></number></intrger></li><li>数值，如line-height：1.5中的1.5</li><li>百分比值，如padding：50%中的50%</li><li>长度值，如99px</li><li>颜色值，如#999</li></ul><p>此外，还有字符串值、位置值等类型。在CSS3新世界中，还有角度值、频率值、时间值等类型。</p><h3 id="3-关键词"><a href="#3-关键词" class="headerlink" title="3. 关键词"></a>3. 关键词</h3><ul><li>关键字：CSS中很关键的英文单词。例如上面案例中的transparent（全透明黑色）就是典型的关键词，还有常见的solid（实线的）、inherit(继承)。</li><li>泛关键字：所有CSS属性都可以使用的关键字，例如<a href="https://blog.csdn.net/codingnoob/article/details/78179536" target="_blank" rel="noopener">initial（默认）、inherit（继承）和unset（不设置）</a></li></ul><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h3><p>CSS中目前可以称为变量的比较有效，CSS3中的currentColor就是变量，非常有用：<a href="https://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/" target="_blank" rel="noopener">currentColor-CSS3超高校级好用CSS变量</a>;</p><p>以及阮一峰老师的自定义CSS变量教程：<br><a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" target="_blank" rel="noopener">CSS 变量教程</a></p><h3 id="5-长度单位"><a href="#5-长度单位" class="headerlink" title="5. 长度单位"></a>5. 长度单位</h3><p>CSS中的单位有时间单位（如s、ms）,还有角度单位（如deg、rad等），但最常见的还是长度单位。长度单位分为：</p><ul><li>绝对长度单位：彼此固定，不会因为其他元素的尺寸变化而变化。主要有px、cm、mm、Q、in、pc、pt(eg:除px外，其他基本不用) </li><li>相对长度单位：指定相对于另一长度的长度。主要有em、ex、ch、rem、%和可视区百分比长度单位 vm、vh、vmin、vmax</li></ul><p><strong>注意</strong>：</p><ul><li>2%属于数值，这里的%不是长度单位</li><li>“值”里面的&lt;length和长度单位的关系：&lt;numberre&gt;+长度单位=&lt;length&gt;;</li></ul><h3 id="6-功能符"><a href="#6-功能符" class="headerlink" title="6. 功能符"></a>6. 功能符</h3><p>值以函数的形式指定（就是被括号括起来的那种），主要用来表示颜色（rgba和hsla）、背景图片地址（url)、元素属性值、计算（calc）和过渡效果等，如rgba (0,0,0,0)、url(“css-world.png”)、attr(“herf”)、scale(-1)</p><h3 id="7-属性值"><a href="#7-属性值" class="headerlink" title="7. 属性值"></a>7. 属性值</h3><p>属性冒号后面的内容统一称为属性值</p><h3 id="8-声明"><a href="#8-声明" class="headerlink" title="8. 声明"></a>8. 声明</h3><p>属性名+属性值</p><h3 id="9-声明块"><a href="#9-声明块" class="headerlink" title="9. 声明块"></a>9. 声明块</h3><p>声明块就是花括号{}包裹的一系列声明</p><h3 id="10-规则或规则集"><a href="#10-规则或规则集" class="headerlink" title="10. 规则或规则集"></a>10. 规则或规则集</h3><p>出现了选择器，而且后面跟着声明块，如本文最上面的案例。</p><h3 id="11-选择器"><a href="#11-选择器" class="headerlink" title="11. 选择器"></a>11. 选择器</h3><p>用来瞄准目标元素的东西。</p><ul><li>类选择器：如.umbrella</li><li>ID选择器：如#id</li><li>属性 选择器：如[attribute]    [target] 选择带有 target 属性所有元素</li><li>伪类选择器：一般前面有一个：</li><li>伪元素选择器：有两个冒号的原则，::selection    ::selection    选择被用户选取的元素部分。</li></ul><p>这里放上更详细的介绍：<a href="https://www.w3school.com.cn/cssref/css_selectors.ASP" target="_blank" rel="noopener">CSS 选择器参考手册</a></p><h3 id="12-关系选择器"><a href="#12-关系选择器" class="headerlink" title="12. 关系选择器"></a>12. 关系选择器</h3><p>根据与其他元素的关系选择元素的选择器，常见的有：</p><ul><li>后代选择器 空格连接</li><li>相邻后代选择器 &gt;连接</li><li>兄弟选择器 ~连接 （注意：是当前元素后面<strong>所有的</strong>的合规则的那个同父的兄弟元素）</li><li>相邻兄弟选择器： +连接 （注意：仅仅选择当前元素相邻的那<strong>一个</strong>同父元素的合规则的兄弟元素。<em>且适用于IE7以上版本</em>）  </li></ul><h3 id="13-规则"><a href="#13-规则" class="headerlink" title="13. @规则"></a>13. @规则</h3><p>指的是以@字符开头的一些规则，例如@media、@font-face、@page或@support</p><h2 id="二、CSS世界中的“未定义行为”"><a href="#二、CSS世界中的“未定义行为”" class="headerlink" title="二、CSS世界中的“未定义行为”"></a><label style="color:orange">二、CSS世界中的“未定义行为”</label></h2><p>现实世界中，法律约束我们的行为，如果越界，就叫违法；在CSS世界中，有Web标准约束元素的行为，如果越界就称为bug。不过不可能面面俱到，法律会有法律空白，在CSS世界也会有”未定义行为”。<br>例如以下这个案例：FireFox mousedown干掉:active实例页面</p><p>HTML：</p><pre><code>正常情况：&lt;a href=&quot;javascript:&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt;包含JS：&lt;a href=&quot;javascript:&quot; id=&quot;button&quot; class=&quot;active-btn&quot;&gt;按下&lt;/a&gt;</code></pre><p>CSS：</p><pre><code>.active-btn {    display: inline-block;     background-color: #cd0000;}.active-btn:active {    background-color: #ae0000;}</code></pre><p>JavaScript：</p><pre><code>var button = document.getElementById(&quot;button&quot;);if (button.addEventListener) {    button.addEventListener(&quot;mousedown&quot;, function(event) {    // 此处省略N行    event.preventDefault();        });}</code></pre><p>现象描述：在FireFox浏览器中，点击“正常情况按钮”会出现按钮点击样式，但点击“包含js的按钮”，则不会有按钮点击样式<img src="http://pvjdnjjsz.bkt.clouddn.com/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA.png" alt="CSS未定义行为"></p><p>原因分析：因为规范上并没有对这种场景的具体描述，所以FireFox认为：active发生在mousedown事件之后。（IE/Chrome反之认为）</p><blockquote><p>像这种规范估计不到的细枝末节的实现，就称之“未定义行为”</p></blockquote><h2 id="三、致谢"><a href="#三、致谢" class="headerlink" title="三、致谢"></a><label style="color:orange">三、致谢</label></h2><p>本文内容我对张鑫旭老师《CSS世界》一书第二章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS世界概述</title>
      <link href="/2019/07/31/CSS%E4%B8%96%E7%95%8C%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/07/31/CSS%E4%B8%96%E7%95%8C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到CSS世界，这里有几个比较大的平行世界，不同世界有浏览器王国的命运也不一样，这里还有许多厉害的魔法师哦！</p><a id="more"></a><h2 id="一、CSS世界的世界观"><a href="#一、CSS世界的世界观" class="headerlink" title="一、CSS世界的世界观"></a><label style="color:orange">一、CSS世界的世界观</label></h2><p>在CSS世界中：</p><h3 id="世界：操作系统"><a href="#世界：操作系统" class="headerlink" title="世界：操作系统"></a>世界：操作系统</h3><p>不同的操作系统代表了不同的评选世界，CSS世界有几个比较大的平行世界，即：</p><ul><li>Window世界</li><li>OS X世界</li><li>移动端iOS世界</li><li>Android世界</li></ul><h3 id="王国：浏览器"><a href="#王国：浏览器" class="headerlink" title="王国：浏览器"></a>王国：浏览器</h3><p>不同世界的浏览器王国的命运不一样，例如：</p><ul><li>在OS X世界中，IE王国是不存在的，而Safari王国异常强大</li><li>而在Window世界中，Safari王国异常落寞</li></ul><h3 id="魔法师：CSS属性"><a href="#魔法师：CSS属性" class="headerlink" title="魔法师：CSS属性"></a>魔法师：CSS属性</h3><p>CSS的各种属性值就是魔法师的魔法技能</p><h3 id="魔法石：HTML"><a href="#魔法石：HTML" class="headerlink" title="魔法石：HTML"></a>魔法石：HTML</h3><h3 id="选择法器：选择器"><a href="#选择法器：选择器" class="headerlink" title="选择法器：选择器"></a>选择法器：选择器</h3><p>例如，使用.umbrella法器，即可对所有class=”umbrella”的元素进行改变<img src="http://m.qpic.cn/psb?/V13nLLWw3zAuxK/sTc164X1TwdEzk5hA6CfmwVXr2uI3.SY*s5A4k*NUdo!/b/dLYAAAAAAAAA&bo=OASgBQAAAAARB6k!&rf=viewer_4" alt="CSS世界"></p><h2 id="二、CSS世界为什么被创造出来"><a href="#二、CSS世界为什么被创造出来" class="headerlink" title="二、CSS世界为什么被创造出来"></a><label style="color:orange">二、CSS世界为什么被创造出来</label></h2><h3 id="2-1-CSS的诞生"><a href="#2-1-CSS的诞生" class="headerlink" title="2.1 CSS的诞生"></a>2.1 CSS的诞生</h3><p>在最开始的时候，互联网领域的信息就是图片和文字，网站的功能就是信息展示。那时候的网站前端技术关心的是图片和文字的呈现，而</p><blockquote><p>CSS世界的诞生就是为图文信息展示服务</p></blockquote><h3 id="2-2-CSS完胜SVG的武器——流"><a href="#2-2-CSS完胜SVG的武器——流" class="headerlink" title="2.2 CSS完胜SVG的武器——流"></a>2.2 CSS完胜SVG的武器——流</h3><p>在很长一段时间里，网站的主要功能都是图片和文字信息的展示，而SVG的强项是图片，但是文字内容的呈现不敢恭维，所以SVG被打入冷宫，CSS一如既往被重用。</p><blockquote><p>CSS为什么有强大的图文显示能力？</p><p>流！</p></blockquote><h3 id="2-3-什么是流？"><a href="#2-3-什么是流？" class="headerlink" title="2.3 什么是流？"></a>2.3 什么是流？</h3><p>流，即是“文档流”的简称，“流”实际上是CSS世界中的一种基本的定位和布局机制，可以理解为现实世界的“水流”。</p><blockquote><p>“流”就是CSS世界中引导元素排列和定位的一条看不见的“水流”</p></blockquote><p>CSS世界构建的基石是HTML,而HTML最具代表的两个基石<div><span>正好是CSS世界中的块级元素和内联元素的代表，对应着盛水容器的水和木头</span></div></p><blockquote><p>现实中的水流：水流自动铺满容器，放入木头，水位升高，木头依次排序。<br>CSS世界中的流：div自动铺满容器，图片文字依次排列，不足则换行。</p></blockquote><h5 id="流是如何影响整个CSS世界的"><a href="#流是如何影响整个CSS世界的" class="headerlink" title="流是如何影响整个CSS世界的"></a>流是如何影响整个CSS世界的</h5><ul><li>通过控制HTML默认的表现符合流，来使流”统治CSS世界</li><li>通过破坏“流”来实现特殊布局</li><li>通过改变流的流向来改变表现形式</li></ul><h5 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h5><p>利用元素“流”的特性实现的各类布局效果。例如“div+CSS布局”</p><p><strong><em>注意</em></strong>：“自适应布局”是凡具有自适应特性的一类布局的统称，“流体布局要小寨的多。例如表格布局是自适应布局，但不是流体布局”</p><h3 id="2-4-CSS的世界的一些备注"><a href="#2-4-CSS的世界的一些备注" class="headerlink" title="2.4 CSS的世界的一些备注"></a>2.4 CSS的世界的一些备注</h3><ul><li>对CSS2.1的全面支持是从微软公司的IE8开始的。</li><li><table>比CSS还要老,他有自己的世界。“流”的特性对<table>并不适用，一些CSS属性的表现，如单元格的vertical-align，也和普通元素不一样。</table></table></li><li>CSS新世界——CSS3:布局更为丰富，视觉表现长足进步。</li></ul><h2 id="三、致谢"><a href="#三、致谢" class="headerlink" title="三、致谢"></a><label style="color:orange">三、致谢</label></h2><p>本文内容我对张鑫旭老师《CSS世界》一书第一章的学习笔记，感谢张鑫旭老师，也感谢阅读本文的你给我的鼓励!</p><p>作为一个前端小白，如果学习笔记中有错误的地方，还请不吝指点，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站成功，第一篇博客用来感谢TRHX的超详细小白建站教程</title>
      <link href="/2019/07/29/%E5%BB%BA%E7%AB%99%E6%88%90%E5%8A%9F%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%9D%A5%E6%84%9F%E8%B0%A2TRHX%E7%9A%84%E8%B6%85%E8%AF%A6%E7%BB%86%E5%B0%8F%E7%99%BD%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/29/%E5%BB%BA%E7%AB%99%E6%88%90%E5%8A%9F%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%9D%A5%E6%84%9F%E8%B0%A2TRHX%E7%9A%84%E8%B6%85%E8%AF%A6%E7%BB%86%E5%B0%8F%E7%99%BD%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>感谢TRHX的建站博客,真的非常详细，给予我莫大的帮助！另外在建站过程中，发现了一个需要注意的问题。</p><a id="more"></a><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a><label style="color:orange">致谢</label></h2><p>感谢TRHX的<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">“使用Github Pages和Hexo搭建自己的独立博客【超级详细的小白教程】”</a>,真的非常详细，给予我的网站莫大的帮助！感谢作者！</p><h2 id="建站过程中需要注意的问题"><a href="#建站过程中需要注意的问题" class="headerlink" title="建站过程中需要注意的问题"></a><label style="color:orange">建站过程中需要注意的问题</label></h2><h3 id="1、无法用“https-yangfff-github-io”打开网页的问题以及解决"><a href="#1、无法用“https-yangfff-github-io”打开网页的问题以及解决" class="headerlink" title="1、无法用“https:/yangfff.github.io”打开网页的问题以及解决"></a>1、无法用“https:/yangfff.github.io”打开网页的问题以及解决</h3><p><strong>问题描述：</strong>无法用“https:/yangfff.github.io”打开网页</p><p><strong>原因分析：</strong>没有配置号 Git 个人信息</p><p><strong>直接原因：</strong>在“ _config.yml 文件”中repository是SSH格式的，但是却没有将Github项目的 <code>Clone or download</code> 按钮，选择为 <code>Use SSH</code></p><pre><code> _config.yml 文件：deploy:  type: git  repository: git@github.com:yangfff/yangfff.github.io.git branch: master</code></pre><p><strong>解决方法：</strong>将Github项目的 <code>Clone or download</code> 按钮，选择为 <code>Use SSH</code><br><img src="http://m.qpic.cn/psb?/V13nLLWw3ji19U/YeJz.yQycFUU9uspOcjVTU4VkQCqloS*z.E6d4NIXPs!/b/dLYAAAAAAAAA&bo=YgGiAAAAAAADB.M!&rf=viewer_4" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/29/hello-world/"/>
      <url>/2019/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcom!Let’s Go!</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-1"><a href="#Create-a-new-post-1" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server-1"><a href="#Run-server-1" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-1"><a href="#Deploy-to-remote-sites-1" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
